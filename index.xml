<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>语千·刻一 on 彭浩 ~ Hao Peng</title>
    <link>/</link>
    <description>Recent content in 语千·刻一 on 彭浩 ~ Hao Peng</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 01 Jan 2005 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>LaTeX 黑魔法（三）：定义参数变长的命令 z</title>
      <link>/tech/2017/07/30/define-a-new-command-with-different-amount-of-parameters-in-latex/</link>
      <pubDate>Sun, 30 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/07/30/define-a-new-command-with-different-amount-of-parameters-in-latex/</guid>
      <description>
        &lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;a href=&#34;https://liam0205.me/2017/07/30/define-a-new-command-with-different-amount-of-parameters-in-LaTeX/&#34; target=&#34;_blank&#34;&gt;https://liam0205.me/2017/07/30/define-a-new-command-with-different-amount-of-parameters-in-LaTeX/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;在 C++ 中，我们可以为同一个函数赋予不同的执行内容，这种行为称之为「函数重载」。具体重载的函数，共享同一个函数名，但是接收的函数参数在数量、类型上不同。LaTeX 是宏语言，没有一般意义上的参数类型的说法。但是，有没有办法在 LaTeX 中「重载」一个宏，根据输入的参数数量不同，而产生不同的效果呢？&lt;/p&gt;

&lt;p&gt;本文给出解决方案。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h1 id=&#34;在-tex-和-latex2e-中定义新命令&#34;&gt;在 TeX 和 LaTeX2e 中定义新命令&lt;/h1&gt;

&lt;p&gt;TeX 中，定义新命令的标准方法是使用 TeX 原语 &lt;code&gt;\def&lt;/code&gt;。它有几个变种，记录如下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\def&lt;/code&gt;：局部定义，定义时不展开；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\edef&lt;/code&gt;：局部定义，定义时完全展开；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\gdef&lt;/code&gt;：相当于 &lt;code&gt;\global\def&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\xdef&lt;/code&gt;：相当于 &lt;code&gt;\global\edef&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;建立在 TeX 之上的各种格式，其提供的定义新命令的方案，都是通过这四个 &lt;code&gt;\def&lt;/code&gt; 来实现的。LaTeX2e 中定义新命令的标准方法是使用 &lt;code&gt;\newcommand&lt;/code&gt;。它也有几个变种，记录如下。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\newcommand&lt;/code&gt;：新定义一个命令，如果该命令已有定义，则报错；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\renewcommand&lt;/code&gt;：重定义一个命令，如果该命令未定义，则报错；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\providecommand&lt;/code&gt;：如果该命令未定义，则定义一个新的命令；否则，啥也不干。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当然，在 LaTeX2e 中，也有 &lt;code&gt;\DeclareRobustCommand&lt;/code&gt; 一系列命令，可以用来定义新的命令。这一系列命令，是 LaTeX2e 针对「脆弱命令」问题，提供的一些保护机制。此处不表。&lt;/p&gt;

&lt;p&gt;在标准的方法中，不论是 TeX 还是 LaTeX2e，都没有提供「参数变长」的实现方法。也就是说，如果不引入奇怪的技巧，我们在普通的 LaTeX 文稿中，是无法重载命令的。&lt;/p&gt;

&lt;h1 id=&#34;ifnextchar&#34;&gt;&lt;code&gt;\@ifnextchar&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;\@ifnextchar&lt;/code&gt; 是&lt;a href=&#34;/2015/04/10/how-to-list-unnumbered-section-in-the-table-of-contents/&#34;&gt;一个 LaTeX 内部宏&lt;/a&gt;。它的作用，是「预读」输入列表的下一个字符，然后判断预读的字符是否与作者期待的字符一致，执行不同的分支。&lt;/p&gt;

&lt;p&gt;例如，我们知道，LaTeX 命令的可选参数，默认是放在所有必选参数之前。那么，我们是否有可能让可选参数放在必选参数之后呢？答案当然是肯定的，利用 &lt;code&gt;\@ifnextchar&lt;/code&gt; 就可以做到。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;\documentclass{article}
\makeatletter
\newcommand{\foo@helper@i}[1]{One parameter: #1{}.}
\def\foo@helper@ii #1[#2]{Two parameters: #1{}, #2{}.}
\newcommand{\foo}[1]{%
\@ifnextchar[%
  {\foo@helper@ii{#1}}%
  {\foo@helper@i{#1}}%
}
\makeatother
\begin{document}
\foo{hello}

\foo{hello}[world]
\end{document}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来看 &lt;code&gt;\foo&lt;/code&gt; 的定义。它接收一个标准的 LaTeX 参数。因此不管是 &lt;code&gt;\foo{hello}&lt;/code&gt; 还是 &lt;code&gt;\foo{hello}[world]&lt;/code&gt;，LaTeX 都会把其中的 &lt;code&gt;\foo{hello}&lt;/code&gt; 先「吃下去」。接下来，LaTeX 会判断下一个字符是否为 &lt;code&gt;[&lt;/code&gt;。对于 &lt;code&gt;\foo{hello}&lt;/code&gt; 这种用法，下一个字符是换行符，因此判定失败，执行 &lt;code&gt;\foo@helper@i&lt;/code&gt;。而对于 &lt;code&gt;\foo{hello}[world]&lt;/code&gt; 这种用法，吃下去 &lt;code&gt;\foo{hello}&lt;/code&gt; 之后，输入流中剩下了 &lt;code&gt;[world]...&lt;/code&gt;，下一个字符正是 &lt;code&gt;[&lt;/code&gt;，因此执行 &lt;code&gt;\foo@helper@ii&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;对于 &lt;code&gt;\foo@helper@ii&lt;/code&gt;，它是使用 TeX 的原语 &lt;code&gt;\def&lt;/code&gt; 定义的命令。参数列表 &lt;code&gt;#1[#2]&lt;/code&gt; 表示该命令接受两个参数。第一个参数是标准的 TeX 参数——用分组包括起来。因此，上一步执行的 &lt;code&gt;\foo@helper@ii&lt;/code&gt; 将第一个参数喂给了 &lt;code&gt;\foo@helper@ii&lt;/code&gt;。接下来，&lt;code&gt;\foo@helper@ii&lt;/code&gt; 还要吃下去第二个参数。按照定义，第二个参数被方括号 &lt;code&gt;[]&lt;/code&gt; 所包围。因此 &lt;code&gt;[world]&lt;/code&gt; 中的 &lt;code&gt;world&lt;/code&gt; 被吃掉，作为第二个参数。&lt;/p&gt;

&lt;p&gt;最终输出如图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/LaTeX/option-brackets-later.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;bgroup&#34;&gt;&lt;code&gt;\bgroup&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;上面的 &lt;code&gt;\foo&lt;/code&gt; 命令，基本已经达成了我们的目标。只不过，第二个参数必须是用方括号表达的。当然这不是不可以，但强迫症选手们可能会希望第二个参数也能用花括号来界定。于是，强迫症们尝试把 &lt;code&gt;\@ifnextchar[&lt;/code&gt; 尝试换成了 &lt;code&gt;\@ifnextchar{&lt;/code&gt;。于是它们得到了报错&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;File ended while scanning use of...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是因为，TeX 遇到 &lt;code&gt;{&lt;/code&gt; 时，会将其解释为一个分组。因此，这种写法会造成 TeX 读入的分组不匹配。这样一来，我们就必须用 &lt;code&gt;\bgroup&lt;/code&gt; 来代替花括号。它的定义是 &lt;code&gt;\let\bgroup={&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;\documentclass{article}
\makeatletter
\newcommand{\foo@helper@i}[1]{One parameter: #1{}.}
\newcommand{\foo@helper@ii}[2]{Two parameters: #1{}, #2{}.}
\newcommand{\foo}[1]{%
\@ifnextchar\bgroup%
  {\foo@helper@ii{#1}}%
  {\foo@helper@i{#1}}%
}
\makeatother
\begin{document}
\foo{hello}

\foo{hello}{world}
\end{document}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一来，我们就实现了一个 &lt;code&gt;\foo&lt;/code&gt; 命令，在参数不同的情况下，具有不同的行为。&lt;/p&gt;

&lt;h1 id=&#34;xparse-宏包&#34;&gt;&lt;code&gt;xparse&lt;/code&gt; 宏包&lt;/h1&gt;

&lt;p&gt;基于 LaTeX3 的 &lt;code&gt;xparse&lt;/code&gt; 宏包给了我们新的选项。它提供的 &lt;code&gt;\NewDocumentCommand&lt;/code&gt; 命令&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:https-tex-stacke&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:https-tex-stacke&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，允许用户使用新的接口定义 LaTeX 命令。其形式为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;\NewDocumentCommand{&amp;lt;command&amp;gt;}{&amp;lt;parameter specificers&amp;gt;}{&amp;lt;replacement text&amp;gt;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如，以下两个定义，效果是一致的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;\usepackage{xparse}

\newcommand{\baz}[1]{I eat #1{}.}
\NewDocumentCommand{\bar}{m}{I eat #1{}.}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，参数标识符 &lt;code&gt;m&lt;/code&gt; 表示 &lt;code&gt;\bar&lt;/code&gt; 接收一个标准的 LaTeX 参数。除去 &lt;code&gt;m&lt;/code&gt; 之外，&lt;code&gt;xparse&lt;/code&gt; 宏包还提供了许多额外的参数标识符（具体参照其手册）。其中，&lt;code&gt;g&lt;/code&gt; 表示该参数是一个可选参数，并且以花括号界定其范围。当参数未给出时，参数值为 &lt;code&gt;-NoValue-&lt;/code&gt;；否则是实际的参数内容。此时我们可以用 &lt;code&gt;\IfNoValueTF&lt;/code&gt; 命令来做分支判断。&lt;/p&gt;

&lt;p&gt;于是，上述 &lt;code&gt;\foo&lt;/code&gt; 命令可以按如下方式实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;\documentclass{article}
\usepackage{xparse}
\NewDocumentCommand{\foo}{mg}{%
  \IfNoValueTF{#2}%
  {One parameter: #1{}.}%
  {Two parameters: #1{}, #2{}.}%
}
\begin{document}
\foo{hello}

\foo{hello}{world}
\end{document}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的实现方式，相对在 LaTeX2e 里用 &lt;code&gt;\@ifnextchar\bgroup&lt;/code&gt; 判断就简单清晰多了。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:https-tex-stacke&#34;&gt;可以从&lt;a href=&#34;https://tex.stackexchange.com/questions/49056/optional-arguments-in-def&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;学习一个关于 &lt;code&gt;\NewDocumentCommand&lt;/code&gt; 命令的更有意思的示例。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:https-tex-stacke&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
        
      </description>
    </item>
    
    <item>
      <title>用 minted 宏包实现语法高亮</title>
      <link>/tech/2017/07/20/minted/</link>
      <pubDate>Thu, 20 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/07/20/minted/</guid>
      <description>
        &lt;h1 id=&#34;listings-的麻烦&#34;&gt;&lt;code&gt;listings&lt;/code&gt; 的麻烦&lt;/h1&gt;

&lt;p&gt;在 LaTeX 中实现语法高亮的老牌方案是 &lt;a href=&#34;https://www.ctan.org/pkg/listings&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;listings&lt;/code&gt;&lt;/a&gt;，然而这种方案用起来非常麻烦：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;默认的字体效果很糟糕，居然是 Serif 系列的；&lt;/li&gt;
&lt;li&gt;定义一种新语言需要先耗费大量时间了解帮助手册，还可能需要了解很多奇怪的规则；&lt;/li&gt;
&lt;li&gt;代码&lt;strong&gt;跨页&lt;/strong&gt;时需要一些&lt;a href=&#34;http://bbs.ctex.org/forum.php?mod=viewthread&amp;amp;tid=53451&#34; target=&#34;_blank&#34;&gt;额外的工作&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;代码中的&lt;a href=&#34;http://stackoverflow.com/questions/432349/how-do-you-display-straight-quotes-instead-of-curly-quotes-when-using-latexs-l&#34; target=&#34;_blank&#34;&gt;单引号，双引号问题&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中文&lt;/strong&gt;支持&lt;a href=&#34;http://bbs.ctex.org/forum.php?mod=viewthread&amp;amp;tid=50241&#34; target=&#34;_blank&#34;&gt;问题&lt;/a&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:CTeX-76123-http&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:CTeX-76123-http&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/li&gt;
&lt;li&gt;甚至对 LaTeX 的语法高亮支持也需要做许多&lt;a href=&#34;/tech/2011/11/03/lsset-highlight-blackslash/&#34;&gt;额外工作&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;当然，不是说 &lt;code&gt;listings&lt;/code&gt; 包的功能不够强大，从《&lt;a href=&#34;/tech/2010/02/24/highlight-chunk/&#34;&gt;给语法高亮内容中的部分内容进行高亮标识&lt;/a&gt;》这个方案可以看到，利用 escape character 除了可以解决中文的问题外，还可以实现更多自定义的效果，比如《&lt;a href=&#34;https://tex.stackexchange.com/questions/22635/lstlistings-getting-pretty-equations-in-display-mode&#34; target=&#34;_blank&#34;&gt;在代码中添加公式&lt;/a&gt;》。如果是英文文档，定义一个类似于 &lt;code&gt;\verb|.|&lt;/code&gt; 的命令，实现 inline code 式的命令也很容易&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:bug-GitHub-282-h&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:bug-GitHub-282-h&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;因此，虽然 &lt;code&gt;listings&lt;/code&gt; 包理论上可以满足我们的需求，但是要解决特定的问题往往需要耗费相当的精力和时间，对初学者并不算太友好。&lt;/p&gt;

&lt;h1 id=&#34;minted-宏包需要的支持&#34;&gt;&lt;code&gt;minted&lt;/code&gt; 宏包需要的支持&lt;/h1&gt;

&lt;p&gt;LaTeX 中的 &lt;code&gt;minted&lt;/code&gt; 宏包实际上是调用 Python 的 &lt;code&gt;pygments&lt;/code&gt; 来完成语法高亮的，高亮效果好，支持的语法充分，可以实现代码内的公式&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:-&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:-&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;，通过 &lt;code&gt;\mintinline&lt;/code&gt; 命令实现&lt;strong&gt;行内代码&lt;/strong&gt;的同时&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Stack-Exchange-4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:Stack-Exchange-4&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;可以指定语言的名称&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Stack-Exchange-4&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:Stack-Exchange-4&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;，需要的额外配置少，唯一目前要做就是在安装完 Python 后，通过下面的命令安装 &lt;code&gt;pygments&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install pygments
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;之后编译时用下面的命令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;xelatex -shell-escape demo.tex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;lualatex -shell-escape demo.tex
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于使用 &lt;a href=&#34;http://blog.csdn.net/u011982340/article/details/40261735&#34; target=&#34;_blank&#34;&gt;WinEdt&lt;/a&gt; 或者 &lt;a href=&#34;https://tex.stackexchange.com/questions/170723/custom-build-settings-in-sublime&#34; target=&#34;_blank&#34;&gt;Sublime Text&lt;/a&gt; 界面接口的用户，可能选项 &lt;code&gt;-shell-escape&lt;/code&gt; 会比较麻烦一些，但由于自己是直接调用 bat 文件来处理编译问题，因此这个选项完全不是问题。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;现在 &lt;code&gt;knitr&lt;/code&gt; 转成 pdf 的语法高亮应该也是由 &lt;code&gt;pygments&lt;/code&gt; 完成的，并且完全不需要用户干预（不确定在 &lt;code&gt;knitr&lt;/code&gt; 时 &lt;code&gt;pygments&lt;/code&gt; 是否需要提前安装。）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;可能的麻烦&#34;&gt;可能的麻烦&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;提醒&lt;/strong&gt;：尝试在 CTeX 2.9.2 下面直接将&lt;a href=&#34;https://github.com/gpoore/minted&#34; target=&#34;_blank&#34;&gt;最新版&lt;/a&gt;的 &lt;code&gt;minted&lt;/code&gt; 相关文件复制到相应的目录，但结果出错，说找不到 &lt;a href=&#34;https://github.com/gpoore/fvextra&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;fvextra&lt;/code&gt;&lt;/a&gt; 宏包，然而添加了该宏包之后仍然会有其它错误，估计是相关的依赖包没有更新的原因，因此推荐使用最新版的 TeXLive 或者将整个 CTeX 套装的宏包都进行更新来解决这个问题，但是在线更新 MikTeX 之后，再更新相关宏包时，同样会出现各种各样的奇怪问题，像 &lt;code&gt;picins&lt;/code&gt; 这要的宏包甚至会认为是过时的而直接删除，导致其它很多麻烦，最终放弃更新 CTeX。&lt;/p&gt;

&lt;p&gt;好像更新新的 &lt;code&gt;ctex&lt;/code&gt; 宏包后，&lt;code&gt;ctexsetup&lt;/code&gt; 命令也不再推荐使用。&lt;/p&gt;

&lt;h1 id=&#34;简单例子&#34;&gt;简单例子&lt;/h1&gt;

&lt;p&gt;这个例子来自 &lt;a href=&#34;https://zhuanlan.zhihu.com/p/27996164&#34; target=&#34;_blank&#34;&gt;https://zhuanlan.zhihu.com/p/27996164&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;\documentclass[a4paper]{article}
\usepackage{minted}
\usepackage{xcolor}
\definecolor{bg}{rgb}{0.95,0.95,0.95} 
\usepackage[margin=2.5cm]{geometry}
\begin{document}

\begin{minted}[bgcolor=bg]{rust}
fn foo(v1: Vec&amp;lt;i32&amp;gt;, v2: Vec&amp;lt;i32&amp;gt;) -&amp;gt; (Vec&amp;lt;i32&amp;gt;, Vec&amp;lt;i32&amp;gt;, i32) {
    // Do stuff with `v1` and `v2`.
    // Hand back ownership, and the result of our function.
    (v1, v2, 42)
}

let v1 = vec![1, 2, 3];
let v2 = vec![1, 2, 3];

let (v1, v2, answer) = foo(v1, v2);
\end{minted}

\begin{minted}[bgcolor=bg]{go}
import &amp;quot;math&amp;quot;

type Shape interface {
    Area() float64
}

type Square struct { // Note: no &amp;quot;implements&amp;quot; declaration
    side float64
}

func (sq Square) Area() float64 { return sq.side * sq.side }

type Circle struct { // No &amp;quot;implements&amp;quot; declaration here either
    radius float64
}

func (c Circle) Area() float64 { return math.Pi * math.Pow(c.radius, 2) }
\end{minted}

\end{document}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是实际的高亮效果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/LaTeX/minted-exm.png&#34; alt=&#34;`minted` 语法高亮&#34; /&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:CTeX-76123-http&#34;&gt;中文支持后期已经基本解决，参考 &lt;a href=&#34;http://bbs.ctex.org/forum.php?mod=viewthread&amp;amp;tid=76123&#34; target=&#34;_blank&#34;&gt;CTeX #76123&lt;/a&gt; 和 &lt;a href=&#34;http://bbs.ctex.org/forum.php?mod=viewthread&amp;amp;tid=77046&#34; target=&#34;_blank&#34;&gt;CTeX #77046&lt;/a&gt;。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:CTeX-76123-http&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:bug-GitHub-282-h&#34;&gt;中文里面还有 bug，参见 &lt;a href=&#34;https://github.com/CTeX-org/ctex-kit/issues/282&#34; target=&#34;_blank&#34;&gt;GitHub #282&lt;/a&gt; 以及《&lt;a href=&#34;/tech/2017/03/07/lstlistings-bgcolor/&#34;&gt;语法高亮：在 &lt;code&gt;lstinline&lt;/code&gt; 中给行内代码添加背景颜色 z&lt;/a&gt;》。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:bug-GitHub-282-h&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:-&#34;&gt;参见帮助文档。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:-&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:Stack-Exchange-4&#34;&gt;可进一步参考 &lt;a href=&#34;https://tex.stackexchange.com/questions/45756/inline-code-and-short-verb-with-minted&#34; target=&#34;_blank&#34;&gt;Stack Exchange #45756&lt;/a&gt;。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Stack-Exchange-4&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:Stack-Exchange-4&#34;&gt;参考 &lt;a href=&#34;https://tex.stackexchange.com/questions/45756/inline-code-and-short-verb-with-minted&#34; target=&#34;_blank&#34;&gt;Stack Exchange #45756&lt;/a&gt;，这个功能需要 &lt;code&gt;minted&lt;/code&gt; 2.0 以上版本，CTeX 2.9.2 套装默认的版本不行。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Stack-Exchange-4&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
        
      </description>
    </item>
    
    <item>
      <title>在 RStudio 中使用 GitHub</title>
      <link>/tech/2017/07/14/github-in-rstudio/</link>
      <pubDate>Fri, 14 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/07/14/github-in-rstudio/</guid>
      <description>
        &lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#basic-knowledge&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1&lt;/span&gt; 基本知识&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#configuration-list&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.1&lt;/span&gt; 查看配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#gen-set-keys&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2&lt;/span&gt; 生成、配置密钥&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#gen-keys&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.1&lt;/span&gt; 生成密钥&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#set-keys&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.2&lt;/span&gt; 配置密钥&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#test-connection&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.3&lt;/span&gt; 测试连接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-rstudio--github&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3&lt;/span&gt; 在 RStudio 中使用 GitHub&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#-github-pages&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.1&lt;/span&gt; 发布到 GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-github-&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.2&lt;/span&gt; 连接 GitHub 可能遇到的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;basic-knowledge&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; 基本知识&lt;/h1&gt;
&lt;p&gt;Git 共有三个级别的 config 文件，分别是 system、global 和 local。在当前环境中，分别对应 &lt;code&gt;%GitPath%\mingw64\etc\gitconfig&lt;/code&gt; 文件、&lt;code&gt;$home\.gitconfig&lt;/code&gt; 文件和 &lt;code&gt;%RepoPath%\.git\config&lt;/code&gt; 文件。其中 &lt;code&gt;%GitPath%&lt;/code&gt; 为 Git 的安装路径，&lt;code&gt;%RepoPath%&lt;/code&gt; 为某仓库的本地路径。所以 system 配置整个系统只有一个，global 配置每个账户只有一个，而 local 配置和 git 仓库的数目相同，并且只有在仓库目录才能看到该配置。&lt;/p&gt;
&lt;div id=&#34;configuration-list&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.1&lt;/span&gt; 查看配置&lt;/h2&gt;
&lt;p&gt;参考资料：&lt;a href=&#34;http://www.jianshu.com/p/0ad3d88c51f4&#34; class=&#34;uri&#34;&gt;http://www.jianshu.com/p/0ad3d88c51f4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于之前已经成功安装 Git 并登陆到过 GitHub，因此查看当前配置时，最后两行会显示用户名及用户密码。&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;$ git config --list | grep user
user.name=xxxxxx
user.email=xxxxxx@xxxx.com&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;user.name&lt;/code&gt; 和 &lt;code&gt;user.email&lt;/code&gt; 就是 Author 信息。此时，上面提到的三个级别都配置了 user 信息。当 &lt;code&gt;git commit&lt;/code&gt; 时，Author 信息依次读取 local、global 和 system 的配置，如果找到则不再继续读取。其他配置的读取顺序也是如此。&lt;/p&gt;
&lt;p&gt;GitHub 支持 https 和 ssh 协议连接。下面以较为安全的 ssh 方式作为示例进行说明。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;gen-set-keys&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;2&lt;/span&gt; 生成、配置密钥&lt;/h1&gt;
&lt;div id=&#34;gen-keys&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.1&lt;/span&gt; 生成密钥&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;由于之前已经生成过密钥并成功登陆过 GitHub，这里暂时不考虑多账号切换登陆的做法，因此直接 &lt;code&gt;cd ~/.ssh&lt;/code&gt; 切换到 SSH 所在目录，将其中的 &lt;code&gt;id_rsa&lt;/code&gt; 和 &lt;code&gt;id_rsa.pub&lt;/code&gt; 备份好后删除掉。&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;git config --global user.name &amp;quot;haopen&amp;quot;&lt;/code&gt; 和 &lt;code&gt;git config --global user.email haopeng.yn@gmail.com&lt;/code&gt; 切换到新的账号，还可以用 &lt;code&gt;git config --global user.name&lt;/code&gt; 和 &lt;code&gt;git config --global user.email&lt;/code&gt; 看账号是否添加成功。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;$ git config --global user.name &amp;quot;haopen&amp;quot;
$ git config --global user.email haopeng.yn@gmail.com

$ git config --global user.name
haopen
$ git config --global user.email
haopeng.yn@gmail.com

$ git config --list
......
user.name=haopen
user.email=haopeng.yn@gmail.com&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;接下来输入 &lt;code&gt;ssh-keygen -t rsa -C &amp;quot;haopeng.yn@gmail.com&amp;quot;&lt;/code&gt; 生成新的密钥。根据&lt;a href=&#34;http://www.cnblogs.com/qcwblog/p/5709720.html&#34;&gt;这篇博文&lt;/a&gt;的例子，在下面生成密钥文件时一路回车，不指定任何文件名称，直接使用系统默认的名称，到最后一步时密钥生成成功！&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class=&#34;txt&#34;&gt;&lt;code&gt;$ ssh-keygen -t rsa -C &amp;quot;haopeng.yn@gmail.com&amp;quot;
Generating public/private rsa key pair.
Enter file in which to save the key (/c/Users/haopeng/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /c/Users/haopeng/.ssh/id_rsa.
Your public key has been saved in /c/Users/haopeng/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:ZH9aXjek6jUT7DWIe7SBrlFGuy50SjseMTtg5HSZLJw haopeng.yn@gmail.com
The key&amp;#39;s randomart image is:
+---[RSA 2048]----+
|                 |
|      . o o      |
|       Eo= .   . |
|      +oo.. = +  |
|       +So.*oB.+.|
|      . .oB**.=.o|
|        o===.B   |
|         =B o o  |
|        .ooo     |
+----[SHA256]-----+&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;set-keys&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.2&lt;/span&gt; 配置密钥&lt;/h2&gt;
&lt;p&gt;复制前一步中生成的 &lt;code&gt;id_rsa.pub&lt;/code&gt; 中的内容，之后登陆到 GitHub，在右上角的头像上点击 &lt;code&gt;Settings - SSH and GPG keys&lt;/code&gt;，点击右边的 &lt;code&gt;New SSH Key&lt;/code&gt;，然后将复制好的内容粘贴进去，标题自己随意取一个，比如 &lt;code&gt;haopen&#39;s key&lt;/code&gt;，这样就完成了远程端的配置。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;test-connection&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.3&lt;/span&gt; 测试连接&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：在 Git Bash Shell 中输入如下命令后连接&lt;strong&gt;失败&lt;/strong&gt;！&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;ssh -T git@github.com&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;Warning: Permanently added the RSA host key for IP address ‘192.30.255.112’ to the list of known hosts. Permission denied (publickey).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在网上查阅资料后，感觉有类似经历的人的解决方法似乎都与自己面临的情况不完全吻合，无意中看到 &lt;code&gt;~/.ssh&lt;/code&gt; 目录中有一个名称为 &lt;code&gt;known_hosts&lt;/code&gt; 的文件，尝试将其删除后再重新进行了前面的第 1 步和第 2 步，这次再测试时就&lt;strong&gt;成功&lt;/strong&gt;了。&lt;/p&gt;
&lt;pre class=&#34;txt&#34;&gt;&lt;code&gt;$ ssh -T git@github.com
The authenticity of host &amp;#39;github.com (192.30.255.113)&amp;#39; can&amp;#39;t be established.
RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &amp;#39;github.com,192.30.255.113&amp;#39; (RSA) to the list of known hosts.
Hi haopen! You&amp;#39;ve successfully authenticated, but GitHub does not provide shell access.&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;-rstudio--github&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;3&lt;/span&gt; 在 RStudio 中使用 GitHub&lt;/h1&gt;
&lt;p&gt;到 GitHub 的网站上新添加一个代码仓库（包含 &lt;code&gt;readme.md&lt;/code&gt;），然后打开 RStudio，&lt;code&gt;File - New Project - Version Control - Git&lt;/code&gt;，输入 &lt;code&gt;Repository URL&lt;/code&gt;（要输入的内容可以在 GitHub 代码仓库右方点 &lt;code&gt;Clone or download&lt;/code&gt; 找到），其中 &lt;code&gt;Project directory name&lt;/code&gt; 用于设定项目所在文件夹的名称，&lt;code&gt;Create project as subdirectory of&lt;/code&gt; 用于指定该文件夹所属的父目录，此外勾选 &lt;code&gt;Open in new session&lt;/code&gt;，接下来 RStudio 会将该仓库中的内容 Pull 到本地。&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Tech/GitHub/RStudio/NewProject-Git-RStudio.png&#34; alt=&#34;创建一个 Git Repository：Step 1&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;创建一个 Git Repository：Step 1&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Tech/GitHub/RStudio/NewProject-Git-RStudio1.png&#34; alt=&#34;创建一个 Git Repository：Step 2&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;创建一个 Git Repository：Step 2&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Tech/GitHub/RStudio/Create-Git-Repository.png&#34; alt=&#34;创建一个 Git Repository：Step 3&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;创建一个 Git Repository：Step 3&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;成功之后显示如下内容：&lt;/p&gt;
&lt;pre class=&#34;txt&#34;&gt;&lt;code&gt;C:/Program Files/.../git.exe clone --progress git@github.com:haopen/Blogdown.git Blogdown&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;尝试添加文件并保存到，点击右边 Git 面板中的 &lt;code&gt;Commit&lt;/code&gt;（直接在 Git 面板中某个文件上点右键，选择 &lt;code&gt;ignore&lt;/code&gt; 可以指定应忽略跳过的文件），可以在打开的窗口中勾选需要 Commit 的文件，之后在右半边窗口中填写简单的描述文字，之后可以点击下方的 &lt;code&gt;Commit&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Tech/GitHub/RStudio/RStudio-Commit.png&#34; alt=&#34;提交一个 Commit&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;提交一个 Commit&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：Commit 完成之后，刚开始右上角并没有 &lt;code&gt;Pull&lt;/code&gt; 向上箭头，并且尝试提交时会出现 &lt;code&gt;unable to access... The requested URL returned error: 403&lt;/code&gt; 类的错误，根据&lt;a href=&#34;https://stackoverflow.com/questions/7438313/pushing-to-git-returning-error-code-403-fatal-http-request-failed&#34;&gt;这个讨论&lt;/a&gt;，在本地目录中找到隐藏的 &lt;code&gt;.git/config&lt;/code&gt;，将其中的&lt;/p&gt;
&lt;pre class=&#34;txt&#34;&gt;&lt;code&gt;url = https://haopen@github.com/derekerdmann/lunch_call.git&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;url = ssh://git@github.com/haopen/testGit.git&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后再次提交成功，并且上图右上角出现 &lt;code&gt;Pull&lt;/code&gt; 向上箭头。当然，&lt;strong&gt;更好的做法&lt;/strong&gt;是在点 &lt;code&gt;Clone or download&lt;/code&gt; 时，直接点击 &lt;code&gt;Use SSH&lt;/code&gt;，然后复制 &lt;code&gt;git@github.com:haopen/testGit.git&lt;/code&gt; 即可。&lt;/p&gt;
&lt;div id=&#34;-github-pages&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.1&lt;/span&gt; 发布到 GitHub Pages&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;先到 GitHub 创建一个名称为 &lt;code&gt;haopen.github.io&lt;/code&gt; 的代码仓库；&lt;/li&gt;
&lt;li&gt;之后 Clone 到本地&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;：参考前面在 RStudio 中 Clone Repository 的步骤，也可以先进入到 &lt;code&gt;D:\GitHub&lt;/code&gt;，再点击右键，选择 &lt;code&gt;Git GUI Here&lt;/code&gt;，在打开的窗口中选择 &lt;code&gt;Clone Existing Repository&lt;/code&gt;，参考下图填写内容即可：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Tech/GitHub/RStudio/CloneExistingRepository.png&#34; alt=&#34;Git 客户端&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Git 客户端&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Tech/GitHub/RStudio/CloneExistingRepositoryRStudio.png&#34; alt=&#34;RStudio 中的 Git 客户端&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;RStudio 中的 Git 客户端&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;其中 &lt;code&gt;haopen-public&lt;/code&gt; 是在 Hugo 中的 &lt;code&gt;.Rprofile&lt;/code&gt; 中指定的内容发布目录，对应的绝对地址是 &lt;code&gt;D:\GitHub\haopen-public&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;做一个 Commit，之后再 Push，等 Push 完成就可以在 &lt;a href=&#34;https://haopen.github.io/&#34; class=&#34;uri&#34;&gt;https://haopen.github.io/&lt;/a&gt; 观察到发布后的页面效果。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;-github-&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.2&lt;/span&gt; 连接 GitHub 可能遇到的问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;：Push 的时候可能会遇到如下的错误：&lt;/p&gt;
&lt;pre class=&#34;txt&#34;&gt;&lt;code&gt;Git push origin 
ssh: Could not resolve hostname ssh.github.com: Name or service not known 
fatal: Could not read from remote repository.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考 &lt;a href=&#34;http://blog.csdn.net/qq_17335153/article/details/51701700&#34; class=&#34;uri&#34;&gt;http://blog.csdn.net/qq_17335153/article/details/51701700&lt;/a&gt; 的说明，打开 &lt;code&gt;~/.ssh&lt;/code&gt;，在里面新建一个名称为 &lt;code&gt;config&lt;/code&gt; 的文件，注意没有扩展名，在其中添加内容：&lt;/p&gt;
&lt;pre class=&#34;txt&#34;&gt;&lt;code&gt;Host github.com
User haopeng.yn@gmail.com
Hostname ssh.github.com
PreferredAuthentications publickey
IdentityFile ~/.ssh/id_rsa
Port 443&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是通过 &lt;code&gt;ssh -T git@github.com&lt;/code&gt; 测试仍然报错：&lt;/p&gt;
&lt;pre class=&#34;txt&#34;&gt;&lt;code&gt;ssh: Could not resolve hostname github.com: Name or service not known
fatal: The remote end hung up unexpectedly&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考 &lt;a href=&#34;http://blog.sina.com.cn/s/blog_a3fb1fe30102wieq.html&#34; class=&#34;uri&#34;&gt;http://blog.sina.com.cn/s/blog_a3fb1fe30102wieq.html&lt;/a&gt; 先通过 &lt;code&gt;ping github.com&lt;/code&gt; 获得 ip 地址 &lt;code&gt;192.30.255.113&lt;/code&gt;，之后在 &lt;code&gt;/etc/hosts&lt;/code&gt; 中添加如下内容&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;192.30.255.113 github.com&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再测试时就没有问题&lt;a href=&#34;#fn3&#34; class=&#34;footnoteRef&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&#34;txt&#34;&gt;&lt;code&gt;$ ssh -T git@github.com
The authenticity of host &amp;#39;[ssh.github.com]:443 ([192.30.253.123]:443)&amp;#39; can&amp;#39;t be established.
RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added &amp;#39;[ssh.github.com]:443,[192.30.253.123]:443&amp;#39; (RSA) to the list of known hosts.
Hi haopen! You&amp;#39;ve successfully authenticated, but GitHub does not provide shell access.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;技巧&lt;/strong&gt;：在 RStudio 第一次准备将本地大量文件 Commit 时，右侧 Git 面板中的 &lt;code&gt;Staged&lt;/code&gt; 对应的 Checkbox 经常点不动，参考 &lt;a href=&#34;https://pages.github.com/&#34; class=&#34;uri&#34;&gt;https://pages.github.com/&lt;/a&gt; 后此时可以考虑从齿轮那里打开 RStudio 带的 Git shell，然后在里面输入&lt;a href=&#34;#fn4&#34; class=&#34;footnoteRef&#34; id=&#34;fnref4&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;git add --all
~$git commit -m &amp;quot;Initial commit&amp;quot;
~$git push -u origin master&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种命令行的方式此时可能会更加方便一些。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;可以考虑使用直接使用 Git GUI Here 客户端，也可以考虑使用 RStudio 提供的界面，通常后者可能会更人性化一些。&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;修改 &lt;code&gt;C:\Windows\System32\drivers\etc\hosts&lt;/code&gt; 这个文件时，经常提示有其它程序占用，因此转而修改 &lt;code&gt;C:\Program Files\Git\etc\hosts&lt;/code&gt;，效果也是一样的。&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;但连接速度真的很慢。&lt;a href=&#34;#fnref3&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34;&gt;&lt;p&gt;要在这个自带的 Shell 窗口中粘贴内容，只能在窗口的标题栏点击右击，再选择“编辑”，之后选择“粘贴”。&lt;a href=&#34;#fnref4&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>添加 lightGallery 功能到 Hugo</title>
      <link>/tech/2017/07/10/hugo-light-gallery/</link>
      <pubDate>Mon, 10 Jul 2017 23:49:00 -2359</pubDate>
      
      <guid>/tech/2017/07/10/hugo-light-gallery/</guid>
      <description>
        &lt;p&gt;Hexo 中用的 jQuery FancyBox 本来效果也不错，但是在移植这部分功能的时候并不顺利，又在搜索解决方案的时候看到了 lightGallery，配置和使用感觉都非常好，因此决定将 lightGallery 的图片浏览功能移植过来。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;下载相关文件并复制到恰当的目录；&lt;/li&gt;
&lt;li&gt;在模板文件中的适当位置，主要是 &lt;code&gt;header&lt;/code&gt; 相关部分添加样式文件，在 &lt;code&gt;footer&lt;/code&gt; 相关部分添加 js 相关的文件；&lt;/li&gt;
&lt;li&gt;一个比较麻烦的地方是，这个插件要求全部图片按比较规范的格式放到一个有 &lt;code&gt;id&lt;/code&gt; 的 html 标记容器之中，思考尝试再三，最后通过 &lt;a href=&#34;/js/lgGallery_Prepare.js&#34;&gt;&lt;code&gt;lgGallery_Prepare.js&lt;/code&gt;&lt;/a&gt; 文件大致达到了相应的目的；&lt;/li&gt;
&lt;li&gt;主要思路是先通过 js 遍历页面中的全部 &lt;code&gt;img&lt;/code&gt; 元素，提取 &lt;code&gt;src&lt;/code&gt; 属性并在一个隐藏的 &lt;code&gt;div&lt;/code&gt; 中按 lightGallery 要求的&lt;a href=&#34;http://sachinchoolur.github.io/lightGallery/demos/html-markup.html&#34; target=&#34;_blank&#34;&gt;格式&lt;/a&gt;再动态生成一遍。之后再通过 js 给原有的每张图片添加一个 &lt;code&gt;onclick&lt;/code&gt; 属性，用于监听点击事件并通过 js 模拟点击隐藏 &lt;code&gt;div&lt;/code&gt; 中对应的图片文件，最后由 lightGallery 监听到隐藏 &lt;code&gt;div&lt;/code&gt; 中的点击事件并最终达到浏览图片的目的；
&lt;ul&gt;
&lt;li&gt;不管是用 &lt;code&gt;setAttribute&lt;/code&gt; 还是用 &lt;code&gt;createAttributes&lt;/code&gt; 创建属性，最后除了 &lt;code&gt;onclick&lt;/code&gt; 属性被传递出去外，其它的自定义名称的属性都不成功；&lt;/li&gt;
&lt;li&gt;要想在后面的代码中通过 &lt;code&gt;document.getElementById()&lt;/code&gt; 的方式获取，就不能用 &lt;code&gt;innerHTML&lt;/code&gt; 的方式，而要用 &lt;code&gt;createElement&lt;/code&gt; 的方式；&lt;/li&gt;
&lt;li&gt;没有通过 &lt;code&gt;addEventListener&lt;/code&gt; 给对象添加匿名函数的方式来处理，因为这时还没有完成 &lt;code&gt;div&lt;/code&gt; 中内容的生成，这会导致后续的监听处理程序找不到动态生成的对象；&lt;/li&gt;
&lt;li&gt;对 &lt;code&gt;onclick&lt;/code&gt; 属性，同时传递自身与事件的代码为 &lt;code&gt;javascript: lg_click(event, this);&lt;/code&gt;，注意这里的 &lt;code&gt;event&lt;/code&gt; 和 &lt;code&gt;this&lt;/code&gt; 的顺序不能反，否则后面 &lt;code&gt;lg_click()&lt;/code&gt; 中引用时会找不到对象，因此基本可以认为是固定用法。当然，只传递 &lt;code&gt;event&lt;/code&gt; 或者 &lt;code&gt;this&lt;/code&gt; 在语法上也是可行的；&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;lg_click()&lt;/code&gt; 中要记得禁止点击事件向上冒泡；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后，完整的配置文档可以从&lt;a href=&#34;http://sachinchoolur.github.io/lightGallery/docs/api.html&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;找到。根据这个示例&lt;a href=&#34;http://www.16css.com/jdt/1304.html&#34; target=&#34;_blank&#34;&gt;配置文件&lt;/a&gt;以及&lt;a href=&#34;http://sachinchoolur.github.io/lightGallery/demos/dynamic.html&#34; target=&#34;_blank&#34;&gt;官方示例文件&lt;/a&gt;的说明，其实可以用 js 生成一个指定格式的数据对象，最后交由 lightGallery 来使用，但由于监听事件是与某个具体 &lt;code&gt;id&lt;/code&gt; 的容器联系的，因此这种动态的方法与本站需要的点击某张图片打开浏览窗口的需求并不一致。&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>添加本地搜索功能到 Hugo</title>
      <link>/tech/2017/07/10/hugo-local-search/</link>
      <pubDate>Mon, 10 Jul 2017 23:13:00 -2323</pubDate>
      
      <guid>/tech/2017/07/10/hugo-local-search/</guid>
      <description>
        

&lt;p&gt;Yihui &lt;a href=&#34;https://github.com/yihui/yihui.name&#34; target=&#34;_blank&#34;&gt;修改过的主题&lt;/a&gt;并不提供本地搜索功能，但 &lt;a href=&#34;https://hexo.io/&#34; target=&#34;_blank&#34;&gt;Hexo&lt;/a&gt; 的 &lt;a href=&#34;http://theme-next.iissnan.com/&#34; target=&#34;_blank&#34;&gt;NexT&lt;/a&gt; 主题却有一个插件（&lt;a href=&#34;https://github.com/iissnan/hexo-theme-next/blob/master/layout/_third-party/search/localsearch.swig&#34; target=&#34;_blank&#34;&gt;JS&lt;/a&gt;、&lt;a href=&#34;https://github.com/iissnan/hexo-theme-next/blob/master/layout/_partials/search/localsearch.swig&#34; target=&#34;_blank&#34;&gt;html&lt;/a&gt;、&lt;a href=&#34;https://github.com/iissnan/hexo-theme-next/blob/master/source/css/_common/components/third-party/localsearch.styl&#34; target=&#34;_blank&#34;&gt;css&lt;/a&gt;）可以实现该功能，可以考虑将这个功能移植过来。&lt;/p&gt;

&lt;h1 id=&#34;模板文件&#34;&gt;模板文件&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;按 Hugo 的规模将 js, html, css 文件复制到对应的目录，并在模板文件中添加对应的引用；&lt;/li&gt;
&lt;li&gt;修改 css 的定义，实现与现有主题的风格搭配；&lt;/li&gt;
&lt;li&gt;js 文件中找到关键的三处配置，一是 &lt;code&gt;.xml&lt;/code&gt; 数据文件的路径，二是每条 Post 中匹配关键词的文本片断的数量，三是搜索的触发方式是 onkeypress 还是 enter 式，对应于 &lt;code&gt;auto&lt;/code&gt; 和 &lt;code&gt;manual&lt;/code&gt; 两个选择；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(&#39;.popup&#39;).detach().appendTo(&#39;...&#39;)&lt;/code&gt; 这里的 &lt;code&gt;appendTo&lt;/code&gt; 实际上是随意指定的，要更换成本主题的某个 html 标记容器，这个地方的错误查了将近 7 个小时；&lt;/li&gt;
&lt;li&gt;搜索引擎 js 文件可以异步加载，但是 &lt;code&gt;jQuery.min.js&lt;/code&gt; 文件却最好直接加载，以避免引起不必要的麻烦；&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;数据文件&#34;&gt;数据文件&lt;/h1&gt;

&lt;p&gt;xml 数据文件在 Hugo 中的生成有些特殊，可按下面的步骤进行：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;添加如下代码到 &lt;code&gt;\contents\search-index.md&lt;/code&gt; 文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
date: &amp;quot;2017-03-05T21:10:52+01:00&amp;quot;
type: &amp;quot;search&amp;quot;
url: &amp;quot;search.xml&amp;quot;
---
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;添加模板文件到 &lt;code&gt;/layouts/search/single.html&lt;/code&gt;。这个文件中的 &lt;code&gt;search&lt;/code&gt; 路径由第 1 点中的 &lt;code&gt;type&lt;/code&gt; 取舍指定，而 &lt;code&gt;single.html&lt;/code&gt; 是 Hugo 的模板优先级规则确定的；&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：根据模板文件生成 xml 文件在 Hugo 中并不方便，原因是 Hugo 会将模板文件中的 &lt;code&gt;&amp;lt;&lt;/code&gt; 强制转换成 &lt;code&gt;&amp;amp;lt;&lt;/code&gt;，而 &lt;a href=&#34;https://github.com/gohugoio/hugo/issues/1740&#34; target=&#34;_blank&#34;&gt;https://github.com/gohugoio/hugo/issues/1740&lt;/a&gt; 提供的 hack 手段比较好的解决了这个问题，具体的实现当然还需要根据实际情况做相应调整，可以参见这个模板文件的内容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;{{ `&amp;lt;?xml` | safeHTML }} version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot; ?&amp;gt;
&amp;lt;!-- Hugo 在转换模板时，&amp;lt; 这个符号总是被强制转换为 &amp;amp;lt; --&amp;gt;
&amp;lt;!-- 根据 https://github.com/gohugoio/hugo/issues/1740 使用如下的 Hack 可以解决 --&amp;gt;
&amp;lt;!-- part1 和 part2 的内容在 &amp;quot;/cn/&amp;quot; 这样的情形中，前者是 cn，后者是 /cn/ --&amp;gt;
&amp;lt;!-- 第一个 if：是不是只有一级路径 /cn/ --&amp;gt;
&amp;lt;!-- 第二个 if：是不是特殊的二级路径 --&amp;gt;
&amp;lt;!-- 第三个 if：是不是特殊的一级路径 --&amp;gt;
&amp;lt;!-- 第四个 if：search.xml 和 主页 --&amp;gt;

&amp;lt;search&amp;gt;
    {{ range $index, $page := .Site.Pages }}
    {{ $.Scratch.Set &amp;quot;Part1&amp;quot; (replaceRE &amp;quot;^/([^/]+)/.*&amp;quot; &amp;quot;$1&amp;quot; $page.RelPermalink) }}
    {{ $.Scratch.Set &amp;quot;Part2&amp;quot; (replaceRE &amp;quot;^/([^/]+)/([^/]+)/.*&amp;quot; &amp;quot;$2&amp;quot; $page.RelPermalink) }}
    {{ $.Scratch.Set &amp;quot;Part2&amp;quot; (replace Part2 &amp;quot;/&amp;quot; &amp;quot;&amp;quot; ) }}
    &amp;lt;!-- 上面两行在真实代码中被合并成了一行 --&amp;gt;
    {{ if not (eq ($.Scratch.Get &amp;quot;Part1&amp;quot;) ($.Scratch.Get &amp;quot;Part2&amp;quot;)) }}
    {{ if not (in (split &amp;quot;tags,categories,vitae,about&amp;quot; &amp;quot;,&amp;quot;) ($.Scratch.Get &amp;quot;Part2&amp;quot;)) }}
    {{ if not (in (split &amp;quot;tags,categories&amp;quot; &amp;quot;,&amp;quot;) ($.Scratch.Get &amp;quot;Part1&amp;quot;)) }}
    {{ if not (or (eq $page.Title &amp;quot;&amp;quot;) (eq $page.RelPermalink &amp;quot;/&amp;quot;)) }}
    &amp;lt;entry&amp;gt;
        {{ `&amp;lt;title&amp;gt;&amp;lt;!` | safeHTML }}[CDATA[{{ $page.Title }}]]&amp;gt;&amp;lt;/title&amp;gt;
        &amp;lt;url&amp;gt;{{ $page.RelPermalink }}&amp;lt;/url&amp;gt;
        {{ `&amp;lt;content type=&amp;quot;text&amp;quot;&amp;gt;&amp;lt;!` |safeHTML }}[CDATA[{{ $page.PlainWords }}]]&amp;gt;&amp;lt;/content&amp;gt;
    &amp;lt;/entry&amp;gt;
    {{ end }}{{ end }}{{ end }}{{ end }}{{ end }}
&amp;lt;/search&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

        
      </description>
    </item>
    
    <item>
      <title>添加标签云页面到 Hugo</title>
      <link>/tech/2017/07/10/tags-cloud/</link>
      <pubDate>Mon, 10 Jul 2017 19:22:44 -2300</pubDate>
      
      <guid>/tech/2017/07/10/tags-cloud/</guid>
      <description>
        &lt;p&gt;Yihui 修改过的主题并不提供分类、标签云这样的分类功能，因此需要自己想办法解决。&lt;/p&gt;

&lt;p&gt;由于标签和分类在 Hugo 都属于 Taxonomies 的一种实现，因此两种类别的内容的 Render 都由 &lt;code&gt;list.html&lt;/code&gt; 来实现，要使用标签云就需要再单独定义与标签云匹配的模板文件（分为主站模板与 Section 下的模板）；&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;整个站点的标签云由 &lt;code&gt;/layouts/taxonomy/tag.terms.html&lt;/code&gt; 负责，按这种目录和文件名结构，Huxo 就能&lt;strong&gt;自动&lt;/strong&gt;根据该文件中的信息生成 &lt;code&gt;tags/index.html&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;调整 &lt;code&gt;/js/tags.js&lt;/code&gt; 中的 &lt;code&gt;begin&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt;，用于设定最小字体、最大字体以及每种标签对应的显示颜色；&lt;/li&gt;
&lt;li&gt;然而仅仅这样做还不够，因为还还需要生成每个 Section 下的标签云页面：在 &lt;code&gt;/contents/&lt;/code&gt; 创建 &lt;code&gt;section-arts.md&lt;/code&gt; 文件，并在其中指定 &lt;code&gt;type&lt;/code&gt; 和 &lt;code&gt;layout&lt;/code&gt; 信息，并且 &lt;code&gt;slug&lt;/code&gt; 将文件映射到指定的路径，之后在 &lt;code&gt;/layouts/customterms/tagslist.html&lt;/code&gt; 中指定文件的渲染模板，注意这里的 &lt;code&gt;customterms&lt;/code&gt; 与前面在 &lt;code&gt;/contents/&lt;/code&gt; 中的 &lt;code&gt;tags-*.md&lt;/code&gt; 对应；&lt;/li&gt;
&lt;li&gt;由于 Hugo 目前无法获取指定 Section 下的 Categories 和 Tags，因此只好用了一些 Hack 的手法，给全部 Post 的 tags 和 categories 信息添加了一个特定的前缀编号（如 &lt;code&gt;4-tagName&lt;/code&gt;），之后模板文件利用这些信息再配合 &lt;code&gt;config.yaml&lt;/code&gt; 中的信息筛选出当前 Section 下的全部 tags；&lt;/li&gt;
&lt;li&gt;一些特殊的代码用于保证在标题中显示的 Section 信息以及 tag 的名称信息是正确的；&lt;/li&gt;
&lt;li&gt;Categories 列表的处理这标签基本类似，只是站点下的分类页面使用了默认的 &lt;code&gt;list.html&lt;/code&gt; 文件，而 Section 下的分类页面使用了 &lt;code&gt;/layouts/customterms/categorieslist.html&lt;/code&gt; 文件；&lt;/li&gt;
&lt;/ol&gt;

        
      </description>
    </item>
    
    <item>
      <title>Hugo 模板优先级解读</title>
      <link>/tech/2017/07/08/hugo-template-priority/</link>
      <pubDate>Sat, 08 Jul 2017 19:09:00 -2100</pubDate>
      
      <guid>/tech/2017/07/08/hugo-template-priority/</guid>
      <description>
        

&lt;h1 id=&#34;功能解读&#34;&gt;功能解读&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\layouts\&lt;/code&gt; 用于放置模板文件，并且文件在该目录中的名称、文件层次决定了模板应用的优先级。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\archetypes\&lt;/code&gt; 是内容文件 &lt;code&gt;.md&lt;/code&gt; 的模板；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/templates/functions/&#34; target=&#34;_blank&#34;&gt;https://gohugo.io/templates/functions/&lt;/a&gt;：方法、函数列表；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gohugo.io/templates/variables/&#34; target=&#34;_blank&#34;&gt;https://gohugo.io/templates/variables/&lt;/a&gt;：模板可操作的变量和对象列表；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$section&lt;/code&gt; 是通过赋值得到的一个可使用的页面级变量，而 &lt;code&gt;.Section&lt;/code&gt; 是一个 Hugo 自带的变量；&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;自定义功能实现&#34;&gt;自定义功能实现&lt;/h1&gt;

&lt;p&gt;目前来说 &lt;code&gt;list.html&lt;/code&gt; 可以遍历全部的 Section，但 Taxonomy Terms 只有一个 &lt;code&gt;tags&lt;/code&gt; 目录和一个 &lt;code&gt;categories&lt;/code&gt; 目录，并不能遍历全部的 Section。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://discourse.gohugo.io/t/create-section-taxonomies/343&#34; target=&#34;_blank&#34;&gt;https://discourse.gohugo.io/t/create-section-taxonomies/343&lt;/a&gt; 想为每个 Section 都创建 tags 和 categories 页面，但后续的讨论应该是没有成功，个人觉得如果能够返回某个 Section 下的所有 tags 对象和 categories 对象时，这个功能才有可能实现。&lt;/p&gt;

&lt;p&gt;根据 &lt;a href=&#34;https://discourse.gohugo.io/t/create-page-with-type-or-layout-template-set-in-frontmatter/5265&#34; target=&#34;_blank&#34;&gt;https://discourse.gohugo.io/t/create-page-with-type-or-layout-template-set-in-frontmatter/5265&lt;/a&gt; 和 &lt;a href=&#34;https://github.com/gohugoio/hugo/issues/386&#34; target=&#34;_blank&#34;&gt;https://github.com/gohugoio/hugo/issues/386&lt;/a&gt;，虽然可以通过给单独文件定义 &lt;code&gt;type&lt;/code&gt; 和 &lt;code&gt;layout&lt;/code&gt; 来做一些事情，但由于无法返回指定 Section 下的 Taxonomy Terms 集合，因此为每个 Section 都创建 tags 和 categories 页面的想法仍然无法实现。&lt;/p&gt;

&lt;h2 id=&#34;文章列表视图&#34;&gt;文章列表视图&lt;/h2&gt;

&lt;p&gt;根据 &lt;a href=&#34;https://gohugo.io/templates/views/&#34; target=&#34;_blank&#34;&gt;https://gohugo.io/templates/views/&lt;/a&gt;，除了 &lt;a href=&#34;https://gohugo.io/templates/content/&#34; target=&#34;_blank&#34;&gt;single&lt;/a&gt; 类型的模板外，每个 Section 都可以利用 &lt;a href=&#34;https://gohugo.io/templates/list/&#34; target=&#34;_blank&#34;&gt;list templates&lt;/a&gt; 生成各种不同的视图，&lt;a href=&#34;https://gohugo.io/templates/homepage/&#34; target=&#34;_blank&#34;&gt;https://gohugo.io/templates/homepage/&lt;/a&gt; 中给出了一个使用摘要视图的例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-django&#34;&gt;{{ range first 10 .Data.Pages }}
    {{ .Render &amp;quot;summary&amp;quot;}}
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的 &lt;code&gt;summary&lt;/code&gt; 还可以是 &lt;code&gt;li&lt;/code&gt; 类型，相关的文件目录结构为：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt dirTree&#34;&gt;▾ layouts/
  ▾ arts/
      li.html
      single.html
      summary.html
  ▾ tech/
      li.html
      single.html
      summary.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;li.html&lt;/code&gt; 和 &lt;code&gt;summary.html&lt;/code&gt; 实际上在 &lt;code&gt;\layouts\_default\list.html&lt;/code&gt; 这样的 list templates 类模板文件中使用，起到循环的作用。&lt;code&gt;list.html&lt;/code&gt; 以及这两种元视图文件的示例参考 &lt;a href=&#34;https://gohugo.io/templates/views/&#34; target=&#34;_blank&#34;&gt;https://gohugo.io/templates/views/&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;tags-页面&#34;&gt;tags 页面&lt;/h2&gt;

&lt;p&gt;经试验，&lt;code&gt;\contents\tags\&lt;/code&gt; 目录（及子目录）下使用 &lt;code&gt;_index.md&lt;/code&gt; 不是使用 &lt;code&gt;terms.html&lt;/code&gt; 相关的模板（比如 &lt;code&gt;terms.html&lt;/code&gt; 或者 &lt;code&gt;taxonomy/tag.terms.html&lt;/code&gt;），而是使用了 &lt;code&gt;list.html&lt;/code&gt; 作为模板，换句话讲，要想让不同的 Section 有自己的标签云页面，在 &lt;code&gt;\contents\&lt;/code&gt; 下创建如下目录结构的想法&lt;del&gt;行不通&lt;/del&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt dirTree&#34;&gt;└── content
    ├── tags
    |   ├── _index.md
    |   ├── tech
    |   |   └── _index.md
    |   └── arts
    └── tech
        ├── first.md
        └── second.md
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;模板部件&#34;&gt;模板部件&lt;/h1&gt;

&lt;h2 id=&#34;页面类型&#34;&gt;页面类型&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io/templates/variables/&#34; target=&#34;_blank&#34;&gt;变量&lt;/a&gt;一节中 Page variables 下的 &lt;code&gt;.Kind&lt;/code&gt; 指出，页面的类型有：page, home, section, taxonomy, taxonomyTerm, RSS, sitemap, robotsTXT 以及 404，但是附带的说明还没有看懂&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:but-these-will-o&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:but-these-will-o&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;home-page&#34;&gt;Home Page&lt;/h2&gt;

&lt;p&gt;根据 &lt;a href=&#34;https://gohugo.io/templates/homepage/&#34; target=&#34;_blank&#34;&gt;https://gohugo.io/templates/homepage/&lt;/a&gt;，Home page 的模板优先级如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;/layouts/index.html
/layouts/_default/list.html
/layouts/_default/single.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 Home page 的模板中，可以访问全部 &lt;a href=&#34;https://gohugo.io/templates/variables/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;page variables&lt;/code&gt;&lt;/a&gt; 和 &lt;a href=&#34;https://gohugo.io/templates/variables/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;site variables&lt;/code&gt;&lt;/a&gt; 中的变量，除此之外，Home page 可以通过 &lt;code&gt;.Data.Pages&lt;/code&gt; 访问全部页面对象，具体方法可以参考 &lt;a href=&#34;https://gohugo.io/templates/list/&#34; target=&#34;_blank&#34;&gt;Lists Template&lt;/a&gt; 部分的介绍。&lt;/p&gt;

&lt;h2 id=&#34;single&#34;&gt;single&lt;/h2&gt;

&lt;p&gt;根据 &lt;a href=&#34;https://gohugo.io/templates/content/&#34; target=&#34;_blank&#34;&gt;https://gohugo.io/templates/content/&lt;/a&gt;，每一篇 post，甚至全部的 &lt;code&gt;_index.md&lt;/code&gt; 都可以视为一个单页（但是 list 和 terms.list 类的页面不是）的模板优先级如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;/layouts/TYPE/LAYOUT.html
/layouts/SECTION/LAYOUT.html
/layouts/TYPE/single.html
/layouts/SECTION/single.html
/layouts/_default/single.html
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中的 &lt;code&gt;TYPE&lt;/code&gt; 和 &lt;code&gt;LAYOUT&lt;/code&gt; 可以在单个的 post 之中，以 &lt;code&gt;type&lt;/code&gt; 和 &lt;code&gt;layout&lt;/code&gt; 属性对的形式出现在 front-matter 之中；&lt;code&gt;SECTION&lt;/code&gt; 则是依据 md 文件在 &lt;code&gt;\contents\&lt;/code&gt; 中对应的文件夹而确定。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:but-these-will-o&#34;&gt;but these will only available during rendering of that kind of page, and not available in any of the &lt;code&gt;Pages&lt;/code&gt; collections. &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:but-these-will-o&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>Hugo 博客平台应用笔记</title>
      <link>/tech/2017/07/09/hugo/</link>
      <pubDate>Sun, 09 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/07/09/hugo/</guid>
      <description>
        &lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#skills&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1&lt;/span&gt; 使用心得&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#install&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2&lt;/span&gt; 安装与运行&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rstudio-&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.1&lt;/span&gt; RStudio 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hugo-&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.2&lt;/span&gt; Hugo 安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#building&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.3&lt;/span&gt; 博客搭建&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#-1&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.3.1&lt;/span&gt; 方法 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-2&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.3.2&lt;/span&gt; 方法 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-3&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.3.3&lt;/span&gt; 方法 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-4&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.3.4&lt;/span&gt; 方法 4（推荐）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#config-custom&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3&lt;/span&gt; 站点配置与功能订制&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#config&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.1&lt;/span&gt; 站点配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#custom&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.2&lt;/span&gt; 功能订制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#futureFeatures&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3.3&lt;/span&gt; 待实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#themes&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4&lt;/span&gt; 主题调整&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#page-width&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.1&lt;/span&gt; 页面宽度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#font-family&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4.2&lt;/span&gt; 字体&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#Hugo-Functions&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;5&lt;/span&gt; 功能解读&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;skills&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; 使用心得&lt;/h1&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;在 yml 头中加入 &lt;code&gt;subtitle: A subtitle&lt;/code&gt; 可以为 post 添加一个副标题；&lt;/li&gt;
&lt;li&gt;这里是一个 &lt;code&gt;&amp;lt;kbd&amp;gt;...&amp;lt;/kbd&amp;gt;&lt;/code&gt; 的例子：&lt;kbd&gt;Ctrl&lt;/kbd&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slug: &amp;quot;cn/about&amp;quot;&lt;/code&gt; 中的 &lt;code&gt;slug&lt;/code&gt; 是 Hugo 特有的一种机制，这里对应的文件实际上只是 &lt;code&gt;\content\cn_about.md&lt;/code&gt;，但最终这个文件在 URL 中显示的却是 &lt;code&gt;/cn/about/&lt;/code&gt;，所以 Slug 可以同时设定所属的博客子分类以及在 URL 中的文件名称，相当于强制重定向到了某一指定的路径。&lt;/li&gt;
&lt;li&gt;要实现 &lt;code&gt;&lt;code&gt;$...&lt;/code&gt;$&lt;/code&gt; 这样的效果，需要使用 &lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt; 标记，具体参考此处的源代码；&lt;/li&gt;
&lt;li&gt;用 R Markdown 时，生成的 toc 如果是全中文的条目，可能链接的下划线无法用 css hack 很好的消除，但给对应的标题一个 &lt;code&gt;{#idName}&lt;/code&gt; 时，这个问题自动消失，详细参考本文档上方的目录；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;R Markdown 的&lt;a href=&#34;https://bookdown.org/yihui/blogdown/content.html#body&#34;&gt;说明文档&lt;/a&gt;中说在 R Markdown 中不能直接使用 Shortcode，而要用下面的语法&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;```{r echo=FALSE}
blogdown::shortcode(&amp;#39;tweet&amp;#39;, &amp;#39;852205086956818432&amp;#39;)
```&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在 md 格式下输入以下内容可以自动将最后一行转换成右对齐的格式（普通的 Rmd 下 knitr 时不支持，但 Blogdown 下的 Rmd 可以）：&lt;/p&gt;
&lt;pre class=&#34;markdown&#34;&gt;&lt;code&gt;# Quotes

&amp;gt; Let us change our traditional attitude to the construction of programs:
&amp;gt; Instead of imagining that our main task is to instruct a computer what to do,
&amp;gt; let us concentrate rather on explaining to humans what we want the computer to do.

&amp;gt; --- Donald E. Knuth, Literate Programming, 1984&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：下面的内容，没有改模板的需求时，基本不用理会。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;install&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;2&lt;/span&gt; 安装与运行&lt;/h1&gt;
&lt;div id=&#34;rstudio-&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.1&lt;/span&gt; RStudio 安装&lt;/h2&gt;
&lt;p&gt;暂时不能直接用官方网站的正式版安装，而要用 &lt;a href=&#34;https://dailies.rstudio.com/&#34; class=&#34;uri&#34;&gt;https://dailies.rstudio.com/&lt;/a&gt; 提供的开发测试版，否则无法直接通过 RStudio 的新建 Project 向导创建一个 Hugo 的博客站点。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;hugo-&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.2&lt;/span&gt; Hugo 安装&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; 基于 &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; 语言编写，与 &lt;a href=&#34;https://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt; 和 &lt;a href=&#34;https://hexo.io/&#34;&gt;Hexo&lt;/a&gt; 相比，虽然 Hugo 目前&lt;a href=&#34;https://themes.gohugo.io/&#34;&gt;主题&lt;/a&gt;和插件还不如 Hexo 丰富，但它运行速度极快，并且安装非常容易，用户只需要&lt;a href=&#34;https://github.com/gohugoio/hugo/releases&#34;&gt;下载&lt;/a&gt;主程序 &lt;code&gt;Hugo.exe&lt;/code&gt; 并复制到指定目录即可&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;pre class=&#34;txt&#34;&gt;&lt;code&gt;C:\Users\Howard\AppData\Roaming\Hugo&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用户可以参考&lt;a href=&#34;https://gohugo.io/overview/introduction/&#34;&gt;官方文档&lt;/a&gt;（&lt;a href=&#34;http://www.gohugo.org/&#34;&gt;中文&lt;/a&gt;）进一步了解如何使用 Hugo，还可以到 GitHub 了解存在的问题以及目前的开发进度，到 &lt;a href=&#34;https://discourse.gohugo.io/&#34;&gt;Community&lt;/a&gt; 与其他用户讨论使用过程中遇到的各种问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;building&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.3&lt;/span&gt; 博客搭建&lt;/h2&gt;
&lt;div id=&#34;-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.3.1&lt;/span&gt; 方法 1&lt;/h3&gt;
&lt;p&gt;首先，切换到放置博客文件的目录，比如 &lt;code&gt;D:\GitHub&lt;/code&gt;，接下来右键并选择 &lt;code&gt;GUI Bash Here&lt;/code&gt;，之后在弹出的命令对话框中输入如下命令：&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;git clone --recursive https://github.com/yihui/blogdown-yihui-template.git&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令从谢益辉的 Github 上提取建立博客需要的全部文件到本地 &lt;code&gt;D:\GitHub\blogdown-yihui-template\&lt;/code&gt; 目录之中，这是谢根据 &lt;code&gt;hugo-lithium-theme&lt;/code&gt; 主题修改后又从自已的站点抽取出来的一个框架，这个目录名称可以自行修改，比如修改成 &lt;code&gt;blogdown_Haopeng&lt;/code&gt;，觉得麻烦的话，也可以参考&lt;a href=&#34;/tech/2017/07/14/github-in-rstudio/&#34;&gt;这里&lt;/a&gt;通过 Git 的图形客户端完成整个过程。&lt;/p&gt;
&lt;p&gt;其次，打开 RStudio，输入如下命令：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setwd(&amp;#39;D:/GitHub/blogdown_Haopeng&amp;#39;)
blogdown::serve_site()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当控制台显示 &lt;code&gt;Serving the directory D:\GitHub\blogdown_Haopeng at http://127.0.0.1:4321&lt;/code&gt; 类似的文字时，就可以在浏览器中输入 &lt;code&gt;http://127.0.0.1:4321&lt;/code&gt; 进行预览，因为具有 Hugo 实时预览功能，因此对目录中相关文件进行修改后，甚至不需要刷新浏览器就可以看到更新后的结果。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;-2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.3.2&lt;/span&gt; 方法 2&lt;/h3&gt;
&lt;p&gt;如果没有安装 git 客户端，也可以跳过上面的两个步骤，直接在 RStudio 中输入如下命令：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;setwd(&amp;#39;D:/GitHub/blogdown_Haopeng&amp;#39;)
blogdown::new_site(theme = &amp;#39;yihui/hugo-lithium-theme&amp;#39;)
blogdown::serve_site()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样生成的博客站点和上面的非常类似，但细节和相关功能上和上面的那个代码仓库相比，可能会有比较多的差别。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;-3&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.3.3&lt;/span&gt; 方法 3&lt;/h3&gt;
&lt;p&gt;先复制一份打包好的 &lt;code&gt;blogdown_Haopeng&lt;/code&gt; 目录到指定位置，然后参考方法 1 第二步进行操作。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;-4&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.3.4&lt;/span&gt; 方法 4（推荐）&lt;/h3&gt;
&lt;p&gt;2017.07.14 所有一切怪异的源头来自 &lt;code&gt;R/*.*&lt;/code&gt;，这里面的文件配合站点下的自定义的 &lt;code&gt;.Rprofile&lt;/code&gt; 用于自定义整个站点的渲染过程，相当于一个自定义版本的 &lt;code&gt;blogdown::servesite()&lt;/code&gt;，虽然现在已经弄清楚中间发生了什么。这种自定义的方式其实是先将 Rmd 文件通过 knitr 转换成 md 文件，之后再交由 Hugo 的 Markdown 引擎 Blackfriday 来处理，对于一般的文档，这种自定义的方法的最大好处是可以控制更多细节，比较 Rmd 文件中绘制图形的保存路径等，但最大的问题是：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;Blackfriday 处理数学公式的能力远不如 Pandoc；&lt;/li&gt;
&lt;li&gt;也无法做到为各级标题自动添加编号；&lt;/li&gt;
&lt;li&gt;不能自动给源文档中不连续的有序列表添加连续的编号；&lt;/li&gt;
&lt;li&gt;还有一个比较难受的点是，生成的临时 md 文件与原始的 md 混在一起，非常难区分；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此最终还是选择用这里的第 4 种方法：先参考第 2 种方法下载最精简版本的文件，之后再从第 1 种方法下载的文件中提取需要用到的各种文件，再整合到精简版的内容之中。&lt;/p&gt;
&lt;p&gt;实际操作过程中，在模板整合完成并调试结束后，可以把其中的内容全部复制出来，再参考&lt;a href=&#34;/tech/2017/07/14/github-in-rstudio/&#34;&gt;这里&lt;/a&gt;将提取出来的内容放到一个 GitHub 的本地代码仓库之中，之后再 Push 到远程仓库。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;方法 1 和 方法 3 的思路会遇到一个比较奇怪的事情，在 &lt;a href=&#34;https://github.com/rstudio/blogdown/issues/140&#34; class=&#34;uri&#34;&gt;https://github.com/rstudio/blogdown/issues/140&lt;/a&gt; 反映了此问题：就是在 Rmd 中&lt;del&gt;&lt;strong&gt;无法&lt;/strong&gt;&lt;/del&gt;成功通过如下的设置来生成文章内的目录，并给每个小标题添加编号，&lt;/p&gt;
&lt;pre class=&#34;yaml&#34;&gt;&lt;code&gt;output:
  blogdown::html_page:
    toc: true
    number_sections: true&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据试验的结果来看，直接在 RStudio 中按 &lt;a href=&#34;https://bookdown.org/yihui/blogdown/rstudio-ide.html&#34; class=&#34;uri&#34;&gt;https://bookdown.org/yihui/blogdown/rstudio-ide.html&lt;/a&gt; 给出的说明：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;点击 &lt;code&gt;File -&amp;gt; New Project -&amp;gt; New Directory&lt;/code&gt;，然后按照下面两张图的设置进行站点初始化：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Tech/Hugo/RStudio/NewProject/1.png&#34; alt=&#34;Create a new website project in RStudio.&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Create a new website project in RStudio.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Tech/Hugo/RStudio/NewProject/2.png&#34; alt=&#34;Create a website project based on blogdown.&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;Create a website project based on blogdown.&lt;/p&gt;
&lt;/div&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;将 &lt;code&gt;yihui/blogdown-yihui-template.git&lt;/code&gt; 下面的 &lt;code&gt;\layouts\*&lt;/code&gt; 和 &lt;code&gt;\static\*&lt;/code&gt; 复制到 &lt;code&gt;Blogdown&lt;/code&gt; 中；&lt;/li&gt;
&lt;li&gt;复制 &lt;code&gt;config.yaml&lt;/code&gt; 并删除默认的 &lt;code&gt;config.toml&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;在 Rmd 文件头中添加上面给出的 &lt;code&gt;output&lt;/code&gt; 设置；&lt;/li&gt;
&lt;li&gt;&lt;del&gt;不复制&lt;/del&gt; &lt;code&gt;blogdown-yihui-template\R&lt;/code&gt; 中的 &lt;code&gt;build_one.R&lt;/code&gt; 和 &lt;code&gt;build.R&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;在 RStudio 中运行 &lt;code&gt;blogdown::serve_site()&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样又可以成功得到 Pandoc 风格的 toc 和 编号后的标题。但目前不清楚为什么用方法 1 和方法 3 不能成功，也不确定方法 2 和这里的方法 4 的完整区别（至少方法 4 中的指定 &lt;code&gt;Create project as subdirectory of&lt;/code&gt; 是方法 2 默认没有的）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如 &lt;a href=&#34;https://bookdown.org/yihui/blogdown/output-format.html&#34; class=&#34;uri&#34;&gt;https://bookdown.org/yihui/blogdown/output-format.html&lt;/a&gt; 最下方指出的，方法 4 可能会导致语法高亮等失效，可以通过 &lt;code&gt;highlight.js&lt;/code&gt; 的方法来修正，在实际运行过程中，IE 下在线加载该语法高亮工具的 CSS 文件可能会比较慢，而在 Chrome 下这个过程很迅速。另外，这个页面中说使用 R Markdown 时，公式需要通过 &lt;code&gt;`$...$`&lt;/code&gt; 才可以正常工作，但实际上模板已经可以直接用 &lt;code&gt;&lt;code&gt;$...&lt;/code&gt;$&lt;/code&gt; 来完成公式的输入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://support.rbind.io/2017/04/25/yihui-website/&#34; class=&#34;uri&#34;&gt;https://support.rbind.io/2017/04/25/yihui-website/&lt;/a&gt; 是谢益辉对自己网站模板的比较详细的思路介绍，值得多读一下，了解更多的细节。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;config-custom&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;3&lt;/span&gt; 站点配置与功能订制&lt;/h1&gt;
&lt;div id=&#34;config&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.1&lt;/span&gt; 站点配置&lt;/h2&gt;
&lt;p&gt;站点配置主要在 &lt;code&gt;config.yaml&lt;/code&gt; 文件中进行，直接参考谢益辉的 &lt;code&gt;config.yaml&lt;/code&gt; 文件进行修改即可，注意目前暂时不添加 &lt;code&gt;googleAnalytics&lt;/code&gt; 相关的信息，因此这一部分的取值为空。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：Hugo 的配置包含两部分，一部分位于主题目录之中，比如 &lt;code&gt;themes\hugo-lithium-theme\&lt;/code&gt; 下的 &lt;code&gt;static\&lt;/code&gt; 或 &lt;code&gt;layout\&lt;/code&gt;，另一部分位于站点根目录之中，比如 &lt;code&gt;\layout\&lt;/code&gt; 或 &lt;code&gt;\static\&lt;/code&gt;，其中后者的优先级要高于前者。在后续的内容中，涉及到相关目录时，如果没有提及“主题中的”相关字眼，通常指的是站点根目录中的相关目录或文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div id=&#34;custom&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.2&lt;/span&gt; 功能订制&lt;/h2&gt;
&lt;p&gt;功能订制主要是在谢益辉已提供功能的基础上进行修正和添加，首先需要从谢益辉的 &lt;code&gt;\static\&lt;/code&gt; 和 &lt;code&gt;\layout\&lt;/code&gt; 中复制全部文件到博客的根目录中，接下来&lt;a href=&#34;#fn3&#34; class=&#34;footnoteRef&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;公式&lt;/strong&gt;：默认的模板公式做的不够好，因此参考 Hexo 的模板加入了公式编号功能，在 &lt;code&gt;/layouts/paritals/footer_mathjax.html&lt;/code&gt; 加入了下面的内容：&lt;/p&gt;
&lt;pre class=&#34;javascript&#34;&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;
MathJax.Hub.Config({
TeX: {equationNumbers: {autoNumber: [&amp;quot;AMS&amp;quot;], useLabelIds: true}},
&amp;quot;HTML-CSS&amp;quot;: {linebreaks: {automatic: true}},
SVG: {linebreaks: {automatic: true}}
});
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;logo&lt;/strong&gt;：在 &lt;code&gt;\static\images\&lt;/code&gt; 中放置已经做好的头像文件，如果觉得不满意，可以在 Photoshop 中参考已经做好的头像文件自行调整；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;disqus&lt;/strong&gt;：将 &lt;code&gt;\layouts\partials\disqus.html&lt;/code&gt; 文件中的：&lt;/p&gt;
&lt;pre class=&#34;javascript&#34;&gt;&lt;code&gt;var disqus_js = &amp;#39;//{{ .Site.DisqusShortname }}.disqus.com/embed.js&amp;#39;;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;替换成：&lt;/p&gt;
&lt;pre class=&#34;javascript&#34;&gt;&lt;code&gt;var disqus_js = &amp;#39;https://{{ .Site.DisqusShortname }}.disqus.com/embed.js&amp;#39;;&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OK&lt;/strong&gt;：关于异步加载字体功能，将 &lt;code&gt;\static\js\load-typekit.js&lt;/code&gt; 文件中的 &lt;code&gt;kitId: &#39;kwz5xar&#39;&lt;/code&gt; 修改成 &lt;code&gt;kitId: &#39;oqz0fck&#39;&lt;/code&gt;，这里的 &lt;code&gt;kitId&lt;/code&gt; 需要&lt;a href=&#34;https://typekit.com/plans&#34;&gt;注册&lt;/a&gt;获得&lt;a href=&#34;#fn4&#34; class=&#34;footnoteRef&#34; id=&#34;fnref4&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;，目前看来，似乎之前这个账号在新的地址中也可以继续使用；&lt;/li&gt;
&lt;li&gt;从 &lt;code&gt;\layouts\partials\head_custom.html&lt;/code&gt; 可以看出：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;OK&lt;/strong&gt;：FontAwesome 相关的字体也是异步在线加载的，现在已迁移到本地，否则 Ad block 有可能产生不好的影响，导致图标无法显示；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OK&lt;/strong&gt;：只有 &lt;code&gt;cn/&lt;/code&gt; 目录下的文章会异步加载思源宋体，已修改，参考 &lt;code&gt;head_custom.html&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OK&lt;/strong&gt;：谢益辉设定 2017 年以前的文章会异步加载 &lt;a href=&#34;https://github.com/vinta/pangu.js&#34;&gt;&lt;code&gt;pangu&lt;/code&gt;&lt;/a&gt; 插件，这里将 &lt;code&gt;{{ if lt (.Date.Year) 2017 }}&lt;/code&gt; 修改成 &lt;code&gt;{{ if lt (.Date.Year) 2005 }}&lt;/code&gt;，相当于不再加载该插件；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OK&lt;/strong&gt;：时间格式正文页中的时间格式显示比较怪，在没有了解 Hugo 的语法前，将 &lt;code&gt;\layouts\partials\article_meta.html&lt;/code&gt; 文件中的 &lt;code&gt;{{ .Date.Format (default &amp;quot;January 2, 2006&amp;quot; .Site.Params.dateFormat ) }}&lt;/code&gt; 修改成 &lt;code&gt;{{ .Date.Format &amp;quot;2006/01/02&amp;quot; }}&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OK&lt;/strong&gt;：GitHub Edit 在 Windows 上，文件路径中使用 &lt;code&gt;\&lt;/code&gt;，而 &lt;code&gt;\layouts\partials\article_meta.html&lt;/code&gt; 中没有考虑到这一点，导致生成的链接中包含 &lt;code&gt;%5c&lt;/code&gt; 字样，这正是 &lt;code&gt;\&lt;/code&gt; 对应的 html 转义码，因此将文件中的&lt;code&gt;{{ $.Scratch.Set &amp;quot;filePath&amp;quot; $.File.Path }}&lt;/code&gt; 修改成 &lt;code&gt;{{ $.Scratch.Set &amp;quot;filePath&amp;quot; (replace $.File.Path &amp;quot;\\&amp;quot; &amp;quot;/&amp;quot;) }}&lt;/code&gt;，注意不是替换 &lt;code&gt;%5c&lt;/code&gt;，而是 &lt;code&gt;\\&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;OK&lt;/strong&gt;：关于页面标题居中通过修改 &lt;code&gt;\layouts\partials\article_meta.html&lt;/code&gt; 将“关于”页面的标题剧中，具体的，需要将如下代码&lt;/p&gt;
&lt;pre class=&#34;html&#34;&gt;&lt;code&gt;&amp;lt;h1 class=&amp;quot;article-title&amp;quot;&amp;gt;{{ .Title }}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改为：&lt;/p&gt;
&lt;pre class=&#34;html&#34;&gt;&lt;code&gt;{{if findRE &amp;quot;-about$&amp;quot; $.File.BaseFileName }}
&amp;lt;h1 class=&amp;quot;article-title&amp;quot; style=&amp;quot;text-align: center;&amp;quot;&amp;gt;{{ .Title }}
{{ else }}
&amp;lt;h1 class=&amp;quot;article-title&amp;quot;&amp;gt;{{ .Title }}
{{ end }}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;futureFeatures&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.3&lt;/span&gt; 待实现&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：R Markdown 下面设定超链接在新窗口中打开，Plain Markdown 中在 &lt;code&gt;_config.yaml&lt;/code&gt; 的 &lt;code&gt;blackfriday&lt;/code&gt; 设置即可；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：标签和分类相关的问题：
&lt;ul&gt;
&lt;li&gt;标签和分类中的空格会被自动忽略，怎么禁止(做不到，但可以在生成页面时再用 Hugo 的指令替换回来)；&lt;/li&gt;
&lt;li&gt;标签和分类为中文时，Blogdown 对应的当前分类（标签）条目汇总页无法显示，但是 &lt;a href=&#34;https://blog.coderzh.com/categories/读书笔记/&#34; class=&#34;uri&#34;&gt;https://blog.coderzh.com/categories/读书笔记/&lt;/a&gt; 是正常工作的，这说明有可能是 blogdown 或者模板的问题(已得到 Yihui 修正，是 &lt;code&gt;Servr&lt;/code&gt; 包的问题)；&lt;/li&gt;
&lt;li&gt;另一个问题是当前分类（标签）汇总页的标题不能是 &lt;code&gt;.Title&lt;/code&gt;，否则取值为 &lt;code&gt;年份&lt;/code&gt;，这里由于 &lt;code&gt;tags&lt;/code&gt; 和 &lt;code&gt;categories&lt;/code&gt; 都位于站点根目录下，因此唯一的可能是获取用户进到本页面之前的前一个页面对应的 section，然后根据该 section 展示一个与 section 有关的标签页或分类页，然而这样做的基础是可以在不同的 section 下面生成各自的 &lt;code&gt;tags&lt;/code&gt; 和 &lt;code&gt;categories&lt;/code&gt; 页(Terms 页本来也不怎么需要分布，而 Section 的 list pages 分页并不受影响)；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：&lt;strong&gt;标签云&lt;/strong&gt;功能的&lt;a href=&#34;/tech/2017/07/10/tags-cloud/&#34;&gt;实现&lt;/a&gt;，默认的分类和标签都是同一类对象，而现在需要将两类对象分离出来，查看 &lt;a href=&#34;https://github.com/kakawait/hugo-tranquilpeak-theme&#34; class=&#34;uri&#34;&gt;https://github.com/kakawait/hugo-tranquilpeak-theme&lt;/a&gt; 中 kakawait-tranquilpeak 的主题效果时，发现里面有一个 &lt;code&gt;\layouts\taxonomy&lt;/code&gt; 目录，其中包含了 &lt;code&gt;archive.terms.html&lt;/code&gt;, &lt;code&gt;category.html&lt;/code&gt;, &lt;code&gt;category.terms.html&lt;/code&gt;, &lt;code&gt;tag.html&lt;/code&gt;, &lt;code&gt;tag.terms.html&lt;/code&gt;，再根据 &lt;a href=&#34;https://gohugo.io/templates/terms/&#34; class=&#34;uri&#34;&gt;https://gohugo.io/templates/terms/&lt;/a&gt; 的文档说明，显然存档页、分类页、标签页都可以分开定义模板，其中 &lt;code&gt;tag.terms.html&lt;/code&gt; 是标签汇总页（标签云），那么 &lt;code&gt;tag.html&lt;/code&gt; 就应该是某个标签下的 post 的展示页，暂时不清楚 &lt;code&gt;archive.terms.html&lt;/code&gt; 的作用。在 &lt;code&gt;\layouts\taxonomy&lt;/code&gt; 中添加了一个自定义的 &lt;code&gt;tag.terms.html&lt;/code&gt;，之后就可以生成标签汇总页。具体生成标签汇总页时，发现 &lt;a href=&#34;https://www.josephearl.co.uk/tags&#34; class=&#34;uri&#34;&gt;https://www.josephearl.co.uk/tags&lt;/a&gt; 的标签云效果很不错，于是： (1) 到 &lt;a href=&#34;https://github.com/josephearl/website&#34; class=&#34;uri&#34;&gt;https://github.com/josephearl/website&lt;/a&gt; 下载了对应的源代码（主题的其它功能可以到 &lt;a href=&#34;https://github.com/nodejh/hugo-theme-cactus-plus&#34; class=&#34;uri&#34;&gt;https://github.com/nodejh/hugo-theme-cactus-plus&lt;/a&gt; 查阅），提取其中的 &lt;code&gt;themes\cactus-plus\static\js\js.tags&lt;/code&gt; 到自己博客的 &lt;code&gt;\static\js\，(2) 参考这个模板中的&lt;/code&gt;\section.html&lt;code&gt;文件的内容，同时参考 &amp;lt;https://github.com/kakawait/hugo-tranquilpeak-theme&amp;gt; 的目录结构，在&lt;/code&gt;&lt;code&gt;中添加了一个自定义的&lt;/code&gt;tag.terms.html&lt;code&gt;，(3) 修改&lt;/code&gt;tags.js&lt;code&gt;中的&lt;/code&gt;var tagcloudOptions={size:{start:12,end:30,unit:“pt”},color:{start:“#bbbbbb”,end:“#2dbe60”}}&lt;code&gt;，将其中的两个&lt;/code&gt;start&lt;code&gt;,&lt;/code&gt;end` 修改成现在的取值，用于指定标签云字体的大小和颜色。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.josephearl.co.uk/tags&#34; class=&#34;uri&#34;&gt;https://www.josephearl.co.uk/tags&lt;/a&gt; 是一个非常好的标签云的效果；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：标签：正文中的标签，标签汇总页（&lt;strong&gt;已解决&lt;/strong&gt;），单个标签对应文章列表（分页，文章多时再解决，这是 Hugo 自动做的事情，完全不是问题）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：分类：正文中显示所属分类，分类目录页（分页），单个分类中的文章列表（分页，文章多时再解决，这是 Hugo 自动做的事情，完全不是问题）；
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://tranquilpeak.kakawait.com/categories/&#34; class=&#34;uri&#34;&gt;https://tranquilpeak.kakawait.com/categories/&lt;/a&gt;：这个分类页面显示了标签，还显示了全部 post，不同分类下的 post，值得参考；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：除了 EN 下外，其它地方的 tags list/paper list 的标题都用中文，这些地方的标题都居中(技巧是给每个分类以及标签一个 Section 代码前缀)；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：能不能每个 section 中包含一个 &lt;code&gt;tags&lt;/code&gt; 和 &lt;code&gt;categories&lt;/code&gt; 页面？&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：存档：按年份倒序的存档页（分页），根据 &lt;a href=&#34;https://gohugo.io/templates/terms/&#34; class=&#34;uri&#34;&gt;https://gohugo.io/templates/terms/&lt;/a&gt;，可以用 &lt;code&gt;len .Data.Terms&lt;/code&gt; 和 &lt;code&gt;len .Data.Pages&lt;/code&gt; 得到标签数和页数；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：Hexo 中的 &lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt; 标记默认可以添加一个 &lt;code&gt;start&lt;/code&gt; 属性，但是本主题中还不支持，用 R Markdown 可以通过 Pandoc 的能力来实现；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：FontAwesome 相关的字体也是异步在线加载的，可以考虑将来迁移到本地；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：只有 &lt;code&gt;cn/&lt;/code&gt; 目录下的文章会异步加载思源宋体，需要修改；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：页面摘要：用 &lt;code&gt;&amp;lt;!--more--&amp;gt;&lt;/code&gt; 生成的目录页和存档页不同，这种类型的页面中包含一部分正文内容，并且需要支持分页，对应于模板的 &lt;code&gt;.Summary&lt;/code&gt; 和 &lt;code&gt;.li&lt;/code&gt; 视图，具体参见&lt;a href=&#34;/tech/2017/07/08/hugo-template-priority/&#34;&gt;这里&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：&lt;strong&gt;搜索&lt;/strong&gt;功能（实现过程参考&lt;a href=&#34;/tech/2017/07/10/hugo-local-search/&#34;&gt;这里&lt;/a&gt;）：
&lt;ul&gt;
&lt;li&gt;可以用 &lt;code&gt;lunr.js&lt;/code&gt; 或者其增强版 &lt;a href=&#34;http://blog.csdn.net/watkinsong/article/details/47168075&#34;&gt;&lt;code&gt;elasticlunr.js&lt;/code&gt;&lt;/a&gt; 来实现，其中 &lt;code&gt;lunr.js&lt;/code&gt; 的比较好的主题示例可以参考 &lt;a href=&#34;https://themes.gohugo.io/docdock/&#34;&gt;DocDock&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;另一种方案是 Hexo 的 NexT 主题使用的 &lt;a href=&#34;https://github.com/algolia/react-instantsearch/&#34;&gt;&lt;code&gt;instantsearch.js&lt;/code&gt;&lt;/a&gt;，&lt;a href=&#34;https://community.algolia.com/instantsearch.js/v2/getting-started.html&#34; class=&#34;uri&#34;&gt;https://community.algolia.com/instantsearch.js/v2/getting-started.html&lt;/a&gt; 有一个比较详细的使用步骤介绍，&lt;a href=&#34;https://codepen.io/Algolia/pen/ZOyoJg&#34; class=&#34;uri&#34;&gt;https://codepen.io/Algolia/pen/ZOyoJg&lt;/a&gt; 是一个非常好的演示例子。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.josephearl.co.uk/&#34; class=&#34;uri&#34;&gt;https://www.josephearl.co.uk/&lt;/a&gt; 的在线搜索感觉非常轻量，也还不错，一些小细节的 CSS 问题还可以参考 &lt;a href=&#34;https://www.josephearl.co.uk/post/css-overlay/&#34; class=&#34;uri&#34;&gt;https://www.josephearl.co.uk/post/css-overlay/&lt;/a&gt;。这个博客用的是 &lt;a href=&#34;https://github.com/nodejh/hugo-theme-cactus-plus&#34; class=&#34;uri&#34;&gt;https://github.com/nodejh/hugo-theme-cactus-plus&lt;/a&gt;，从 &lt;a href=&#34;https://github.com/josephearl/website&#34; class=&#34;uri&#34;&gt;https://github.com/josephearl/website&lt;/a&gt; 下载的源代码中的 &lt;code&gt;\themes\cactus-plus\static\js&lt;/code&gt; 目录中可以发现，同时有 &lt;code&gt;search.js&lt;/code&gt; 和 &lt;code&gt;lunr.js&lt;/code&gt;，因此感觉应该是一个 &lt;code&gt;lunr.js&lt;/code&gt; 的包装，不过这个站点的搜索好像只针对标题和标签，虽然快但是没有全文搜索的能力；&lt;/li&gt;
&lt;li&gt;Hexo 的 NexT 主题实际上本人现在用的是一种本地搜索的实现方式，&lt;code&gt;themes\next\layout\_third-party\search&lt;/code&gt; 中的 &lt;code&gt;localsearch.swig&lt;/code&gt; 以及 &lt;code&gt;next\source\css\_common\components\third-party&lt;/code&gt; 中的 &lt;code&gt;localsearch.styl&lt;/code&gt; 是两个最为重要的文件，还有一个 &lt;code&gt;next\layout\_partials\search&lt;/code&gt; 中的 &lt;code&gt;localsearch.swig&lt;/code&gt; 可以参考，这是目前最满意的方案，可惜需要用到 &lt;code&gt;db.json&lt;/code&gt;，这个文件目前还没有找到好的方案来生成，但感觉上与 Hugo 的 &lt;code&gt;index.xml&lt;/code&gt; 文件的生成有关联。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://discourse.gohugo.io/t/search-index-json-file-for-lunr-js/6286/8&#34;&gt;Search Index .json-file for Lunr.js&lt;/a&gt;：没看明白；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gohugoio/hugo/issues/144&#34;&gt;Save data to “data/pages.json” #144&lt;/a&gt;：没有解决方案；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/gohugoio/hugo/pull/1853&#34;&gt;Add generator for a search index #1853&lt;/a&gt;：没有解决方案；&lt;/li&gt;
&lt;li&gt;生成全站的 &lt;code&gt;json&lt;/code&gt; 文件（&lt;strong&gt;未解决&lt;/strong&gt;）：
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://bitquabit.com/post/json-feed-with-hugo/&#34; class=&#34;uri&#34;&gt;https://bitquabit.com/post/json-feed-with-hugo/&lt;/a&gt;：已试验不成功；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/bep/bepsays.com/commit/1d7bf7fd6e7c637f28a04f93a97ebfed084c27ff&#34; class=&#34;uri&#34;&gt;https://github.com/bep/bepsays.com/commit/1d7bf7fd6e7c637f28a04f93a97ebfed084c27ff&lt;/a&gt;：未试验，但感觉是一个 post 生成一个文件，这个地址来自 &lt;a href=&#34;https://discourse.gohugo.io/t/simple-json-site-index-in-hugo/2854&#34;&gt;Simple JSON site index in Hugo&lt;/a&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：图片浏览器不再用 &lt;code&gt;fancybox&lt;/code&gt;，使用方便程度和整合难度都不太理想，改成用 &lt;a href=&#34;/tech/2017/07/10/hugo-light-gallery/&#34;&gt;&lt;code&gt;lightGallery&lt;/code&gt;&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OK&lt;/strong&gt;：图片保存的路径，在 &lt;code&gt;\static\images\&lt;/code&gt; 中保存是比较好的选择，Rmd 文件生成的图像在 &lt;code&gt;static\figures\&lt;/code&gt;之中，不需要人工干预；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;已解决&lt;/strong&gt;：文章内目录：&lt;code&gt;\layouts\_default\single.html&lt;/code&gt; 显示目前的主题是支持 toc 功能的，通过 &lt;code&gt;show_toc: true&lt;/code&gt; 开启，如果是 Rmd 文件，开启方法参考 Bookdown 即可：&lt;/p&gt;
&lt;pre class=&#34;yaml&#34;&gt;&lt;code&gt;output:
  blogdown::html_page:
toc: true
number_sections: true&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：文章内的子标题编号，由于 Hugo 的 Markdown 引擎 &lt;a href=&#34;https://github.com/russross/blackfriday&#34;&gt;blackfriday&lt;/a&gt; 还不支持 Auto numbering，因此这个功能暂时不好实现，Rmd 提供了接口，开启方法见上面的示例代码或本文档的源文件；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可解决&lt;/strong&gt;：视频文件的特殊显示效果 &lt;code&gt;lightGallery&lt;/code&gt; 就可以解决，参考 &lt;a href=&#34;https://gohugo.io/extras/shortcodes/&#34;&gt;Shortcodes&lt;/a&gt; 可以了解更多关于短代码的说明，里面有 Youtube 的支持，但是感觉这会导致不同的系统不兼容，另外还可以参考主题 &lt;code&gt;Castanet&lt;/code&gt; 的实现方法；需要进一步了解自己怎样定义好的短代码；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已解决&lt;/strong&gt;：图片的标题是用 &lt;code&gt;*...*&lt;/code&gt; 还是直接用一个 &lt;code&gt;&amp;lt;p class=&amp;quot;text-align: center&amp;quot;&amp;gt;...&amp;lt;/p&amp;gt;&lt;/code&gt;，最终决定定义一个 &lt;code&gt;imgCaption&lt;/code&gt; 和 &lt;code&gt;tabCaption&lt;/code&gt;，这里使用了 Pandoc 的转换功能，将 Markdown 代码中的可选文本自动转换成 Caption；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可解决&lt;/strong&gt;：如果将幻灯片等和本博客集成到一起，需不需要集成，做不了，也没必要，直接再做一个仓库保存幻灯片即可；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OK&lt;/strong&gt;：试验添加 &lt;code&gt;Rmd&lt;/code&gt; 文件，并在 RStudio 中查看运行效果，原生的 Rmd 格式的 YAML 头和 blogdown 中的并不完全相同，各走各即可，目前使用过程中除 toc 功能外大部分是相同的；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可解决&lt;/strong&gt;：不准备做，反正 &lt;code&gt;EN&lt;/code&gt; 已经基本的外观。像 &lt;a href=&#34;https://github.com/bep/bepsays.com/blob/master/config.toml&#34; class=&#34;uri&#34;&gt;https://github.com/bep/bepsays.com/blob/master/config.toml&lt;/a&gt; 一样，提供不同语言界面的支持，或者像 &lt;a href=&#34;https://github.com/kakawait/hugo-tranquilpeak-theme&#34; class=&#34;uri&#34;&gt;https://github.com/kakawait/hugo-tranquilpeak-theme&lt;/a&gt; 中的 &lt;code&gt;hugo-tranquilpeak-theme-master\i18n&lt;/code&gt; 那样用不同 YAML 提供语言支持的做法也非常值得参考；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可解决&lt;/strong&gt;：多主题：&lt;a href=&#34;https://yulinling.net/&#34; class=&#34;uri&#34;&gt;https://yulinling.net/&lt;/a&gt; 中 blog 部分是卡片列表，而相册部分是另外一种主题，不知道是不是可以在不同的 Section 中用不同的主题，还是压根是两个站点，是一个站点，只需要给指定的 Section 一个特殊的 list.html 即可，参考&lt;a href=&#34;/tech/2017/07/08/hugo-template-priority/&#34;&gt;这里&lt;/a&gt;，再移植其它模板的代码即可；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;别解决&lt;/strong&gt;：如何通过 Hugo 删除一些不想要的 post 在 &lt;code&gt;public\&lt;/code&gt; 中的 html 存档，html 文档类似于缓存，删除之后下次 Render 时候又要再做一次，所以不要删除；&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;themes&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;4&lt;/span&gt; 主题调整&lt;/h1&gt;
&lt;div id=&#34;page-width&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.1&lt;/span&gt; 页面宽度&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;static/css/fonts/&lt;/code&gt; 中修改 &lt;code&gt;custom.css&lt;/code&gt;，相关内容参考该文件中的注释。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;font-family&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.2&lt;/span&gt; 字体&lt;/h2&gt;
&lt;p&gt;在 &lt;code&gt;static/css/fonts/&lt;/code&gt; 中修改 &lt;code&gt;fonts.css&lt;/code&gt;，调整字体相关的设置为如下内容：&lt;/p&gt;
&lt;pre class=&#34;css&#34;&gt;&lt;code&gt;body {
  font-family: &amp;#39;Alegreya&amp;#39;, &amp;#39;Palatino Linotype&amp;#39;, &amp;#39;Book Antiqua&amp;#39;, Palatino,
    &amp;#39;source-han-serif-sc&amp;#39;, &amp;#39;Source Han Serif SC&amp;#39;, &amp;#39;Source Han Serif CN&amp;#39;,
    &amp;#39;Source Han Serif TC&amp;#39;, &amp;#39;Source Han Serif TW&amp;#39;, &amp;#39;Source Han Serif&amp;#39;, &amp;#39;Songti SC&amp;#39;,
    &amp;#39;仿宋&amp;#39;, &amp;#39;FangSong&amp;#39;, &amp;#39;NSimSun&amp;#39;, &amp;#39;Microsoft YaHei&amp;#39;, serif;
}
blockquote {
  font-family: &amp;#39;Source Sans Pro&amp;#39;, Tahoma, Geneva, &amp;#39;STKaiti&amp;#39;, &amp;#39;KaiTi&amp;#39;, &amp;#39;楷体&amp;#39;, &amp;#39;SimKai&amp;#39;,
    &amp;#39;DFKai-SB&amp;#39;, &amp;#39;NSimSun&amp;#39;, serif;
}
.cn blockquote {
  font-family: &amp;#39;Alegreya&amp;#39;, &amp;#39;Palatino Linotype&amp;#39;, &amp;#39;Book Antiqua&amp;#39;, Palatino, &amp;#39;STKaiti&amp;#39;,
    &amp;#39;KaiTi&amp;#39;, &amp;#39;楷体&amp;#39;, &amp;#39;SimKai&amp;#39;, &amp;#39;DFKai-SB&amp;#39;, &amp;#39;NSimSun&amp;#39;, serif;
}
code {
  font-family: &amp;#39;PT Mono&amp;#39;, &amp;#39;STKaiti&amp;#39;, &amp;#39;KaiTi&amp;#39;, &amp;#39;SimKai&amp;#39;, monospace;
  font-size: 85%;
}
p code, li code {
  font-size: 90%;
}
strong {
  color: #2dbe60;
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;Hugo-Functions&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;5&lt;/span&gt; 功能解读&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Hugo 中的相关统计数据，如字数(&lt;code&gt;.WordCount&lt;/code&gt;)、估计阅读时间(&lt;code&gt;.ReadingTime&lt;/code&gt;)、页数、文章数、分类数等可以参考&lt;a href=&#34;https://gohugo.io/templates/variables/&#34;&gt;变量列表&lt;/a&gt;，特殊功能实现参考&lt;a href=&#34;https://gohugo.io/templates/functions/&#34;&gt;函数列表&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.Site.Params&lt;/code&gt; 开头的是站点的&lt;code&gt;全局&lt;/code&gt;参数，可以自定义；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.Params&lt;/code&gt; 开头的是当前文章中的&lt;code&gt;局部&lt;/code&gt;参数，在 yml 头中定义，但暂时不清楚是否可以自定义，当然即使可以支持，为了保持和其它系统或 Markdown 的良好兼容，不推荐在文章内用自定义的参数；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;下面的代码实现了一个循环：&lt;/p&gt;
&lt;pre class=&#34;html&#34;&gt;&lt;code&gt;{{ range .Site.Params.customJS }}
&amp;lt;script async src=&amp;quot;{{ . | relURL }}&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
{{ end }}&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;{{ with FOO }}{{ . }}{{ end }}&lt;/code&gt; 是 &lt;code&gt;{{if FOO }}{{ FOO }}{{ end }}&lt;/code&gt; 的另一种写法，可以不用写两次 &lt;code&gt;FOO&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.Data&lt;/code&gt; is dynamic, and its value changes according to the specific list you want to generate. For example, the list page &lt;code&gt;https://xmin.yihui.name/post/&lt;/code&gt; only contains pages under &lt;code&gt;content/post/&lt;/code&gt;, and &lt;code&gt;https://xmin.yihui.name/note/&lt;/code&gt; only contains pages under &lt;code&gt;content/note/&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;content\&lt;/code&gt; 目录下的 &lt;code&gt;_index.md&lt;/code&gt; 对应的是存档页，对应 &lt;code&gt;list.html&lt;/code&gt;，用于生成全部 post 的存档列表；分类、标签汇总页对应 &lt;code&gt;terms.html&lt;/code&gt;，是自动生成的，&lt;code&gt;single.html&lt;/code&gt; 对应一篇 post 的生成；分类、汇总还可以通过 &lt;code&gt;list.html&lt;/code&gt; 生成各自的存档页，对分类、标签设置不同的模板参考“待解决问题”；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_index.md&lt;/code&gt; 中有内容时（YAML 除外），本主题将 &lt;code&gt;list.html&lt;/code&gt; 转换成一个类似于网站主页说明的 &lt;code&gt;index.html&lt;/code&gt;，但这个转换不是用 &lt;code&gt;single.html&lt;/code&gt; 的模板，而是 &lt;code&gt;list.html&lt;/code&gt; 的 &lt;code&gt;if&lt;/code&gt; 分支的模板，没有内容时，填充当前 section 下的全部文章的 list。但不同位置的 &lt;code&gt;_index.md&lt;/code&gt; 的管辖范围不同；&lt;/li&gt;
&lt;li&gt;模板文件不能用 Markdown，只能用 html 语法格式；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;主题中一段比较有参考价值的代码的解释：&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;html&#34;&gt;&lt;code&gt;{{ if .File.Path }}

{{ $Rmd := (print .File.BaseFileName &amp;quot;.Rmd&amp;quot;)) }}

{{ if (where (readDir (print &amp;quot;content/&amp;quot; .File.Dir)) &amp;quot;Name&amp;quot; $Rmd) }}
  {{ $.Scratch.Set &amp;quot;FilePath&amp;quot; (print .File.Dir $Rmd) }}
{{ else }}
  {{ $.Scratch.Set &amp;quot;FilePath&amp;quot; .File.Path }}
{{ end }}

{{ with .Site.Params.GithubEdit}}
&amp;lt;a href=&amp;#39;{{ . }}{{ $.Scratch.Get &amp;quot;FilePath&amp;quot; }}&amp;#39;&amp;gt;Edit this page&amp;lt;/a&amp;gt;
{{ end }}

{{ end }}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The basic logic is that for a file, if the same filename with the extension .Rmd exists, we will point the Edit link to the Rmd file. First, we define a variable &lt;code&gt;$Rmd&lt;/code&gt; to be the filename with the &lt;code&gt;.Rmd&lt;/code&gt; extension. Then we check if it exists. Unfortunately, there is no function in Hugo like &lt;code&gt;file.exists()&lt;/code&gt; in R, so we have to use a hack: list all files under the directory and see if the Rmd file is in the list. &lt;code&gt;$.Scratch&lt;/code&gt; is the way to dynamically store and obtain variables in Hugo templates. Most variables in Hugo are read-only, and you have to use &lt;code&gt;$.Scratch&lt;/code&gt; when you want to modify a variable. We set a variable FilePath in &lt;code&gt;$.Scratch&lt;/code&gt;, whose value is the full path to the Rmd file when the Rmd file exists, and the path to the Markdown source file otherwise. Finally we concatenate a custom option GithubEdit in &lt;code&gt;config.toml&lt;/code&gt; with the file path to complete the Edit link &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;. Here is an example of the option in &lt;code&gt;config.toml&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.Data.Terms&lt;/code&gt; 解读：&lt;code&gt;.Data.Terms&lt;/code&gt; stores all terms under a taxonomy, e.g., all category names. The variable &lt;code&gt;$key&lt;/code&gt; denotes the term and &lt;code&gt;$value&lt;/code&gt; denotes the list of pages associated with this term. The link of the term is passed to the Hugo function relURL via a pipe &lt;code&gt;|&lt;/code&gt; to make it relative, &lt;code&gt;$&lt;/code&gt; is required because we are inside a loop, and need to access variables from the outside scope. 注意 &lt;code&gt;$value&lt;/code&gt; 中是全部文章对象&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;html&#34;&gt;&lt;code&gt;&amp;lt;ul class=&amp;quot;terms&amp;quot;&amp;gt;
  {{ range $key, $value := .Data.Terms }}
  &amp;lt;li&amp;gt;
    &amp;lt;a href=&amp;#39;{{ (print &amp;quot;/&amp;quot; $.Data.Plural &amp;quot;/&amp;quot; $key) | relURL }}&amp;#39;&amp;gt;
      {{ $key }}
    &amp;lt;/a&amp;gt;
    ({{ len $value }})
  &amp;lt;/li&amp;gt;
  {{ end }}
&amp;lt;/ul&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;这段代码的插入需要用比较特殊的语法，与传统的 R Markdow 中使用 backtick 的方法还不相同，具体参考源文件。&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;这个目录是本人电脑上的目录，可自行根据实际情况修改。&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;实际的修改过程要考虑的细节和内容要复杂很多，下面只是最早不太熟悉时候的一些记录。&lt;a href=&#34;#fnref3&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34;&gt;&lt;p&gt;必需通过 VPN 方式才能注册，无法用 Chrome 带的翻墙功能注册。&lt;a href=&#34;#fnref4&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>用 Python 搭建一个简单的 Web 服务器</title>
      <link>/tech/2017/07/06/python-web-server/</link>
      <pubDate>Thu, 06 Jul 2017 21:49:57 -0700</pubDate>
      
      <guid>/tech/2017/07/06/python-web-server/</guid>
      <description>
        &lt;p&gt;在 RStudio 中运行 Hugo 的站点时，含有中文的地址解析都会出错，就想查出到底是 Hugo 的原因还是 Blogdown 的原因，先是发现 &lt;a href=&#34;https://blog.coderzh.com/&#34; target=&#34;_blank&#34;&gt;https://blog.coderzh.com/&lt;/a&gt; 里面的中文分类以及中文 URL 地址在 Chrome 中都可以正常工作。于是接下来想自己搭一个简单的 Web 服务器，看看在非 Blogdown 的环境中会有什么样的结果。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;参考 &lt;a href=&#34;http://bbs.chinaunix.net/thread-743286-1-1.html&#34; target=&#34;_blank&#34;&gt;http://bbs.chinaunix.net/thread-743286-1-1.html&lt;/a&gt; 在 Hugo 的 &lt;code&gt;\public\&lt;/code&gt; 目录下放置一个包含如下内容的 Python 脚本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import SimpleHTTPServer
SimpleHTTPServer.test()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按照作者的说明，此时可以双击开启 &lt;code&gt;8000&lt;/code&gt; 端口并启动一个简单的 Web 服务，但由于是 Windows，因此根据廖雪峰的 Python 3.X 的讲义，不可能双击执行。于是在 CMD 窗口中尝试用 Python 命令来启动，仍然&lt;strong&gt;失败&lt;/strong&gt;，提示没有 &lt;code&gt;SimpleHTTPServer&lt;/code&gt; 包。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;参考 &lt;a href=&#34;http://www.cnblogs.com/harry-xiaojun/p/6739003.html&#34; target=&#34;_blank&#34;&gt;http://www.cnblogs.com/harry-xiaojun/p/6739003.html&lt;/a&gt;，在 CMD 窗口中输入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-dos&#34;&gt;python -m http.server 80
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这次成功启动。在 Chrome 中浏览发现带有中文 URL 地址的内容在这个简单的 Web 服务器下解析正常，因此大致上可以确定是 Blogdown 在接管 Hugo 提供的 Server 服务时，做了一些额外的事情，或者做的工作不够，导致中文 URL 地址解析出错。&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>比较回归系数的四种方法</title>
      <link>/prof/2017/06/27/comparing-coefficients/</link>
      <pubDate>Tue, 27 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/prof/2017/06/27/comparing-coefficients/</guid>
      <description>
        &lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1&lt;/span&gt; 总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#suest-&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2&lt;/span&gt; &lt;code&gt;suest&lt;/code&gt; 和交乘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#xtreg--suest&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3&lt;/span&gt; &lt;code&gt;xtreg&lt;/code&gt; 无法使用 &lt;code&gt;suest&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bdiff----by-&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4&lt;/span&gt; &lt;code&gt;bdiff&lt;/code&gt; - 自举法 by 连玉君&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#z-&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;5&lt;/span&gt; Z 统计量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-hausman-test---&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;6&lt;/span&gt; 不能用 Hausman test - 慧航&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; 总结&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;若干扰项相同，可以考虑用分组变量交乘项回归；&lt;/li&gt;
&lt;li&gt;若干扰项不相同但有关联，可以考虑用&lt;code&gt;suest&lt;/code&gt; test&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;，但这个命令不支持&lt;code&gt;xtreg&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;用自举法，&lt;code&gt;bdiff&lt;/code&gt; by 连玉君；&lt;/li&gt;
&lt;li&gt;构造一个 Z 统计量：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[z=\frac{\hat{\beta}_m-\hat{\beta}_f}{\sqrt{s^2(\hat{\beta}_m)+s^2(\hat{\beta}_f)}}\]&lt;/span&gt;&lt;/p&gt;
&lt;!-- more --&gt;
&lt;/div&gt;
&lt;div id=&#34;suest-&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;2&lt;/span&gt; &lt;code&gt;suest&lt;/code&gt; 和交乘&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;参考&lt;/strong&gt;：&lt;a href=&#34;http://bbs.pinggu.org/thread-2267159-1-1.html&#34; class=&#34;uri&#34;&gt;http://bbs.pinggu.org/thread-2267159-1-1.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Stata 里&lt;code&gt;suest&lt;/code&gt;可以做 Chow test 检验&lt;/p&gt;
&lt;p&gt;Example 2: Do coefficients vary between groups? (“Chow test”)&lt;/p&gt;
&lt;pre class=&#34;stata&#34;&gt;&lt;code&gt;. webuse income
. regress inc edu exp if male
. estimates store Male

. regress inc edu exp if !male
. estimates store Female

. suest Male Female
. test [Male_mean = Female_mean] // 注意这里是 test&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那如果我要检验两组的&lt;code&gt;edu&lt;/code&gt;系数是否相同，是不是可以用命令&lt;code&gt;test [Male_mean]edu =[ Female_mean]edu&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;另外，我在&lt;a href=&#34;http://www.stata.com/support/faqs/statistics/computing-chow-statistic/&#34; class=&#34;uri&#34;&gt;http://www.stata.com/support/faqs/statistics/computing-chow-statistic/&lt;/a&gt;这一网站看到，将&lt;code&gt;male&lt;/code&gt;与其他所有解释变量交乘，检验交乘项的系数也可以得到&lt;code&gt;edu&lt;/code&gt;系数在两组是否不同。我发现者两种方法的检验统计量不同，但 p 值大致相同。&lt;/p&gt;
&lt;p&gt;请问这两种方法有差异么？哪种更好？&lt;/p&gt;
&lt;blockquote class=&#34;gray&#34;&gt;
&lt;p&gt;&lt;strong&gt;连玉君&lt;/strong&gt;：&lt;code&gt;SUest&lt;/code&gt;假设两组的干扰项具有&lt;code&gt;不同&lt;/code&gt;的分布，允许两组的干扰项相关；而采用交乘项的方式，估计时只有一条方程，所以相当于假设两个组的干扰项具有&lt;code&gt;相同&lt;/code&gt;的分布。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div id=&#34;xtreg--suest&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;3&lt;/span&gt; &lt;code&gt;xtreg&lt;/code&gt; 无法使用 &lt;code&gt;suest&lt;/code&gt;&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://bbs.pinggu.org/thread-2862014-1-1.html&#34; class=&#34;uri&#34;&gt;http://bbs.pinggu.org/thread-2862014-1-1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://bbs.pinggu.org/thread-3927057-1-1.html&#34; class=&#34;uri&#34;&gt;http://bbs.pinggu.org/thread-3927057-1-1.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用面板数据进行分组回归（按中西东进行地区划分，分别作回归），如何对回归系数的差异的显著性进行检验？尝试用&lt;code&gt;suest&lt;/code&gt;命令做，但是结果显示：&lt;/p&gt;
&lt;pre class=&#34;stata&#34;&gt;&lt;code&gt;.suest region1 region2 region3

xtreg is not supported by suest&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即&lt;code&gt;suest&lt;/code&gt;不支持&lt;code&gt;xtreg&lt;/code&gt;命令。&lt;/p&gt;
&lt;blockquote class=&#34;gray&#34;&gt;
&lt;p&gt;&lt;strong&gt;连玉君&lt;/strong&gt;：如果估计的是固定效应模型，可以使用&lt;code&gt;reg y x i.id&lt;/code&gt;替代&lt;code&gt;xtreg y x, fe&lt;/code&gt;命令进行估计，然后就可以进一步使用&lt;code&gt;suest&lt;/code&gt;命令执行检验了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外还有命令&lt;code&gt;test&lt;/code&gt;和&lt;code&gt;ttest&lt;/code&gt;，可以&lt;strong&gt;进一步补充&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.michaelnormanmitchell.com/stow/comparing-coefficients-across-groups-using-suest-and-test.html&#34;&gt;Comparing coefficients across groups using suest and test&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;bdiff----by-&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;4&lt;/span&gt; &lt;code&gt;bdiff&lt;/code&gt; - 自举法 by 连玉君&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/23642050&#34; class=&#34;uri&#34;&gt;https://www.zhihu.com/question/23642050&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;z-&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;5&lt;/span&gt; Z 统计量&lt;/h1&gt;
&lt;p&gt;见最上面的总结部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Client Importance, Institutional Improvements, and Audit Quality in China: An Office and Individual Auditor Level Analysis, Chen &amp;amp; Sun &amp;amp; Wu(2010), TAR&lt;/li&gt;
&lt;li&gt;Statistical Methods for Comparing Regression Coefficients Between Models, Clogg &amp;amp; Petkova &amp;amp; Haritou(1995), American Journal of Sociology&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;-hausman-test---&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;6&lt;/span&gt; 不能用 Hausman test - 慧航&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/23642050&#34; class=&#34;uri&#34;&gt;https://www.zhihu.com/question/23642050&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hausman test 的应用场景：存在同一组系数的两个估计&lt;code&gt;b1&lt;/code&gt;和&lt;code&gt;b2&lt;/code&gt;，满足：在 H0 的条件下，&lt;code&gt;b1&lt;/code&gt;和&lt;code&gt;b2&lt;/code&gt;均一致，但是&lt;code&gt;b1&lt;/code&gt;是最有效的在 H1 的条件下，&lt;code&gt;b1&lt;/code&gt;是不一致的，但是&lt;code&gt;b2&lt;/code&gt;是一致的，Hausman 证明了，在 H0 的条件下，&lt;code&gt;var(b2-b1)=var(b2)-var(b1)&lt;/code&gt;故而可以构造统计量，&lt;code&gt;(b2-b1)(var(b2)-var(b1))^(-1)(b2-b1)~chi2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;比如，检验线性回归是不是有内生性：H0：不具有内生性 H1：具有内生性那么&lt;code&gt;b1&lt;/code&gt;就是 ols 回归结果，&lt;code&gt;b2&lt;/code&gt;就是 iv 的回归结果。同样，检验固定效应还是随机效应，&lt;code&gt;b1&lt;/code&gt;是随机效应结果，&lt;code&gt;b2&lt;/code&gt;是固定效应结果。但如果比较的是不是组回归的系数，显然不满足 Hausman test 的前提，所以绝对不能用 Hausman test。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;参考 UCLA 上面的《&lt;a href=&#34;https://stats.idre.ucla.edu/stata/code/comparing-regression-coefficients-across-groups-using-suest/&#34;&gt;Comparing Regressioni Coefficients Across Groups using Suest&lt;/a&gt;》。&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>正则</title>
      <link>/prof/2017/06/24/regular/</link>
      <pubDate>Sat, 24 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/prof/2017/06/24/regular/</guid>
      <description>
        &lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;临界点、正则点、临界值、正则值&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;出处&lt;/strong&gt;：经济数学方法与模型, de la Fuente(2000), 朱保华 &amp;amp; 钱晓明(2003), p150-151.&lt;/p&gt;
&lt;p&gt;在以后的讨论中，我们需要对函数的雅可比矩阵的秩作出假设，也就是对函数的导数作出假设。特别是，我们可以证明：若函数&lt;span class=&#34;math inline&#34;&gt;\(f:\mathbb{R}^n\to\mathbb{R}^m\)&lt;/span&gt;在&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;处可微，且导数矩阵&lt;span class=&#34;math inline&#34;&gt;\(\mathrm{D}f(x)\)&lt;/span&gt;的秩为&lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt;，则&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;的局部行为就可以由&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;的可微性决定。&lt;/p&gt;
&lt;p&gt;下面介绍一些在后面将用到的概念。令&lt;span class=&#34;math inline&#34;&gt;\(f:\mathbb{R}^n\supseteq X\to\mathbb{R}^m\)&lt;/span&gt;（&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;是开集）是可微函数&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;。若&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;在&lt;span class=&#34;math inline&#34;&gt;\(x\in X\)&lt;/span&gt;处的微分，即线性映射&lt;span class=&#34;math inline&#34;&gt;\(\mathrm{d}f_{x}\in L(\mathbb{R}^n,\mathbb{R}^m)\)&lt;/span&gt;是满射，则称&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;是&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;的正则点（Regular Point）。若&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;不是&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;的正则点，即若&lt;span class=&#34;math inline&#34;&gt;\(\mathrm{d}f_{x}\)&lt;/span&gt;不是满射，则称&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;是&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;的临界点（Critical Point）。若&lt;span class=&#34;math inline&#34;&gt;\(y\in\mathbb{R}^m\)&lt;/span&gt;是某个临界点的像，则称&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;是&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;的临界值，否则称&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;是&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;的正则值。&lt;/p&gt;
&lt;p&gt;可以看到，&lt;span class=&#34;math inline&#34;&gt;\(\mathrm{d}f_x\)&lt;/span&gt;是满射，即&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;是&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;的正则点的充要条件是导数&lt;span class=&#34;math inline&#34;&gt;\(\mathrm{D}f(x)\)&lt;/span&gt;的秩为&lt;span class=&#34;math inline&#34;&gt;\(m\)&lt;/span&gt;。因此，&lt;span class=&#34;math inline&#34;&gt;\(f:\mathbb{R}^n\supseteq X\to\mathbb{R}^m\)&lt;/span&gt;的临界点的集合为：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
C_f=\left\{\,x\in X;\,\text{rank}\,[\mathrm{D}f(x)]&amp;lt;m\,\right\}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;的临界值的集合为&lt;span class=&#34;math inline&#34;&gt;\(f(C_f)\)&lt;/span&gt;，正则值的集合为&lt;span class=&#34;math inline&#34;&gt;\(f(C_f)\)&lt;/span&gt;的补集，即&lt;span class=&#34;math inline&#34;&gt;\(\mathbb{R}^m\sim f(C_f)\)&lt;/span&gt;。可以看到：若&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;不是&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;中任意点的像，根据定义，正则值是那些不是临界值的点，则&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;是&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;的正则值，而&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;是临界值的充要条件是&lt;span class=&#34;math inline&#34;&gt;\(f^{-1}(y)\)&lt;/span&gt;至少包含一个临界点，这样&lt;span class=&#34;math inline&#34;&gt;\(f^{-1}(y)\)&lt;/span&gt;就不可能是空集。&lt;/p&gt;
&lt;p&gt;这个定义将初等微积分中临界点的定义作了推广。若&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;是多元实值函数，我们刚才给出的临界点的定义等价于条件“梯度&lt;span class=&#34;math inline&#34;&gt;\(\nabla f(x)\)&lt;/span&gt;是零向量”，因为只有这种情形&lt;span class=&#34;math inline&#34;&gt;\(\nabla f(x)\)&lt;/span&gt;不能生成&lt;span class=&#34;math inline&#34;&gt;\(\mathbb{R}\)&lt;/span&gt;；若&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;是一元函数，条件为&lt;span class=&#34;math inline&#34;&gt;\(f&amp;#39;(x)=0\)&lt;/span&gt;，同样看到：当&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;是从&lt;span class=&#34;math inline&#34;&gt;\(\mathbb{R}^n\)&lt;/span&gt;到&lt;span class=&#34;math inline&#34;&gt;\(\mathbb{R}^n\)&lt;/span&gt;的函数时，&lt;span class=&#34;math inline&#34;&gt;\(\mathrm{D}f(x)\)&lt;/span&gt;是方阵，若&lt;span class=&#34;math inline&#34;&gt;\(|\mathrm{D}f(x)|=0\)&lt;/span&gt;，则&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;是临界点。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;经济是正则的&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;出处&lt;/strong&gt;：经济学拓扑方法, 王则柯(2001), p305.&lt;/p&gt;
&lt;p&gt;设&lt;span class=&#34;math inline&#34;&gt;\(\pmb{p}\)&lt;/span&gt;是经济&lt;span class=&#34;math inline&#34;&gt;\(\varepsilon\)&lt;/span&gt;的一个均衡价格向量，即&lt;span class=&#34;math inline&#34;&gt;\(f(\pmb{p})=\pmb{0}\)&lt;/span&gt;，那么当&lt;span class=&#34;math inline&#34;&gt;\(\mathrm{Rank}[\mathrm{d}f_{\pmb{p}}]=n-1\)&lt;/span&gt;时，称均衡价格向量&lt;span class=&#34;math inline&#34;&gt;\(\pmb{p}\)&lt;/span&gt;是正则的（Regular）。如果每个均衡价格向量都是正则的，就说该经济&lt;span class=&#34;math inline&#34;&gt;\(\varepsilon\)&lt;/span&gt;是正则的&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;换言之，如果&lt;span class=&#34;math inline&#34;&gt;\(f(\pmb{p})=\pmb{0}\)&lt;/span&gt;时必有&lt;span class=&#34;math inline&#34;&gt;\(\mathrm{Rank}[\mathrm{d}f_{\pmb{p}}]=n-1\)&lt;/span&gt;，就说经济&lt;span class=&#34;math inline&#34;&gt;\(\varepsilon\)&lt;/span&gt;是正则的。&lt;/p&gt;
&lt;p&gt;作为一般经济均衡问题微分方法的初步结果，我们有如下定理&lt;a href=&#34;#fn3&#34; class=&#34;footnoteRef&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;均衡价格向量&lt;span class=&#34;math inline&#34;&gt;\(\pmb{p}\in\mathbb{S}_+^{n-1}\)&lt;/span&gt;正则当且仅当在&lt;span class=&#34;math inline&#34;&gt;\((\pmb{p},\pmb{0})\)&lt;/span&gt;，流形&lt;span class=&#34;math inline&#34;&gt;\(T\mathbb{S}_0^{n-1}\)&lt;/span&gt;和流形&lt;span class=&#34;math inline&#34;&gt;\(\text{Graph}\,f\)&lt;/span&gt;在流形&lt;span class=&#34;math inline&#34;&gt;\(T^{n-1}\)&lt;/span&gt;中横截。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;这里的&lt;span class=&#34;math inline&#34;&gt;\(\mathbb{R}^m\)&lt;/span&gt;是一个多维的变量，但只要不是集合，就可以认为&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;是函数？&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;这里的秩为&lt;span class=&#34;math inline&#34;&gt;\(n-1\)&lt;/span&gt;为什么要有一个&lt;code&gt;-1&lt;/code&gt;，感觉和下面的&lt;span class=&#34;math inline&#34;&gt;\(\pmb{p}\in\mathbb{S}_+^{n-1}\)&lt;/span&gt;有关。&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;没有学过拓扑，看不懂。&lt;a href=&#34;#fnref3&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>Python 动态创建类 z</title>
      <link>/tech/2017/06/19/create-class-dynamic/</link>
      <pubDate>Mon, 19 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/06/19/create-class-dynamic/</guid>
      <description>
        

&lt;h1 id=&#34;廖雪峰-metaclass-orm-个人理解&#34;&gt;廖雪峰 Metaclass-ORM 个人理解&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;默认的类看不出是动态创建的；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eval()&lt;/code&gt;, &lt;code&gt;getattr&lt;/code&gt; 动态创建对象 - 见下面内容；&lt;/li&gt;
&lt;li&gt;区分&lt;code&gt;__getattr__()&lt;/code&gt;方法与&lt;code&gt;getattr()&lt;/code&gt;函数；前者是访问不存在的属性时动态返回一个属性或函数，后者是返回指定类属性的取值；&lt;/li&gt;
&lt;/ol&gt;

&lt;!-- more --&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li&gt;廖雪峰的 ORM 的例子中中，&lt;code&gt;Model&lt;/code&gt;里面只有非常抽象的&lt;code&gt;save()&lt;/code&gt;等方法，在&lt;code&gt;ModelMetaclass&lt;/code&gt;里面根据&lt;code&gt;User&lt;/code&gt;中的属性动态创建映射关系，然后再实时返回一个创建好的具体的&lt;code&gt;User&lt;/code&gt;类；
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Users&lt;/code&gt;中由使用者指定需要映射的具体条目，对于不同的使用者，要映射的条目不相同，比如现在要的是&lt;code&gt;username, email&lt;/code&gt;，下次的场景就可能是&lt;code&gt;user, password&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;即使要映射的条目相同，使用者定义的&lt;code&gt;Users&lt;/code&gt;的属性名称也可能不同，比如有人是&lt;code&gt;username&lt;/code&gt;，有人可能是&lt;code&gt;userid&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;但我们不希望每次需求不同时，就重新定义一个面向特定需求的类，类中包含需要的各种属性；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;分离出来的&lt;code&gt;Model&lt;/code&gt;负责实现与数据库的交互，但&lt;code&gt;Model&lt;/code&gt;不清楚究竟要与哪张表交互，有哪些字段；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ModelMetaclass&lt;/code&gt;在 new Users 的时候，就把&lt;code&gt;Users&lt;/code&gt;中指定好的条目对（本地条目、数据库表的字段）接管过来，保存好&lt;code&gt;属性-字段&lt;/code&gt;关系，将其作为一部分参数重新传递给&lt;code&gt;type()&lt;/code&gt;函数重新创建&lt;code&gt;User&lt;/code&gt;类，也就是在&lt;code&gt;Users()&lt;/code&gt;创建的时候拦截下来，做了修改之后再按规划创建一个规范的&lt;code&gt;User&lt;/code&gt;类&lt;/li&gt;
&lt;li&gt;&lt;code&gt;User&lt;/code&gt;如果不用&lt;code&gt;ModelMetaclass&lt;/code&gt;的话，其创建的时候，自身是无法知道接下来会有什么属性和属性名的。&lt;/li&gt;
&lt;li&gt;这时&lt;code&gt;User&lt;/code&gt;继承自&lt;code&gt;Model&lt;/code&gt;的&lt;code&gt;Save()&lt;/code&gt;其实在此之前并不知道会有哪些条目，但是经过&lt;code&gt;ModelMetaclass&lt;/code&gt;之后，就可以从动态生成的&lt;code&gt;__mappings__&lt;/code&gt;中获知这一点；&lt;/li&gt;
&lt;li&gt;现在&lt;code&gt;User&lt;/code&gt;只管根据需要即时创建好条目对，之后由&lt;code&gt;ModelMetaclass&lt;/code&gt;创建修改后的类，创建初始化完成后，参数再传递到继承自&lt;code&gt;Model&lt;/code&gt;的&lt;code&gt;Save()&lt;/code&gt;方法，最后&lt;code&gt;Save()&lt;/code&gt;根据收到的参数：对象的具体参数以及具体需要的条目对完成数据库操作。&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;User&lt;/code&gt;中只有条目对作为属性；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ModelMetaclass&lt;/code&gt;中只有&lt;code&gt;__new__()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Model&lt;/code&gt;中包含具体的初始化以及业务逻辑。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;利用-eval&#34;&gt;利用 eval()&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;a href=&#34;http://blog.chinaunix.net/uid-608135-id-3774614.htmlz&#34; target=&#34;_blank&#34;&gt;http://blog.chinaunix.net/uid-608135-id-3774614.htmlz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;某些时候我们需要创建一个对象的时候，要根据运行环境来确定对象的类型，这个时候就需要一种方法来动态的创建对象，也就是说类的名字是不确定的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def getObj(name):
    return eval(name+&#39;()&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;利用-getattr-函数-未理解&#34;&gt;利用 getattr() 函数 - 未理解&lt;/h1&gt;

&lt;p&gt;比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;modulename = &#39;haha&#39; #模块字符串
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;m = __import__(mymodule)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面方法就可以用 Python 动态创建类。如果要取得模块中的一个属性的话：可以用&lt;code&gt;getattr()&lt;/code&gt;，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;c = getattr(m, &#39;myclass&#39;) 
myobject = c()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是要注意：如果&lt;code&gt;myclass&lt;/code&gt;并不在&lt;code&gt;mymodule&lt;/code&gt;的自动导出列表中（&lt;code&gt;__all__&lt;/code&gt;），则必须显式地导入，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;m = __import__(&#39;mymodule&#39;, globals(), locals(), [&#39;myclass&#39;]) 
c = getattr(m, &#39;myclass&#39;) 
myobject = c()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单的可以用&lt;code&gt;globals()[class_name]()&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def create_obj(cls_name):
    names = cls_name.split(&amp;quot;.&amp;quot;)
    cls = globals()[names[0]]
    for name in names[1:]:
        cls = getattr(cls, name)

    if isinstance(cls, type):
        return cls()
    else:
        raise Exception(&amp;quot;no such class&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要使用当前模块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;classname = &#39;blabla&#39;;
mod       = sys.modules[__name__];
dynclass  = getattr(mod, classname)
object    = dynclass(params);
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;利用-type&#34;&gt;利用 type()&lt;/h1&gt;

&lt;h1 id=&#34;利用-metaclass-return-type&#34;&gt;利用 Metaclass + return type()&lt;/h1&gt;

&lt;h1 id=&#34;class-in-function-不如-eval-彻底&#34;&gt;class in function - 不如 eval 彻底&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;代码出处&lt;/strong&gt;：&lt;a href=&#34;https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python&#34; target=&#34;_blank&#34;&gt;https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如同 &lt;strong&gt;e-satis&lt;/strong&gt; 所说的，这里的方案还不够动态，因为仍然需要自己编写整个类的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def choose_class(name):
…       if name == &#39;foo&#39;:
…           class Foo(object):
…               pass
…           return Foo          # 返回的是类，不是类的实例
…       else:
…           class Bar(object):
…               pass
…           return Bar
…
&amp;gt;&amp;gt;&amp;gt; MyClass = choose_class(&#39;foo&#39;)
&amp;gt;&amp;gt;&amp;gt; print MyClass               # 函数返回的是类，不是类的实例
&amp;lt;class &#39;__main__&#39;.Foo&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print MyClass()             # 你可以通过这个类创建类实例，也就是对象
&amp;lt;__main__.Foo object at 0x89c6d4c&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

        
      </description>
    </item>
    
    <item>
      <title>SAS 中 IF 与 WHERE 的辨析</title>
      <link>/tech/2017/06/18/sas-if-where/</link>
      <pubDate>Sun, 18 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/06/18/sas-if-where/</guid>
      <description>
        &lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;：《SAS 编程演义》, by 谷鸿秋, p90&lt;/p&gt;

&lt;p&gt;在新数据集里，我们可能只要部分观测，比如：只要女生。如何挑出女生的观测呢？通常可以从这三个阶段入手：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;打开数据集时，直接读取只需要的观测；&lt;/li&gt;
&lt;li&gt;PDV 里筛选过滤观测；&lt;/li&gt;
&lt;li&gt;只写入所需观测进入数据集。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体执行时，可以借助 &lt;code&gt;IF&lt;/code&gt; 或 &lt;code&gt;WHERE&lt;/code&gt; 语句选项。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt;*===第一阶段：通过 WHERE 选项限定读入数据集;
data tmp;
    set sashlep.class(where=(sex=&amp;quot;F&amp;quot;));
run;

*===第二阶段：通过 IF 或者 WHERE 语句;
*===通过 where 语句;
data tmp;
    set sashlep.class;
    where sex=&amp;quot;F&amp;quot;;
run;

*===通过求子集 IF 语句;
data tmp;
    set sashlep.class;
    if sex=&amp;quot;F&amp;quot;;
run;

*===第三阶段：通过 WHERE 选项限定输出数据集;
data tmp(where=(sex=&amp;quot;F&amp;quot;));
    set sashlep.class;
run;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;在数据集选项里，我们只能用 &lt;code&gt;WHERE&lt;/code&gt;，而不能用 &lt;code&gt;IF&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;从效率上讲，&lt;code&gt;WHERE&lt;/code&gt; 更高效。因为 &lt;code&gt;WHERE&lt;/code&gt; 语句在读入 PDV 之前就先行判断，而求子集 &lt;code&gt;IF&lt;/code&gt; 语句先读入观测进入 PDV，而后再判断；&lt;/li&gt;
&lt;li&gt;从使用范围上讲，&lt;code&gt;WHERE&lt;/code&gt; 更广泛。&lt;code&gt;WHREE&lt;/code&gt; 语句不仅可以用在 &lt;code&gt;DATA&lt;/code&gt; 步，还可以用在 &lt;code&gt;PROC&lt;/code&gt; 步中。此外，&lt;code&gt;WHERE&lt;/code&gt; 还可以作为数据集选项使用，而 &lt;code&gt;IF&lt;/code&gt; 只能作为 &lt;code&gt;DATA&lt;/code&gt; 步语句使用；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IF&lt;/code&gt; 语句对 &lt;code&gt;INPUT&lt;/code&gt; 语句创建的观测有效，但是 &lt;code&gt;WHERE&lt;/code&gt; 语句只能筛选数据集里的观测；&lt;/li&gt;
&lt;li&gt;有 &lt;code&gt;BY&lt;/code&gt; 语句时，求子集 &lt;code&gt;IF&lt;/code&gt; 语句与 &lt;code&gt;WHERE&lt;/code&gt; 语句的结果可能会不同，因为 SAS 创建 &lt;code&gt;BY&lt;/code&gt; 组在 &lt;code&gt;WHERE&lt;/code&gt; 之后，求子集 &lt;code&gt;IF&lt;/code&gt; 语句之前；&lt;/li&gt;
&lt;li&gt;求子集 &lt;code&gt;IF&lt;/code&gt; 语句可以用在条件 &lt;code&gt;IF&lt;/code&gt; 语句中，但 &lt;code&gt;WHERE&lt;/code&gt; 语句不行；&lt;/li&gt;
&lt;li&gt;当读入多个数据集时，求子集 &lt;code&gt;IF&lt;/code&gt; 语句无法针对每个数据集单独筛选，但是 &lt;code&gt;WHERE&lt;/code&gt; 选项却可以。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大多数情况下，作者喜欢用数据集选项来筛选观测。因此，在筛选观测时，代码大致如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sas&#34;&gt;*=== WHERE 选项筛选观测;
data want(where=(not missing(id)));
    set raw1(where=(age between  20 and 30))  raw2(where=(sex=&amp;quot;F&amp;quot;));
run;
&lt;/code&gt;&lt;/pre&gt;

        
      </description>
    </item>
    
    <item>
      <title>《廖雪峰 Python 教程》笔记 5：面向对象编程2</title>
      <link>/tech/2017/06/18/python-class-2/</link>
      <pubDate>Sun, 18 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/06/18/python-class-2/</guid>
      <description>
        

&lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186738532805c392f2cc09446caf3236c34e3f980f000&#34; target=&#34;_blank&#34;&gt;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186738532805c392f2cc09446caf3236c34e3f980f000&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;进一步阅读&lt;/strong&gt;资料，了解关于 Metaclass 的相关细节：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;/stylus/2014/08/10/python-class-object/&#34;&gt;深刻理解Python中的元类(metaclass)&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;/stylus/2017/06/18/create-class-dynamic/&#34;&gt;Python 动态创建类z&lt;/a&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Python 是动态语言，因此创建了一个&lt;code&gt;class&lt;/code&gt;的实例后，可以给该实例绑定任何属性和方法。但是，给一个实例绑定的方法，对另一个实例是不起作用的。为了给所有实例都绑定方法，可以给&lt;code&gt;class&lt;/code&gt;绑定方法，之后该方法所有实例均可调用。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;定制类&#34;&gt;定制类&lt;/h1&gt;

&lt;h2 id=&#34;slots-限制实例可以添加的属性和方法&#34;&gt;&lt;strong&gt;slots&lt;/strong&gt; - 限制实例可以添加的属性和方法&lt;/h2&gt;

&lt;p&gt;试图绑定不允许的属性将得到&lt;code&gt;AttributeError&lt;/code&gt;的错误。但要注意，&lt;code&gt;__slots__&lt;/code&gt;定义的属性仅对当前类实例起作用，对继承的子类是不起作用的，除非在子类中也定义&lt;code&gt;__slots__&lt;/code&gt;，这样，子类实例允许定义的属性就是自身的&lt;code&gt;__slots__&lt;/code&gt;加上父类的&lt;code&gt;__slots__&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):
    __slots__ = (&#39;name&#39;, &#39;age&#39;) # 用tuple定义允许绑定的属性名称
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;str-repr-结果看上去更人性化&#34;&gt;__str__(), __repr__() - 结果看上去更人性化&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__str__()&lt;/code&gt;：&lt;code&gt;print()&lt;/code&gt;类的实例时结果看上去更人性化；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__repr__()&lt;/code&gt;：直接访问类实例，不&lt;code&gt;print()&lt;/code&gt;时的结果更人性化。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return &#39;Student object (name=%s)&#39; % self.name
    __repr__ = __str__
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;iter-类似-list-或-tuple-那样可以-for-in&#34;&gt;__iter__() - 类似 list 或 tuple 那样可以 for&amp;hellip; in&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;class Fib(object):
    def __init__(self):
        self.a, self.b = 0, 1 # 初始化两个计数器a，b

    def __iter__(self):
        return self # 实例本身就是迭代对象，故返回自己

    def __next__(self):
        self.a, self.b = self.b, self.a + self.b # 计算下一个值
        if self.a &amp;gt; 100000: # 退出循环的条件
            raise StopIteration()
        return self.a # 返回下一个值
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;getitem-更像-list-下标-切片访问&#34;&gt;__getitem__() - 更像 list 下标、切片访问&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Fib(object):
    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        return a

&amp;gt;&amp;gt;&amp;gt; f = Fib()
&amp;gt;&amp;gt;&amp;gt; f[0]
1
&amp;gt;&amp;gt;&amp;gt; f[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;切片访问&#34;&gt;切片访问&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Fib(object):
    def __getitem__(self, n):
        if isinstance(n, int): # n是索引
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            return a
        if isinstance(n, slice): # n是切片
            start = n.start
            stop = n.stop
            if start is None:
                start = 0
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &amp;gt;= start:
                    L.append(a)
                a, b = b, a + b
            return L
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;切片的&lt;code&gt;step&lt;/code&gt;功能，即&lt;code&gt;f[:10:2]&lt;/code&gt;中的&lt;code&gt;2&lt;/code&gt;，负数处理等都需要额外的代码实现。所以，要正确实现一个&lt;code&gt;__getitem__()&lt;/code&gt;还是有很多工作要做的。&lt;/p&gt;

&lt;p&gt;此外，如果把对象看成&lt;code&gt;dict&lt;/code&gt;，&lt;code&gt;__getitem__()&lt;/code&gt;的参数也可能是一个可以作&lt;code&gt;key&lt;/code&gt;的&lt;code&gt;object&lt;/code&gt;，例如&lt;code&gt;str&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;与之对应的是&lt;code&gt;__setitem__()&lt;/code&gt;方法，把对象视作&lt;code&gt;list&lt;/code&gt;或&lt;code&gt;dict&lt;/code&gt;来对集合赋值。最后，还有一个&lt;code&gt;__delitem__()&lt;/code&gt;方法，用于删除某个元素。&lt;/p&gt;

&lt;p&gt;总之，通过上面的方法，我们自己定义的类表现得和 Python 自带的&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;tuple&lt;/code&gt;、&lt;code&gt;dict&lt;/code&gt;没什么区别，这完全归功于动态语言的“鸭子类型”，不需要强制继承某个接口。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;理解&lt;/strong&gt;：可能直接继承自&lt;code&gt;list()&lt;/code&gt;，然后将返回值变成一个&lt;code&gt;list&lt;/code&gt;值的对象可能更容易达到目的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;getattr-动态返回一个不存在的属性或函数&#34;&gt;__getattr__() - 动态返回一个不存在的属性或函数&lt;/h2&gt;

&lt;p&gt;注意与&lt;code&gt;getattr()&lt;/code&gt;函数区分开：&lt;code&gt;c = getattr(m, &#39;myclass&#39;)&lt;/code&gt;。前者是返回指定类属性的取值，后者是访问不存在的属性时动态返回一个属性或函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):

    def __init__(self):
        self.name = &#39;Michael&#39;

    def __getattr__(self, attr):
        if attr==&#39;score&#39;:
            return 99

&amp;gt;&amp;gt;&amp;gt; s = Student()
&amp;gt;&amp;gt;&amp;gt; s.name
&#39;Michael&#39;
&amp;gt;&amp;gt;&amp;gt; s.score
99

# 返回函数
class Student(object):

    def __getattr__(self, attr):
        if attr==&#39;age&#39;:
            return lambda: 25
只是调用方式要变为：

&amp;gt;&amp;gt;&amp;gt; s.age()     # 注意调用方法
25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到任意调用如&lt;code&gt;s.abc&lt;/code&gt;都会返回&lt;code&gt;None&lt;/code&gt;，这是因为我们定义的&lt;code&gt;__getattr__()&lt;/code&gt;默认返回就是&lt;code&gt;None&lt;/code&gt;。要让&lt;code&gt;class&lt;/code&gt;只响应特定的几个属性，我们就要按照约定，抛出&lt;code&gt;AttributeError&lt;/code&gt;的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):

    def __getattr__(self, attr):
        if attr==&#39;age&#39;:
            return lambda: 25
        raise AttributeError(&#39;\&#39;Student\&#39; object has no attribute \&#39;%s\&#39;&#39; % attr)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;理解&lt;/strong&gt;：理解教程中 REST 的关键就在于，一个 URL 对应一个功能接口，所以在链式方式调用某个功能时，利用&lt;code&gt;__getattr__()&lt;/code&gt;可以动态实现一个特定的 URL 字符串，这样就不必要针对每个功能的 URL 专门定义一个方法或属性，而是动态生成即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Chain(object):

    def __init__(self, path=&#39;GET &#39;):
        self._path = path

    def __getattr__(self, path):
        return Chain(&#39;%s/%s&#39; % (self._path, path))

    def __call__(self,path):
        return Chain(&#39;%s/%s&#39; % (self._path, path))

    def __str__(self):
        return self._path

    __repr__ = __str__


print(Chain().users(&#39;lidu&#39;).repos)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Chain() -&amp;gt; init&lt;/code&gt;得到&lt;code&gt;&#39;GET &#39;&lt;/code&gt;，&lt;code&gt;.user()&lt;/code&gt;没有这个方法，所以走&lt;code&gt;__getattr__()&lt;/code&gt;，这时，&lt;code&gt;self._path&lt;/code&gt;是&lt;code&gt;GET&lt;/code&gt;，&lt;code&gt;path&lt;/code&gt;是&lt;code&gt;user&lt;/code&gt;，然后在传给&lt;code&gt;Chain&lt;/code&gt;时，被连接了起来&lt;code&gt;GET /user&lt;/code&gt;，然后又调用了&lt;code&gt;Chain -&amp;gt; init&lt;/code&gt;，这时，&lt;code&gt;path&lt;/code&gt;为&lt;code&gt;GET /user&lt;/code&gt;， 因为&lt;code&gt;Chain()&lt;/code&gt;将生成一个实例，而这个实例后面跟着&lt;code&gt;(&#39;lidu&#39;)&lt;/code&gt;，所以将调用&lt;code&gt;__call__()&lt;/code&gt;，把&lt;code&gt;lidu&lt;/code&gt;与&lt;code&gt;_path&lt;/code&gt;连接起来，然后&lt;code&gt;__call__()&lt;/code&gt;中又调用&lt;code&gt;Chain()&lt;/code&gt;，继续走&lt;code&gt;init&lt;/code&gt;, 把&lt;code&gt;GET /user/lidu&lt;/code&gt;给了&lt;code&gt;_path&lt;/code&gt;，后面又跟了一个&lt;code&gt;.repos&lt;/code&gt;，没有这个属性，走&lt;code&gt;__getatter__()&lt;/code&gt;，就如一开始那样，把&lt;code&gt;repos&lt;/code&gt;也连接起来了。&lt;/p&gt;

&lt;p&gt;最后，外面是一个&lt;code&gt;print&lt;/code&gt;，里面是一个&lt;code&gt;Chain&lt;/code&gt;的实例，所以会调用&lt;code&gt;str&lt;/code&gt;，类中定义&lt;code&gt;str&lt;/code&gt;返回&lt;code&gt;_path&lt;/code&gt;，就是上面一连串过程后，生成的字符串：&lt;code&gt;GET /user/lidu/repos&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&#34;call-让实例像函数一样-callable&#34;&gt;__call__() - 让实例像函数一样 callable&lt;/h2&gt;

&lt;p&gt;这部分可以参考&lt;a href=&#34;/stylus/2015/04/19/python-call/&#34;&gt;Python 中 __init__ 和 __call__ 的区别z&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;一个对象实例可以有自己的属性和方法，当我们调用实例方法时，我们用&lt;code&gt;instance.method()&lt;/code&gt;来调用。能不能直接在实例本身上调用呢？在 Python 中，答案是肯定的。&lt;/p&gt;

&lt;p&gt;任何类，只需要定义一个&lt;code&gt;__call__()&lt;/code&gt;方法，就可以直接对实例进行调用。请看示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):
    def __init__(self, name):
        self.name = name

    def __call__(self):
        print(&#39;My name is %s.&#39; % self.name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用方式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = Student(&#39;Michael&#39;)
&amp;gt;&amp;gt;&amp;gt; s() # self参数不要传入
My name is Michael.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;__call__()&lt;/code&gt;还可以定义参数。对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。&lt;/p&gt;

&lt;p&gt;如果你把对象看成函数，那么函数本身其实也可以在运行期动态创建出来，因为类的实例都是运行期创建出来的，这么一来，我们就模糊了对象和函数的界限。&lt;/p&gt;

&lt;p&gt;那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个 Callable 对象，比如函数和我们上面定义的带有&lt;code&gt;__call__()&lt;/code&gt;的类实例：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; callable(Student())
True
&amp;gt;&amp;gt;&amp;gt; callable(max)
True
&amp;gt;&amp;gt;&amp;gt; callable([1, 2, 3])
False
&amp;gt;&amp;gt;&amp;gt; callable(None)
False
&amp;gt;&amp;gt;&amp;gt; callable(&#39;str&#39;)
False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;code&gt;callable()&lt;/code&gt;函数，我们就可以判断一个对象是否是&lt;code&gt;可调用&lt;/code&gt;对象。&lt;/p&gt;

&lt;h1 id=&#34;property-方便的-set-get&#34;&gt;@property - 方便的 set(), get()&lt;/h1&gt;

&lt;p&gt;在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数。为解决这一缺陷，&lt;a href=&#34;/stylus/2017/06/17/Python-class/&#34;&gt;初级方法中的解决方案&lt;/a&gt;是将属性设定为私有类型，然后提供相应的&lt;code&gt;set(), get()&lt;/code&gt;方法来访问属性。但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？Python内置的&lt;code&gt;@property&lt;/code&gt;装饰器就是负责把一个方法变成属性调用的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer!&#39;)
        if value &amp;lt; 0 or value &amp;gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@property&lt;/code&gt;的实现比较复杂，我们先考察如何使用。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;用法&lt;/strong&gt;：把一个&lt;code&gt;getter()&lt;/code&gt;方法变成属性，只需要加上&lt;code&gt;@property&lt;/code&gt;就可以了，此时，&lt;code&gt;@property&lt;/code&gt;本身又创建了另一个装饰器&lt;code&gt;@score.setter&lt;/code&gt;，负责把一个&lt;code&gt;setter()&lt;/code&gt;方法变成属性赋值，于是，我们就拥有一个可控的属性操作：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = Student()
&amp;gt;&amp;gt;&amp;gt; s.score = 60 # OK，实际转化为s.set_score(60)
&amp;gt;&amp;gt;&amp;gt; s.score # OK，实际转化为s.get_score()
60
&amp;gt;&amp;gt;&amp;gt; s.score = 9999
Traceback (most recent call last):
  ...
ValueError: score must between 0 ~ 100!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意到这个神奇的&lt;code&gt;@property&lt;/code&gt;，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过&lt;code&gt;getter()&lt;/code&gt;和&lt;code&gt;setter()&lt;/code&gt;方法来实现的。还可以定义只读属性，只定义&lt;code&gt;getter()方法，不定义&lt;/code&gt;setter()方法就是一个只读属性：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2015 - self._birth
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;多重继承-mixin&#34;&gt;多重继承, MixIn&lt;/h1&gt;

&lt;p&gt;通过多重继承，一个子类就可以同时获得多个父类的所有功能。&lt;/p&gt;

&lt;p&gt;在设计类的继承关系时，通常，&lt;strong&gt;主线&lt;/strong&gt;都是&lt;code&gt;单一&lt;/code&gt;继承下来的，例如，&lt;code&gt;Ostrich&lt;/code&gt;继承自&lt;code&gt;Bird&lt;/code&gt;。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让&lt;code&gt;Ostrich&lt;/code&gt;除了继承自&lt;code&gt;Bird&lt;/code&gt;外，再同时继承&lt;code&gt;Runnable&lt;/code&gt;。这种设计通常称之为&lt;strong&gt;MixIn&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;为了更好地看出继承关系，我们把&lt;code&gt;Runnable&lt;/code&gt;和&lt;code&gt;Flyable&lt;/code&gt;改为&lt;code&gt;RunnableMixIn&lt;/code&gt;和&lt;code&gt;FlyableMixIn&lt;/code&gt;。类似的，你还可以定义出肉食动物&lt;code&gt;CarnivorousMixIn&lt;/code&gt;和植食动物&lt;code&gt;HerbivoresMixIn&lt;/code&gt;，让某个动物同时拥有好几个&lt;code&gt;MixIn&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Dog(Mammal, RunnableMixIn, CarnivorousMixIn):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;MixIn 的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个 MixIn 的功能，而不是设计&lt;del&gt;&lt;code&gt;多层次&lt;/code&gt;&lt;/del&gt;的复杂的继承关系&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:Python-MixIn-Jav&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:Python-MixIn-Jav&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;理解&lt;/strong&gt;：MixIn 本身在语法上和主线上的继承类没有区别，但是在名称上加了&lt;code&gt;MixIn&lt;/code&gt;以后，可以更清晰的看到继承的主与次？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Python 自带的很多库也使用了 MixIn。举个例子，Python 自带了&lt;code&gt;TCPServer&lt;/code&gt;和&lt;code&gt;UDPServer&lt;/code&gt;这两类网络服务，而要同时服务多个用户就必须使用多进程或多线程模型，这两种模型由&lt;code&gt;ForkingMixIn&lt;/code&gt;和&lt;code&gt;ThreadingMixIn&lt;/code&gt;提供。通过组合，我们就可以创造出合适的服务来。&lt;/p&gt;

&lt;p&gt;比如，编写一个多进程模式的 TCP 服务，定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyTCPServer(TCPServer, ForkingMixIn):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编写一个多线程模式的 UDP 服务，定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyUDPServer(UDPServer, ThreadingMixIn):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你打算搞一个更先进的协程模型，可以编写一个&lt;code&gt;CoroutineMixIn&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyTCPServer(TCPServer, CoroutineMixIn):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。&lt;/p&gt;

&lt;h1 id=&#34;枚举&#34;&gt;枚举&lt;/h1&gt;

&lt;p&gt;Python提供了&lt;code&gt;Enum&lt;/code&gt;类来实现这个功能：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from enum import Enum

Month = Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样我们就获得了&lt;code&gt;Month&lt;/code&gt;类型的枚举类，可以直接使用&lt;code&gt;Month.Jan&lt;/code&gt;来引用一个常量，或者枚举它的所有成员：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for name, member in Month.__members__.items():
    print(name, &#39;=&amp;gt;&#39;, member, &#39;,&#39;, member.value)

Jan =&amp;gt; Month.Jan , 1
Feb =&amp;gt; Month.Feb , 2
Mar =&amp;gt; Month.Mar , 3
Apr =&amp;gt; Month.Apr , 4
May =&amp;gt; Month.May , 5
Jun =&amp;gt; Month.Jun , 6
Jul =&amp;gt; Month.Jul , 7
Aug =&amp;gt; Month.Aug , 8
Sep =&amp;gt; Month.Sep , 9
Oct =&amp;gt; Month.Oct , 10
Nov =&amp;gt; Month.Nov , 11
Dec =&amp;gt; Month.Dec , 12
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;value&lt;/code&gt;属性则是自动赋给成员的&lt;code&gt;int&lt;/code&gt;常量，默认从&lt;code&gt;1&lt;/code&gt;开始计数。&lt;/p&gt;

&lt;p&gt;如果需要更精确地控制枚举类型，可以从&lt;code&gt;Enum&lt;/code&gt;派生出自定义类：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from enum import Enum, unique

@unique
class Weekday(Enum):
    Sun = 0 # Sun的value被设定为0
    Mon = 1
    Tue = 2
    Wed = 3
    Thu = 4
    Fri = 5
    Sat = 6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;@unique&lt;/code&gt;装饰器可以帮助我们检查保证没有重复值。&lt;/p&gt;

&lt;p&gt;访问这些枚举类型可以有若干种方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; day1 = Weekday.Mon
&amp;gt;&amp;gt;&amp;gt; print(day1)
Weekday.Mon
&amp;gt;&amp;gt;&amp;gt; print(Weekday.Tue)
Weekday.Tue
&amp;gt;&amp;gt;&amp;gt; print(Weekday[&#39;Tue&#39;])
Weekday.Tue
&amp;gt;&amp;gt;&amp;gt; print(Weekday.Tue.value)
2
&amp;gt;&amp;gt;&amp;gt; print(day1 == Weekday.Mon)
True
&amp;gt;&amp;gt;&amp;gt; print(day1 == Weekday.Tue)
False
&amp;gt;&amp;gt;&amp;gt; print(Weekday(1))
Weekday.Mon
&amp;gt;&amp;gt;&amp;gt; print(day1 == Weekday(1))
True
&amp;gt;&amp;gt;&amp;gt; Weekday(7)
Traceback (most recent call last):
  ...
ValueError: 7 is not a valid Weekday
&amp;gt;&amp;gt;&amp;gt; for name, member in Weekday.__members__.items():
...     print(name, &#39;=&amp;gt;&#39;, member)
...
Sun =&amp;gt; Weekday.Sun
Mon =&amp;gt; Weekday.Mon
Tue =&amp;gt; Weekday.Tue
Wed =&amp;gt; Weekday.Wed
Thu =&amp;gt; Weekday.Thu
Fri =&amp;gt; Weekday.Fri
Sat =&amp;gt; Weekday.Sat
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，既可以用成员名称引用枚举常量，又可以直接根据&lt;code&gt;value&lt;/code&gt;的值获得枚举常量。&lt;/p&gt;

&lt;h1 id=&#34;元类&#34;&gt;元类&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt;类是一切之祖，是 Python 的内建 Metaclass，&lt;code&gt;type()&lt;/code&gt;函数可以查看类型；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type()&lt;/code&gt;函数既可以返回一个对象的类型，又可以创建出新的类型，比如，我们可以通过&lt;code&gt;type()&lt;/code&gt;函数创建出&lt;code&gt;Hello&lt;/code&gt;类，而无需通过&lt;code&gt;class Hello(object)...&lt;/code&gt;的定义：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def fn(self, name=&#39;world&#39;): # 先定义函数
...     print(&#39;Hello, %s.&#39; % name)
...
&amp;gt;&amp;gt;&amp;gt; Hello = type(&#39;Hello&#39;, (object,), dict(hello=fn)) # 创建Hello class
&amp;gt;&amp;gt;&amp;gt; h = Hello()
&amp;gt;&amp;gt;&amp;gt; h.hello()
Hello, world.
&amp;gt;&amp;gt;&amp;gt; print(type(Hello))
&amp;lt;class &#39;type&#39;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; print(type(h))
&amp;lt;class &#39;__main__.Hello&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要创建一个&lt;code&gt;class&lt;/code&gt;对象，&lt;code&gt;type()&lt;/code&gt;函数依次传入 3 个参数：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt;的名称；&lt;/li&gt;
&lt;li&gt;继承的父类集合，注意 Python 支持多重继承，如果只有一个父类，别忘了&lt;code&gt;tuple&lt;/code&gt;的单元素写法；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;class&lt;/code&gt;的方法名称与函数绑定，这里我们把函数&lt;code&gt;fn&lt;/code&gt;绑定到方法名&lt;code&gt;hello&lt;/code&gt;上。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;通过&lt;code&gt;type()&lt;/code&gt;函数创建的类和直接写 class 是完全一样的，因为 Python  解释器遇到 class 定义时，仅仅是扫描一下 class 定义的语法，然后调用&lt;code&gt;type()&lt;/code&gt;函数创建出&lt;code&gt;class&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;正常情况下，我们都用&lt;code&gt;class Xxx...&lt;/code&gt;来定义类，但是，&lt;code&gt;type()&lt;/code&gt;函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;理解&lt;/strong&gt;：教程中关于 Metaclass 的内容不好理解，一是例子本身比较深奥，二是讲解也不到位。但需要注意的是普通的 class 不仅是一个类，而且也是一个 object，这是 Python 的一个非常特殊的概念。而所有 class 的祖先就是 type，但 type 的实现又用了一些特殊的技巧，&lt;code&gt;class&lt;/code&gt;这个关键词实际上就是告诉 Python 在创建一个 class 的时候，也会创建一个对应的 classObject。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;type&lt;/code&gt;就是 Python 的内建元类，当然了，你也可以创建自己的元类。&lt;/p&gt;

&lt;p&gt;除了一些代码中不能理解的东西外，还不好理解的是为什么 ORM 适合用 Metaclass 来实现，这一部分教程写的非常不够。&lt;a href=&#34;https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python&#34; target=&#34;_blank&#34;&gt;https://stackoverflow.com/questions/100003/what-is-a-metaclass-in-python&lt;/a&gt; 的讲解虽然好（&lt;a href=&#34;http://blog.jobbole.com/21351/&#34; target=&#34;_blank&#34;&gt;中文版&lt;/a&gt;），但这一问题仍然感觉不到位。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于教程中的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# metaclass是类的模板，所以必须从`type`类型派生：
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):   // cls 是固定写法，new 阶段还没有 self，也就无法用 self 为参数
        attrs[&#39;add&#39;] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在难以理解的是这里的&lt;code&gt;ListMetaclass&lt;/code&gt;中的&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;bases&lt;/code&gt;究竟是什么。&lt;/p&gt;

&lt;h2 id=&#34;metaclass&#34;&gt;Metaclass&lt;/h2&gt;

&lt;p&gt;除了使用&lt;code&gt;type()&lt;/code&gt;动态创建类以外，要控制类的创建行为，还可以使用&lt;code&gt;Metaclass&lt;/code&gt;。&lt;code&gt;Metaclass&lt;/code&gt;，直译为元类，简单的解释就是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当我们定义了类以后，就可以根据这个类创建出实例，所以：&lt;code&gt;先定义类，然后创建实例&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;但是如果我们想创建出类呢？那就必须根据&lt;code&gt;Metaclass&lt;/code&gt;创建出类，所以：&lt;code&gt;先定义 Metaclass，然后创建类&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;连接起来就是：&lt;code&gt;先定义 Metaclass，就可以创建类，最后创建实例&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所以，Metaclass允许你创建类或者修改类。换句话说，你可以把类看成是 Metaclass 创建出来的实例，也就是前面总结的，普通的类不仅是一个 class，同时还是一个由 Metaclass 而来的 object，。&lt;/p&gt;

&lt;p&gt;Metaclass 是 Python 面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用 Metaclass 的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。&lt;/p&gt;

&lt;p&gt;我们先看一个简单的例子，这个 Metaclass 可以给我们自定义的&lt;code&gt;MyList&lt;/code&gt;增加一个&lt;code&gt;add&lt;/code&gt;方法：&lt;/p&gt;

&lt;p&gt;定义&lt;code&gt;ListMetaclass&lt;/code&gt;，按照默认习惯，Metaclass 的类名总是以 Metaclass 结尾，以便清楚地表示这是一个 Metaclass：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Metaclass 是类的模板，所以必须从`type`类型派生：
class ListMetaclass(type):
    def __new__(cls, name, bases, attrs):
        // new 的时候还没有 object，到 init 时才有，所以不能是 self，只能是 cls
        attrs[&#39;add&#39;] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了&lt;code&gt;ListMetaclass&lt;/code&gt;，我们在定义类的时候还要指示使用&lt;code&gt;ListMetaclass&lt;/code&gt;来定制类，传入关键字参数&lt;code&gt;metaclass&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class MyList(list, metaclass=ListMetaclass):
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们传入关键字参数&lt;code&gt;metaclass&lt;/code&gt;时，魔术就生效了，它指示 Python 解释器在创建&lt;code&gt;MyList&lt;/code&gt;时，要通过&lt;code&gt;ListMetaclass.__new__()&lt;/code&gt;来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;__new__()&lt;/code&gt;方法接收到的参数依次是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;当前准备创建的类的对象；&lt;/li&gt;
&lt;li&gt;类的名字；&lt;/li&gt;
&lt;li&gt;类继承的父类集合；&lt;/li&gt;
&lt;li&gt;类的方法集合。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;测试一下&lt;code&gt;MyList&lt;/code&gt;是否可以调用&lt;code&gt;add()&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = MyList()
&amp;gt;&amp;gt;&amp;gt; L.add(1)
&amp;gt;&amp;gt; L
[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而普通的&lt;code&gt;list&lt;/code&gt;没有&lt;code&gt;add()&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L2 = list()
&amp;gt;&amp;gt;&amp;gt; L2.add(1)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
AttributeError: &#39;list&#39; object has no attribute &#39;add&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;动态修改有什么意义？直接在&lt;code&gt;MyList&lt;/code&gt;定义中写上&lt;code&gt;add()&lt;/code&gt;方法不是更简单吗？正常情况下，确实应该直接写，通过 Metaclass 修改纯属变态。但是，总会遇到需要通过 Metaclass 修改类定义的。ORM 就是一个典型的例子。&lt;/p&gt;

&lt;h2 id=&#34;metaclass-orm-实例&#34;&gt;Metaclass - ORM 实例&lt;/h2&gt;

&lt;p&gt;ORM 全称&lt;code&gt;Object Relational Mapping&lt;/code&gt;，即&lt;code&gt;对象-关系映射&lt;/code&gt;，就是把关系数据库的一行映射为一个对象&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:User&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:User&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，也就是一个类&lt;code&gt;User-Class&lt;/code&gt;对应一个表&lt;code&gt;User-Table&lt;/code&gt;，这样，写代码更简单，不用直接操作 SQL 语句。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;不理解&lt;/strong&gt;：要编写一个 ORM 框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;让我们来尝试编写一个 ORM 框架。&lt;/p&gt;

&lt;p&gt;编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个 ORM 框架，想定义一个&lt;code&gt;User&lt;/code&gt;类来操作对应的数据库表&lt;code&gt;User&lt;/code&gt;，我们期待他写出这样的代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class User(Model):
    # 定义类的属性到列的映射：
    id = IntegerField(&#39;id&#39;)
    name = StringField(&#39;username&#39;)
    email = StringField(&#39;email&#39;)
    password = StringField(&#39;password&#39;)
    // 这部分的语法用于指定 User 的属性，但实际上最终被 Metaclass `pop` 了

# 创建一个实例：
u = User(id=12345, name=&#39;Michael&#39;, email=&#39;test@orm.org&#39;, password=&#39;my-pwd&#39;)
    // User 的 __init__() 可以直接用 Model 的 __init()?
# 保存到数据库：
u.save()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，父类&lt;code&gt;Model&lt;/code&gt;和属性类型&lt;code&gt;StringField&lt;/code&gt;、&lt;code&gt;IntegerField&lt;/code&gt;是由 ORM 框架提供的，剩下的魔术方法比如&lt;code&gt;save()&lt;/code&gt;全部由&lt;code&gt;metaclass&lt;/code&gt;自动完成。虽然&lt;code&gt;metaclass&lt;/code&gt;的编写会比较复杂，但 ORM 的使用者用起来却异常简单。&lt;/p&gt;

&lt;p&gt;现在，我们就按上面的接口来实现该 ORM。&lt;/p&gt;

&lt;p&gt;首先来定义&lt;code&gt;Field&lt;/code&gt;类，它负责保存数据库表的字段名和字段类型：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Field(object):

    def __init__(self, name, column_type):
        self.name = name
        self.column_type = column_type

    def __str__(self):
        return &#39;&amp;lt;%s:%s&amp;gt;&#39; % (self.__class__.__name__, self.name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;Field&lt;/code&gt;的基础上，进一步定义各种类型的&lt;code&gt;Field&lt;/code&gt;，比如&lt;code&gt;StringField&lt;/code&gt;，&lt;code&gt;IntegerField&lt;/code&gt;等等：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class StringField(Field):

    def __init__(self, name):
        super(StringField, self).__init__(name, &#39;varchar(100)&#39;)

class IntegerField(Field):

    def __init__(self, name):
        super(IntegerField, self).__init__(name, &#39;bigint&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下一步，就是编写最复杂的&lt;code&gt;ModelMetaclass&lt;/code&gt;了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class ModelMetaclass(type):

    def __new__(cls, name, bases, attrs):
        # cls 固定；name, bases, attrs 对应为将来准备使用的参数，来自 User，走向新 User
        # 参考《深刻理解Python中的元类(metaclass)》可知是未来的
        if name==&#39;Model&#39;:
            return type.__new__(cls, name, bases, attrs)
        print(&#39;Found model: %s&#39; % name)
        mappings = dict()
        for k, v in attrs.items():
            if isinstance(v, Field):
                print(&#39;Found mapping: %s ==&amp;gt; %s&#39; % (k, v))
                mappings[k] = v
        for k in mappings.keys():
            attrs.pop(k)
        attrs[&#39;__mappings__&#39;] = mappings    # 保存属性和列的映射关系
        attrs[&#39;__table__&#39;] = name           # 假设表名和类名一致
        return type.__new__(cls, name, bases, attrs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以及基类&lt;code&gt;Model&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Model(dict, metaclass=ModelMetaclass):

    def __init__(self, **kw):
        # **kw 在初始化 User 时用到
        super(Model, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&amp;quot;&#39;Model&#39; object has no attribute &#39;%s&#39;&amp;quot; % key)

    def __setattr__(self, key, value):
        self[key] = value

    def save(self):
        fields = []
        params = []
        args = []
        for k, v in self.__mappings__.items():
            fields.append(v.name)
            params.append(&#39;?&#39;)
            args.append(getattr(self, k, None))
        sql = &#39;insert into %s (%s) values (%s)&#39; % (self.__table__, &#39;,&#39;.join(fields), &#39;,&#39;.join(params))
        print(&#39;SQL: %s&#39; % sql)
        print(&#39;ARGS: %s&#39; % str(args))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当用户定义一个&lt;code&gt;class User(Model)&lt;/code&gt;时，Python 解释器首先在当前类&lt;code&gt;User&lt;/code&gt;的定义中查找&lt;code&gt;metaclass&lt;/code&gt;，如果没有找到，就继续在父类&lt;code&gt;Model&lt;/code&gt;中查找&lt;code&gt;metaclass&lt;/code&gt;，找到了，就使用&lt;code&gt;Model&lt;/code&gt;中定义的&lt;code&gt;metaclass&lt;/code&gt;的&lt;code&gt;ModelMetaclass&lt;/code&gt;来创建&lt;code&gt;User&lt;/code&gt;类，也就是说，&lt;code&gt;metaclass&lt;/code&gt;可以隐式地继承到子类，但子类自己却感觉不到。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;ModelMetaclass&lt;/code&gt;中，一共做了几件事情：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;排除掉对&lt;code&gt;Model&lt;/code&gt;类的修改&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:if-name-Model&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:if-name-Model&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;；&lt;/li&gt;
&lt;li&gt;在当前类（比如&lt;code&gt;User&lt;/code&gt;）中查找定义的类的所有属性，如果找到一个&lt;code&gt;Field&lt;/code&gt;属性，就把它保存到一个&lt;code&gt;__mappings__&lt;/code&gt;的&lt;code&gt;dict&lt;/code&gt;中，同时从类属性中删除该&lt;code&gt;Field&lt;/code&gt;属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:-&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:-&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;；&lt;/li&gt;
&lt;li&gt;把表名保存到&lt;code&gt;__table__&lt;/code&gt;中，这里简化为表名默认为类名。&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;Model&lt;/code&gt;类中，就可以定义各种操作数据库的方法，比如&lt;code&gt;save()&lt;/code&gt;，&lt;code&gt;delete()&lt;/code&gt;，&lt;code&gt;find()&lt;/code&gt;，&lt;code&gt;update()&lt;/code&gt;等等。&lt;/li&gt;
&lt;li&gt;我们实现了&lt;code&gt;save()&lt;/code&gt;方法，把一个实例保存到数据库中。因为有表名，属性到字段的映射和属性值的集合，就可以构造出&lt;code&gt;INSERT&lt;/code&gt;语句。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;编写代码试试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;u = User(id=12345, name=&#39;Michael&#39;, email=&#39;test@orm.org&#39;, password=&#39;my-pwd&#39;)
u.save()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Found model: User
Found mapping: email ==&amp;gt; &amp;lt;StringField:email&amp;gt;
Found mapping: password ==&amp;gt; &amp;lt;StringField:password&amp;gt;
Found mapping: id ==&amp;gt; &amp;lt;IntegerField:uid&amp;gt;
Found mapping: name ==&amp;gt; &amp;lt;StringField:username&amp;gt;
SQL: insert into User (password,email,username,id) values (?,?,?,?)
ARGS: [&#39;my-pwd&#39;, &#39;test@orm.org&#39;, &#39;Michael&#39;, 12345]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，&lt;code&gt;save()&lt;/code&gt;方法已经打印出了可执行的 SQL 语句，以及参数列表，只需要真正连接到数据库，执行该 SQL 语句，就可以完成真正的功能。&lt;/p&gt;

&lt;p&gt;不到 100 行代码，我们就通过&lt;code&gt;metaclass&lt;/code&gt;实现了一个精简的 ORM 框架。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:Python-MixIn-Jav&#34;&gt;由于 Python 允许使用多重继承，因此，MixIn 就是一种常见的设计。只允许单一继承的语言（如 Java）不能使用 MixIn 的设计。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:Python-MixIn-Jav&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:User&#34;&gt;这里对应&lt;code&gt;User&lt;/code&gt;。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:User&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:if-name-Model&#34;&gt;这个对应于&lt;code&gt;if name==&#39;Model&#39;&lt;/code&gt;，但不明白含义。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:if-name-Model&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:-&#34;&gt;没有彻底的理解。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:-&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>《廖雪峰 Python 教程》笔记 6：调试</title>
      <link>/tech/2017/06/18/python-debug/</link>
      <pubDate>Sun, 18 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/06/18/python-debug/</guid>
      <description>
        

&lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431915578556ad30ab3933ae4e82a03ee2e9a4f70871000&#34; target=&#34;_blank&#34;&gt;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431915578556ad30ab3933ae4e82a03ee2e9a4f70871000&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;程序能一次写完并正常运行的概率很小，基本不超过 1%。总会有各种各样的 bug 需要修正。有的 bug 很简单，看看错误信息就知道，有的 bug 很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复 bug。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;print&#34;&gt;&lt;code&gt;print()&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;第一种方法简单直接粗暴有效，就是用&lt;code&gt;print()&lt;/code&gt;把可能有问题的变量打印出来看看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def foo(s):
    n = int(s)
    print(&#39;&amp;gt;&amp;gt;&amp;gt; n = %d&#39; % n)
    return 10 / n

def main():
    foo(&#39;0&#39;)

main()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行后在输出中查找打印的变量值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python3 err.py
&amp;gt;&amp;gt;&amp;gt; n = 0
Traceback (most recent call last):
  ...
ZeroDivisionError: integer division or modulo by zero
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用&lt;code&gt;print()&lt;/code&gt;最大的坏处是将来还得删掉它，想想程序里到处都是&lt;code&gt;print()&lt;/code&gt;，运行结果也会包含很多垃圾信息。所以，我们又有第二种方法。&lt;/p&gt;

&lt;h1 id=&#34;断言&#34;&gt;断言&lt;/h1&gt;

&lt;p&gt;凡是用&lt;code&gt;print()&lt;/code&gt;来辅助查看的地方，都可以用断言（assert）来替代：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def foo(s):
    n = int(s)
    assert n != 0, &#39;n is zero!&#39;
    return 10 / n

def main():
    foo(&#39;0&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;assert&lt;/code&gt;的意思是，表达式&lt;code&gt;n != 0&lt;/code&gt;应该是&lt;code&gt;True&lt;/code&gt;，否则，根据程序运行的逻辑，后面的代码肯定会出错。&lt;/p&gt;

&lt;p&gt;如果断言失败，&lt;code&gt;assert&lt;/code&gt;语句本身就会抛出&lt;code&gt;AssertionError&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python3 err.py
Traceback (most recent call last):
  ...
AssertionError: n is zero!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;程序中如果到处充斥着&lt;code&gt;assert&lt;/code&gt;，和&lt;code&gt;print()&lt;/code&gt;相比也好不到哪去。不过，启动 Python 解释器时可以用&lt;code&gt;-O&lt;/code&gt;参数来关闭&lt;code&gt;assert&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python3 -O err.py
Traceback (most recent call last):
  ...
ZeroDivisionError: division by zero
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭后，你可以把所有的&lt;code&gt;assert&lt;/code&gt;语句当成&lt;code&gt;pass&lt;/code&gt;来看。&lt;/p&gt;

&lt;h1 id=&#34;logging&#34;&gt;&lt;code&gt;logging&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;把&lt;code&gt;print()&lt;/code&gt;替换为&lt;code&gt;logging&lt;/code&gt;是第 3 种方式，和&lt;code&gt;assert&lt;/code&gt;比，&lt;code&gt;logging&lt;/code&gt;不会抛出错误，而且可以输出到文件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import logging

s = &#39;0&#39;
n = int(s)
logging.info(&#39;n = %d&#39; % n)
print(10 / n)
logging.info()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以输出一段文本。运行，发现除了&lt;code&gt;ZeroDivisionError&lt;/code&gt;，没有任何信息。怎么回事？&lt;/p&gt;

&lt;p&gt;别急，在&lt;code&gt;import logging&lt;/code&gt;之后添加一行配置再试试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import logging
logging.basicConfig(level=logging.INFO)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到输出了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python3 err.py
INFO:root:n = 0
Traceback (most recent call last):
  File &amp;quot;err.py&amp;quot;, line 8, in &amp;lt;module&amp;gt;
    print(10 / n)
ZeroDivisionError: division by zero
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是&lt;code&gt;logging&lt;/code&gt;的好处，它允许你指定记录信息的级别，有&lt;code&gt;debug&lt;/code&gt;，&lt;code&gt;info&lt;/code&gt;，&lt;code&gt;warning&lt;/code&gt;，&lt;code&gt;error&lt;/code&gt;等几个级别，当我们指定&lt;code&gt;level=INFO&lt;/code&gt;时，&lt;code&gt;logging.debug&lt;/code&gt;就不起作用了。同理，指定&lt;code&gt;level=WARNING&lt;/code&gt;后，&lt;code&gt;debug&lt;/code&gt;和&lt;code&gt;info&lt;/code&gt;就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;logging&lt;/code&gt;的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如&lt;code&gt;console&lt;/code&gt;和文件。&lt;/p&gt;

&lt;h1 id=&#34;pdb&#34;&gt;pdb&lt;/h1&gt;

&lt;p&gt;第 4 种方式是启动 Python 的调试器&lt;code&gt;pdb&lt;/code&gt;，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# err.py
s = &#39;0&#39;
n = int(s)
print(10 / n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后启动：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python3 -m pdb err.py
&amp;gt; /Users/michael/Github/learn-python3/samples/debug/err.py(2)&amp;lt;module&amp;gt;()
-&amp;gt; s = &#39;0&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以参数&lt;code&gt;-m pdb&lt;/code&gt;启动后，&lt;code&gt;pdb&lt;/code&gt;定位到下一步要执行的代码&lt;code&gt;-&amp;gt; s = &#39;0&#39;&lt;/code&gt;。输入命令&lt;code&gt;l&lt;/code&gt;来查看代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Pdb) l
  1     # err.py
  2  -&amp;gt; s = &#39;0&#39;
  3     n = int(s)
  4     print(10 / n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入命令&lt;code&gt;n&lt;/code&gt;可以单步执行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Pdb) n
&amp;gt; /Users/michael/Github/learn-python3/samples/debug/err.py(3)&amp;lt;module&amp;gt;()
-&amp;gt; n = int(s)
(Pdb) n
&amp;gt; /Users/michael/Github/learn-python3/samples/debug/err.py(4)&amp;lt;module&amp;gt;()
-&amp;gt; print(10 / n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;任何时候都可以输入命令&lt;code&gt;p 变量名&lt;/code&gt;来查看变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Pdb) p s
&#39;0&#39;
(Pdb) p n
0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输入命令&lt;code&gt;q&lt;/code&gt;结束调试，退出程序：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(Pdb) q
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种通过&lt;code&gt;pdb&lt;/code&gt;在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第 999 行得敲多少命令啊。还好，我们还有另一种调试方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pdb.set_trace()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方法也是用&lt;code&gt;pdb&lt;/code&gt;，但是不需要单步执行，我们只需要&lt;code&gt;import pdb&lt;/code&gt;，然后，在可能出错的地方放一个&lt;code&gt;pdb.set_trace()&lt;/code&gt;，就可以设置一个断点：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# err.py
import pdb

s = &#39;0&#39;
n = int(s)
pdb.set_trace() # 运行到这里会自动暂停
print(10 / n)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行代码，程序会自动在&lt;code&gt;pdb.set_trace()&lt;/code&gt;暂停并进入&lt;code&gt;pdb&lt;/code&gt;调试环境，可以用命令&lt;code&gt;p&lt;/code&gt;查看变量，或者用命令&lt;code&gt;c&lt;/code&gt;继续运行：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ python3 err.py 
&amp;gt; /Users/michael/Github/learn-python3/samples/debug/err.py(7)&amp;lt;module&amp;gt;()
-&amp;gt; print(10 / n)
(Pdb) p n
0
(Pdb) c
Traceback (most recent call last):
  File &amp;quot;err.py&amp;quot;, line 7, in &amp;lt;module&amp;gt;
    print(10 / n)
ZeroDivisionError: division by zero
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个方式比直接启动&lt;code&gt;pdb&lt;/code&gt;单步调试效率要高很多，但也高不到哪去。&lt;/p&gt;

&lt;h1 id=&#34;ide&#34;&gt;IDE&lt;/h1&gt;

&lt;p&gt;如果要比较爽地设置断点、单步执行，就需要一个支持调试功能的 IDE。目前比较好的 Python IDE 有 PyCharm：&lt;a href=&#34;http://www.jetbrains.com/pycharm/&#34; target=&#34;_blank&#34;&gt;http://www.jetbrains.com/pycharm/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;另外，&lt;a href=&#34;http://eclipse.org/&#34; target=&#34;_blank&#34;&gt;Eclipse&lt;/a&gt; 加上&lt;a href=&#34;http://pydev.org/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;pydev&lt;/code&gt;&lt;/a&gt;插件也可以调试 Python 程序。&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>不动点定理</title>
      <link>/prof/2017/06/18/fixed-point/</link>
      <pubDate>Sun, 18 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/prof/2017/06/18/fixed-point/</guid>
      <description>
        &lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;：《经济数学方法与模型》, by de la Fuente, p191&lt;/p&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;简介&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Brouwer (&lt;strong&gt;布劳维尔&lt;/strong&gt;)不动点定理给出的是函数存在不动点的充分条件；&lt;/li&gt;
&lt;li&gt;Kakutani (&lt;strong&gt;角谷静夫&lt;/strong&gt;)不动点定理给出的是有限维空间中对应存在不动点的充分条件；&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;不动点定理&lt;/h1&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;压缩映射原理&lt;/strong&gt;(Émile Picard(1890)；Stefan Banach(1922))：设&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;是一个完备的度量空间，映射&lt;span class=&#34;math inline&#34;&gt;\(f:X\to X\)&lt;/span&gt; 把每两点的距离至少压缩&lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt;倍，即&lt;span class=&#34;math inline&#34;&gt;\(\mathrm{d}(f(x), f(y))\leqslant\lambda\mathrm{d}(x,y)\)&lt;/span&gt;，这里&lt;span class=&#34;math inline&#34;&gt;\(\lambda\)&lt;/span&gt;是一个小于&lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;的常数，那么&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;必有而且只有一个不动点，而且从&lt;span class=&#34;math inline&#34;&gt;\(Χ\)&lt;/span&gt;的任何点&lt;span class=&#34;math inline&#34;&gt;\(x_0\)&lt;/span&gt;出发作出序列&lt;span class=&#34;math inline&#34;&gt;\(x_1=f(x_0),x_2=f(x_1),\dotsc,x_n=f(x_{n-1}),\dotsc\)&lt;/span&gt;，这序列一定收敛到那个不动点。这条定理是许多种方程的解的存在性、惟一性及迭代解法的理论基础。由于分析学的需要，这定理已被推广到非扩展映射、概率度量空间、映射族、集值映射等许多方面。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Brouwer 不动点定理&lt;/strong&gt;(1910): 设&lt;span class=&#34;math inline&#34;&gt;\(Χ\)&lt;/span&gt;是欧氏空间中的紧凸集，那么&lt;span class=&#34;math inline&#34;&gt;\(Χ\)&lt;/span&gt;到自身的每个连续映射都至少有一个不动点。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用这定理可以证明&lt;strong&gt;代数基本定理&lt;/strong&gt;：复系数的代数方程一定有复数解。把布劳威尔定理中的欧氏空间换成巴拿赫空间，就是&lt;strong&gt;绍德尔不动点定理&lt;/strong&gt;(1930)，常用于偏微分方程理论。这些定理可以从单值映射推广到集值映射，除微分方程理论外还常用于对策论和数理经济学。&lt;/p&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;strong&gt;Kakutani 不动点定理&lt;/strong&gt;: 设&lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt;是&lt;span class=&#34;math inline&#34;&gt;\(\mathbb{R}^n\)&lt;/span&gt;中的紧凸集，&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;为从&lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt;到&lt;span class=&#34;math inline&#34;&gt;\(C\)&lt;/span&gt;的非空凸子集的上半连续的点—集映射，则至少存在一点&lt;span class=&#34;math inline&#34;&gt;\(x^\ast\)&lt;/span&gt;, 使得&lt;span class=&#34;math inline&#34;&gt;\(x^\ast\in f(x^\ast)\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;1941 年，Kakutani 把 Brouwer 不动点定理推广到有限维空间中多值映射的情形。不动点的个数有两种数法。代数上通常说&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;次复多项式有&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;个复根，是把一个&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;重根算作&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;个根的。如果不把重数统计在内，根的个数就可以小于&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;。推广&lt;strong&gt;根的重数&lt;/strong&gt;概念，可以定义不动点的指数，它是一个整数，可正可负可零，取决于映射在不动点附近的局部几何性质。一个映射的所有不动点的指数的总和，称为这映射的&lt;strong&gt;不动点代数个数&lt;/strong&gt;，以别于不动点的实际个数。&lt;/p&gt;
&lt;ol start=&#34;4&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;strong&gt;莱夫谢茨不动点定理&lt;/strong&gt;：设&lt;span class=&#34;math inline&#34;&gt;\(Χ\)&lt;/span&gt;是紧多面体，&lt;span class=&#34;math inline&#34;&gt;\(f:Χ\to Χ\)&lt;/span&gt;是映射，那么&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;的不动点代数个数等于&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;的莱夫谢茨数&lt;span class=&#34;math inline&#34;&gt;\(L(f)\)&lt;/span&gt;，它是一个容易计算的同伦不变量，可以利用同调群以简单的公式写出。当&lt;span class=&#34;math inline&#34;&gt;\(L(f)\neq 0\)&lt;/span&gt;时，与&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;同伦的每个映射都至少有一个不动点。这个定理既发展了布劳威尔定理，也发展了关于向量场奇点指数和等于流形的欧拉数的&lt;strong&gt;庞加莱－霍普夫定理&lt;/strong&gt;，把它进一步推广到泛函空间而得的&lt;strong&gt;勒雷－绍德尔参数延拓原理&lt;/strong&gt;，早已成为偏微分方程理论的标准的工具。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;J.尼尔斯 1927 年发现，一个映射&lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;的全体不动点可以自然地分成若干个不动点类，每类中诸不动点的指数和都是同伦不变量。指数和不为&lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;的不动点类的个数，称为这映射的&lt;strong&gt;尼尔斯数&lt;/strong&gt;&lt;span class=&#34;math inline&#34;&gt;\(N(f)\)&lt;/span&gt;。只要&lt;span class=&#34;math inline&#34;&gt;\(Χ\)&lt;/span&gt;是维数大于&lt;span class=&#34;math inline&#34;&gt;\(2\)&lt;/span&gt;的流形，&lt;span class=&#34;math inline&#34;&gt;\(N(f)\)&lt;/span&gt;恰是与 &lt;span class=&#34;math inline&#34;&gt;\(f\)&lt;/span&gt;同伦的映射的最少不动点数。这就提供了研究方程的解的实际个数（而不只是代数个数）的一种方法。&lt;/p&gt;
&lt;p&gt;莱夫谢茨定理的一个重要发展是关于微分流形上椭圆型算子与椭圆型复形的&lt;strong&gt;阿蒂亚－辛格指标定理&lt;/strong&gt;与&lt;strong&gt;阿蒂亚-博特不动点定理&lt;/strong&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;参考文献&lt;/h1&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;江泽涵，《不动点类理论》，科学出版社，北京，1979。&lt;/li&gt;
&lt;li&gt;V. I. Istratescu. Fixed Point Theory (An Introduction)[M]. Reidel, 1981.&lt;/li&gt;
&lt;li&gt;B.Jiang,Lectures on Nielsen Fixed Point Theory,Amer. Math. Soc., Providence, 1983.&lt;/li&gt;
&lt;li&gt;M.J.Todd,The Computation of Fixed Points and Applications, Springer-Verlag, New York, 1976.&lt;/li&gt;
&lt;li&gt;L. E. J. Brouwer. Beweis der Invarianz der Dimensionenzahl[J]. Math. Ann., 1911, (70): 161–165.&lt;/li&gt;
&lt;li&gt;S. Kakutani. A Generalization of Brouwer Fixed Point Theorem[J]. Duke Math. J., 1941, (8): 457–459.&lt;/li&gt;
&lt;li&gt;熊金城. 点集拓扑讲义(第三版)[M]. 高等教育出版社, 2003.&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Picard%E2%80%93Lindel%C3%B6f_theorem&#34;&gt;Picard–Lindelöf theorem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Banach_fixed-point_theorem&#34;&gt;Banach fixed-point theorem&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zhidao.baidu.com/question/1671784868029411107.html&#34; class=&#34;uri&#34;&gt;https://zhidao.baidu.com/question/1671784868029411107.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>算子 (Operator)</title>
      <link>/prof/2017/06/18/operator/</link>
      <pubDate>Sun, 18 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/prof/2017/06/18/operator/</guid>
      <description>
        &lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;：《经济数学方法与模型》, by de la Fuente, p119&lt;/p&gt;
&lt;p&gt;从&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;到&lt;span class=&#34;math inline&#34;&gt;\(X\)&lt;/span&gt;自身的映射称为&lt;strong&gt;算子&lt;/strong&gt;(Operator)。&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>《廖雪峰 Python 教程》笔记 4：面向对象编程1</title>
      <link>/tech/2017/06/17/python-class/</link>
      <pubDate>Sat, 17 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/06/17/python-class/</guid>
      <description>
        

&lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318645694388f1f10473d7f416e9291616be8367ab5000&#34; target=&#34;_blank&#34;&gt;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318645694388f1f10473d7f416e9291616be8367ab5000&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class 是一种抽象概念，比如我们定义的 Class——Student，是指学生这个概念，而实例（Instance）则是一个个具体的 Student，比如，Bart Simpson 和Lisa Simpson 是两个具体的 Student。所以，面向对象的设计思想是抽象出 Class，根据 Class 创建 Instance。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;面向对象的抽象程度又比函数要高，因为一个 Class 既包含数据，又包含操作数据的方法。&lt;/p&gt;

&lt;h1 id=&#34;简单示例&#34;&gt;简单示例&lt;/h1&gt;

&lt;h2 id=&#34;面向函数&#34;&gt;面向函数&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;std1 = { &#39;name&#39;: &#39;Michael&#39;, &#39;score&#39;: 98 }
std2 = { &#39;name&#39;: &#39;Bob&#39;, &#39;score&#39;: 81 }

def print_score(std):
    print(&#39;%s: %s&#39; % (std[&#39;name&#39;], std[&#39;score&#39;]))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;面向对象&#34;&gt;面向对象&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score

    def print_score(self):
        print(&#39;%s: %s&#39; % (self.name, self.score))

bart = Student(&#39;Bart Simpson&#39;, 59)
lisa = Student(&#39;Lisa Simpson&#39;, 87)
bart.print_score()
lisa.print_score()
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;类和实例&#34;&gt;类和实例&lt;/h1&gt;

&lt;p&gt;一般模块文件名称小写，类的名称首字母大写，在新式类的定义中，需要明确指定是继承自哪个父类。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):
    pass

&amp;gt;&amp;gt;&amp;gt; bart = Student()
&amp;gt;&amp;gt;&amp;gt; bart
&amp;lt;__main__.Student object at 0x10a67a590&amp;gt;
&amp;gt;&amp;gt;&amp;gt; Student
&amp;lt;class &#39;__main__.Student&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类的实例——对象可以自由添加新的属性&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:-&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:-&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; bart.name = &#39;Bart Simpson&#39;
&amp;gt;&amp;gt;&amp;gt; bart.name
&#39;Bart Simpson&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;init&#34;&gt;__init__()&lt;/h2&gt;

&lt;p&gt;类可以起到模板的作用，因此，可以在初始化实例的时候&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:new-init&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:new-init&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的&lt;code&gt;__init__()&lt;/code&gt;方法，在初始化实例的时候，就把&lt;code&gt;name&lt;/code&gt;，&lt;code&gt;score&lt;/code&gt;等属性绑上去：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):

    def __init__(self, name, score):
        self.name = name
        self.score = score
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;code&gt;__init__()&lt;/code&gt;方法的第一个参数永远是&lt;code&gt;self&lt;/code&gt;，表示创建的实例本身，因此，在&lt;code&gt;__init__()&lt;/code&gt;方法内部，就可以把各种属性绑定到&lt;code&gt;self&lt;/code&gt;，因为&lt;code&gt;self&lt;/code&gt;就指向创建的实例本身。有了&lt;code&gt;__init__()&lt;/code&gt;方法，在创建实例的时候，就不能&lt;del&gt;&lt;code&gt;传入空的参数&lt;/code&gt;&lt;/del&gt;了，必须传入与&lt;code&gt;__init__()&lt;/code&gt;方法匹配的参数，但&lt;code&gt;self&lt;/code&gt;不需要传，Python 解释器自己会把实例变量传进去：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; bart = Student(&#39;Bart Simpson&#39;, 59)
&amp;gt;&amp;gt;&amp;gt; bart.name
&#39;Bart Simpson&#39;
&amp;gt;&amp;gt;&amp;gt; bart.score
59
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量&lt;code&gt;self&lt;/code&gt;，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。&lt;/p&gt;

&lt;h2 id=&#34;访问限制&#34;&gt;访问限制&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__name&lt;/code&gt;式的成员是私有成员，不能外部访问，当然，也可以用&lt;code&gt;._Class__name&lt;/code&gt;的方式强制访问；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_name&lt;/code&gt;式的成员可以外部访问，但习惯上认为没应该从外部访问；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__name__&lt;/code&gt;式的可以外部访问，但一般有特殊含义，不建议自己定义的成员使用；&lt;/li&gt;
&lt;li&gt;私有成员考虑实现&lt;code&gt;get(), set()&lt;/code&gt;方法来进行访问，这样可以增加访问限制，从而避免无效参数设定；&lt;/li&gt;
&lt;li&gt;不要给类实例增加&lt;code&gt;__name&lt;/code&gt;这样的属性，这个名称与实际上内部私有成员的属性名&lt;code&gt;._Class__name&lt;/code&gt;并不相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;公有-私有成员&#34;&gt;公有、私有成员&lt;/h3&gt;

&lt;p&gt;如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线&lt;code&gt;__&lt;/code&gt;，在 Python 中，实例的变量名如果以&lt;code&gt;__&lt;/code&gt;开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把&lt;code&gt;Student&lt;/code&gt;类改一改：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):

    def __init__(self, name, score):
        self.__name = name
        self.__score = score

    def print_score(self):
        print(&#39;%s: %s&#39; % (self.__name, self.__score))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量&lt;code&gt;.__name&lt;/code&gt;和实例变量&lt;code&gt;.__score&lt;/code&gt;了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; bart = Student(&#39;Bart Simpson&#39;, 98)
&amp;gt;&amp;gt;&amp;gt; bart.__name
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
AttributeError: &#39;Student&#39; object has no attribute &#39;__name&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就确保了外部代码不能随意修改对象内部的状态，这样通过访问限制的保护，代码更加健壮。&lt;/p&gt;

&lt;h3 id=&#34;get-set&#34;&gt;get(), set()&lt;/h3&gt;

&lt;p&gt;但是如果外部代码要获取&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;score&lt;/code&gt;怎么办？可以给&lt;code&gt;Student&lt;/code&gt;类增加&lt;code&gt;get_name()&lt;/code&gt;和&lt;code&gt;get_score()&lt;/code&gt;这样的方法&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:getattr-setattr&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:getattr-setattr&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):
    ...

    def get_name(self):
        return self.__name

    def get_score(self):
        return self.__score
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果又要允许外部代码修改&lt;code&gt;score&lt;/code&gt;怎么办？可以再给&lt;code&gt;Student&lt;/code&gt;类增加&lt;code&gt;set_score()&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):
    ...

    def set_score(self, score):
        self.__score = score
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你也许会问，原先那种直接通过&lt;code&gt;bart.score = 59&lt;/code&gt;也可以修改啊，为什么要定义一个方法大费周折？因为在方法中，可以对参数做检查，避免传入无效的参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Student(object):
    ...

    def set_score(self, score):
        if 0 &amp;lt;= score &amp;lt;= 100:
            self.__score = score
        else:
            raise ValueError(&#39;bad score&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;强行访问&#34;&gt;强行访问&lt;/h3&gt;

&lt;p&gt;需要注意的是，在 Python 中，变量名类似&lt;code&gt;__xxx__&lt;/code&gt;的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是 private 变量，所以，不能用&lt;code&gt;__name__()&lt;/code&gt;、&lt;code&gt;__score__()&lt;/code&gt;这样的变量名。&lt;/p&gt;

&lt;p&gt;有些时候，你会看到以一个下划线开头的实例变量名，比如&lt;code&gt;_name&lt;/code&gt;，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。&lt;/p&gt;

&lt;p&gt;双下划线开头的实例变量是不是一定不能从外部访问呢？其实也不是。不能直接访问&lt;code&gt;__name&lt;/code&gt;是因为 Python 解释器对外把&lt;code&gt;__name&lt;/code&gt;变量改成了&lt;code&gt;_Student__name&lt;/code&gt;，所以，仍然可以通过&lt;code&gt;_Student__name&lt;/code&gt;来访问&lt;code&gt;__name&lt;/code&gt;变量：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; bart._Student__name
&#39;Bart Simpson&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是强烈建议你不要这么干，因为不同版本的 Python 解释器可能会把&lt;code&gt;__name&lt;/code&gt;改成不同的变量名。总的来说就是，Python 本身没有任何机制阻止你干坏事，一切全靠自觉。&lt;/p&gt;

&lt;p&gt;最后注意下面的这种错误写法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; bart = Student(&#39;Bart Simpson&#39;, 98)
&amp;gt;&amp;gt;&amp;gt; bart.get_name()
&#39;Bart Simpson&#39;
&amp;gt;&amp;gt;&amp;gt; bart.__name = &#39;New Name&#39; # 设置__name变量！
&amp;gt;&amp;gt;&amp;gt; bart.__name
&#39;New Name&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;表面上看，外部代码“成功”地设置了&lt;code&gt;__name&lt;/code&gt;变量，但实际上这个&lt;code&gt;__name&lt;/code&gt;变量和 class 内部的&lt;code&gt;__name&lt;/code&gt;变量不是一个变量！内部的&lt;code&gt;__name&lt;/code&gt;变量已经被 Python 解释器自动改成了&lt;code&gt;_Student__name&lt;/code&gt;，而外部代码给&lt;code&gt;bart&lt;/code&gt;新增了一个&lt;code&gt;__name&lt;/code&gt;变量。不信试试：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; bart.get_name()         # get_name()内部返回self.__name
&#39;Bart Simpson&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;继承和多态&#34;&gt;继承和多态&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;有什么好处？最大的好处是子类获得了父类的全部功能。由于&lt;code&gt;Animial&lt;/code&gt;实现了&lt;code&gt;run()&lt;/code&gt;方法，因此，&lt;code&gt;Dog&lt;/code&gt;和&lt;code&gt;Cat&lt;/code&gt;作为它的子类，什么事也没干，就自动拥有了&lt;code&gt;run()&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;当子类和父类都存在相同的&lt;code&gt;run()&lt;/code&gt;方法时，我们说，子类的&lt;code&gt;run()&lt;/code&gt;覆盖了父类的&lt;code&gt;run()&lt;/code&gt;，在代码运行的时候，总是会调用子类的&lt;code&gt;run()&lt;/code&gt;。这样，我们就获得了继承的另一个好处：&lt;strong&gt;多态&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;对于下面的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def run_twice(animal):
    animal.run()
    animal.run()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;新增一个&lt;code&gt;Animal&lt;/code&gt;的子类，不必对&lt;code&gt;run_twice()&lt;/code&gt;做任何修改，实际上，任何依赖&lt;code&gt;Animal&lt;/code&gt;作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。&lt;/p&gt;

&lt;p&gt;多态的好处就是，当我们需要传入&lt;code&gt;Dog&lt;/code&gt;、&lt;code&gt;Cat&lt;/code&gt;、&lt;code&gt;Tortoise&lt;/code&gt;……时，我们只需要接收&lt;code&gt;Animal&lt;/code&gt;类型就可以了，因为&lt;code&gt;Dog&lt;/code&gt;、&lt;code&gt;Cat&lt;/code&gt;、&lt;code&gt;Tortoise&lt;/code&gt;……都是&lt;code&gt;Animal&lt;/code&gt;类型，然后，按照&lt;code&gt;Animal&lt;/code&gt;类型进行操作即可。由于&lt;code&gt;Animal&lt;/code&gt;类型有&lt;code&gt;run()&lt;/code&gt;方法，因此，传入的任意类型，只要是&lt;code&gt;Animal&lt;/code&gt;类或者子类，就会自动调用实际类型的&lt;code&gt;run()&lt;/code&gt;方法，这就是多态的意思：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;对于一个变量，我们只需要知道它是&lt;code&gt;Animal&lt;/code&gt;类型，无需确切地知道它的子类型，就可以放心地调用&lt;code&gt;run()&lt;/code&gt;方法，而具体调用的&lt;code&gt;run()&lt;/code&gt;方法是作用在&lt;code&gt;Animal&lt;/code&gt;、&lt;code&gt;Dog&lt;/code&gt;、&lt;code&gt;Cat&lt;/code&gt;还是&lt;code&gt;Tortoise&lt;/code&gt;对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：调用方只管调用，不管细节，而当我们新增一种&lt;code&gt;Animal&lt;/code&gt;的子类时，只要确保&lt;code&gt;run()&lt;/code&gt;方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;对扩展开放：允许新增&lt;code&gt;Animal&lt;/code&gt;子类；&lt;/li&gt;
&lt;li&gt;对修改封闭：不需要修改依赖&lt;code&gt;Animal&lt;/code&gt;类型的&lt;code&gt;run_twice()&lt;/code&gt;等函数。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;静态语言-vs-动态语言&#34;&gt;静态语言 vs 动态语言&lt;/h2&gt;

&lt;p&gt;对于静态语言（例如 Java）来说，如果需要传入&lt;code&gt;Animal&lt;/code&gt;类型，则传入的对象必须是&lt;code&gt;Animal&lt;/code&gt;类型或者它的子类，否则，将无法调用&lt;code&gt;run()&lt;/code&gt;方法。&lt;/p&gt;

&lt;p&gt;对于 Python 这样的动态语言来说，则不一定需要传入&lt;code&gt;Animal&lt;/code&gt;类型。我们只需要保证传入的对象有一个&lt;code&gt;run()&lt;/code&gt;方法就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Timer(object):
    def run(self):
        print(&#39;Start...&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这就是动态语言的&lt;strong&gt;鸭子类型&lt;/strong&gt;，它并不要求严格的继承体系，一个对象只要&lt;code&gt;看起来像鸭子，走起路来像鸭子&lt;/code&gt;，那它就可以被看做是鸭子。&lt;/p&gt;

&lt;p&gt;Python 的&lt;code&gt;file-like object&lt;/code&gt;就是一种鸭子类型。对真正的文件对象，它有一个&lt;code&gt;read()&lt;/code&gt;方法，返回其内容。但是，许多对象，只要有&lt;code&gt;read()&lt;/code&gt;方法，都被视为&lt;code&gt;file-like object&lt;/code&gt;。许多函数接收的参数就是&lt;code&gt;file-like object&lt;/code&gt;，你不一定要传入真正的文件对象，完全可以传入任何实现了&lt;code&gt;read()&lt;/code&gt;方法的对象。&lt;/p&gt;

&lt;h2 id=&#34;获取对象信息&#34;&gt;获取对象信息&lt;/h2&gt;

&lt;h3 id=&#34;type-判断对象类型&#34;&gt;type() - 判断对象类型&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; type(123)==type(456)
True
&amp;gt;&amp;gt;&amp;gt; type(123)==int
True
&amp;gt;&amp;gt;&amp;gt; type(&#39;abc&#39;)==type(&#39;123&#39;)
True
&amp;gt;&amp;gt;&amp;gt; type(&#39;abc&#39;)==str
True
&amp;gt;&amp;gt;&amp;gt; type(&#39;abc&#39;)==type(123)
False

&amp;gt;&amp;gt;&amp;gt; import types
&amp;gt;&amp;gt;&amp;gt; def fn():
...     pass
...
&amp;gt;&amp;gt;&amp;gt; type(fn)==types.FunctionType
True
&amp;gt;&amp;gt;&amp;gt; type(abs)==types.BuiltinFunctionType
True
&amp;gt;&amp;gt;&amp;gt; type(lambda x: x)==types.LambdaType
True
&amp;gt;&amp;gt;&amp;gt; type((x for x in range(10)))==types.GeneratorType
True
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;isinstance-有继承关系时比-type-好用&#34;&gt;isinstance() - 有继承关系时比 type() 好用&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(h, Husky)
True

&amp;gt;&amp;gt;&amp;gt; isinstance(h, Dog)
True

&amp;gt;&amp;gt;&amp;gt; isinstance(d, Dog) and isinstance(d, Animal)
True

&amp;gt;&amp;gt;&amp;gt; isinstance(d, Husky)
False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;能用&lt;code&gt;type()&lt;/code&gt;判断的基本类型也可以用&lt;code&gt;isinstance()&lt;/code&gt;判断：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(&#39;a&#39;, str)
True
&amp;gt;&amp;gt;&amp;gt; isinstance(123, int)
True
&amp;gt;&amp;gt;&amp;gt; isinstance(b&#39;a&#39;, bytes)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;并且还可以判断一个变量是否是某些类型中的一种，比如下面的代码就可以判断是否是&lt;code&gt;list&lt;/code&gt;或者&lt;code&gt;tuple&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; isinstance([1, 2, 3], (list, tuple))
True
&amp;gt;&amp;gt;&amp;gt; isinstance((1, 2, 3), (list, tuple))
True
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;dir-获得对象的所有属性和方法&#34;&gt;dir() - 获得对象的所有属性和方法&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;dir(&#39;ABC&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似&lt;code&gt;__xxx__&lt;/code&gt;的属性和方法在 Python 中都是有特殊用途的，剩下的都是普通属性或方法。&lt;/p&gt;

&lt;h3 id=&#34;getattr-setattr-hasattr&#34;&gt;getattr()、setattr()、hasattr()&lt;/h3&gt;

&lt;p&gt;注意这里的&lt;code&gt;getattr()&lt;/code&gt;和&lt;code&gt;setattr()&lt;/code&gt;与前面的&lt;code&gt;get_name()&lt;/code&gt;和&lt;code&gt;set_name()&lt;/code&gt;不同，这里的两个方法是针对全体类的一个通过实现，而前面的两个方法是程序作者根据需要自己定义的方法，作者通常会在其中添加自己的更多额外工作，如数据有效验证等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;x&#39;) # 有属性&#39;x&#39;吗？
True
&amp;gt;&amp;gt;&amp;gt; obj.x
9
&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？
False
&amp;gt;&amp;gt;&amp;gt; setattr(obj, &#39;y&#39;, 19) # 设置一个属性&#39;y&#39;
&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;y&#39;) # 有属性&#39;y&#39;吗？
True
&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;y&#39;) # 获取属性&#39;y&#39;
19
&amp;gt;&amp;gt;&amp;gt; obj.y # 获取属性&#39;y&#39;
19
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果试图获取不存在的属性，会抛出&lt;code&gt;AttributeError&lt;/code&gt;的错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;z&#39;) # 获取属性&#39;z&#39;
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
AttributeError: &#39;MyObject&#39; object has no attribute &#39;z&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以传入一个&lt;code&gt;default&lt;/code&gt;参数，如果属性不存在，就返回默认值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;z&#39;, 404) # 获取属性&#39;z&#39;，如果不存在，返回默认值404
404
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以获得对象的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; hasattr(obj, &#39;power&#39;) # 有属性&#39;power&#39;吗？
True
&amp;gt;&amp;gt;&amp;gt; getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;
&amp;lt;bound method MyObject.power of &amp;lt;__main__.MyObject object at 0x10077a6a0&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; fn = getattr(obj, &#39;power&#39;) # 获取属性&#39;power&#39;并赋值到变量fn
&amp;gt;&amp;gt;&amp;gt; fn # fn指向obj.power
&amp;lt;bound method MyObject.power of &amp;lt;__main__.MyObject object at 0x10077a6a0&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; fn() # 调用fn()与调用obj.power()是一样的
81
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;

&lt;p&gt;通过内置的一系列函数，我们可以对任意一个 Python 对象进行剖析，拿到其内部的数据。要注意的是，只有在不知道对象信息的时候，我们才会去获取对象信息。如果可以直接写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sum = obj.x + obj.y
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就不要写：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sum = getattr(obj, &#39;x&#39;) + getattr(obj, &#39;y&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;一个正确的用法的例子如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def readImage(fp):
    if hasattr(fp, &#39;read&#39;):
        return readData(fp)
    return None
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设我们希望从文件流&lt;code&gt;fp&lt;/code&gt;中读取图像，我们首先要判断该&lt;code&gt;fp&lt;/code&gt;对象是否存在&lt;code&gt;read()&lt;/code&gt;方法，如果存在，则该对象是一个流，如果不存在，则无法读取。&lt;code&gt;hasattr()&lt;/code&gt;就派上了用场。&lt;/p&gt;

&lt;p&gt;请注意，在 Python 这类动态语言中，根据鸭子类型，有&lt;code&gt;read()&lt;/code&gt;方法，不代表该&lt;code&gt;fp&lt;/code&gt;对象就是一个&lt;del&gt;&lt;code&gt;文件流&lt;/code&gt;&lt;/del&gt;，它也可能是&lt;code&gt;网络流&lt;/code&gt;，也可能是内存中的一个&lt;code&gt;字节流&lt;/code&gt;，但只要&lt;code&gt;read()&lt;/code&gt;方法返回的是有效的图像数据，就不影响读取图像的功能。&lt;/p&gt;

&lt;h2 id=&#34;实例属性和类属性&#34;&gt;实例属性和类属性&lt;/h2&gt;

&lt;p&gt;由于 Python 是动态语言，根据类创建的实例可以任意绑定属性，但这个属性只与实例有关，与类无关。我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到。编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是删除实例属性后，再使用相同的名称，访问到的将是类属性。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:-&#34;&gt;类在一定条件下也可以实时添加新的属性，具体方法参考高级部分内容。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:-&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:new-init&#34;&gt;教程中说的是创建实例的时候，实际上创建与&lt;code&gt;__new__()&lt;/code&gt;对应，要早于&lt;code&gt;__init__()&lt;/code&gt;。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:new-init&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:getattr-setattr&#34;&gt;和后面的&lt;code&gt;getattr()&lt;/code&gt;、&lt;code&gt;setattr()&lt;/code&gt;不同，那里的两个方法是 Python 实现的适用于全体类的通用方法。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:getattr-setattr&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>《廖雪峰 Python 教程》笔记 3：Module, Package</title>
      <link>/tech/2017/06/16/python/</link>
      <pubDate>Fri, 16 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/06/16/python/</guid>
      <description>
        

&lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318447437605e90206e261744c08630a836851f5183000&#34; target=&#34;_blank&#34;&gt;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014318447437605e90206e261744c08630a836851f5183000&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;概念&#34;&gt;概念&lt;/h1&gt;

&lt;h2 id=&#34;模块&#34;&gt;模块&lt;/h2&gt;

&lt;p&gt;在计算机程序的开发过程中，随着程序代码越写越多，在一个文件里代码就会越来越长，越来越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样，每个文件包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在 Python 中，一个&lt;code&gt;.py&lt;/code&gt;文件就称之为一个&lt;strong&gt;模块&lt;/strong&gt;（Module）。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;使用模块有什么好处？&lt;/p&gt;

&lt;p&gt;最大的好处是大大提高了代码的可维护性。其次，编写代码不必从零开始。当一个模块编写完毕，就可以被其他地方引用。我们在编写程序的时候，也经常引用其他模块，包括 Python 内置的模块和来自第三方的模块。&lt;/p&gt;

&lt;p&gt;使用模块还可以避免函数名和变量名冲突。相同名字的函数和变量完全可以分别存在不同的模块中，因此，我们自己在编写模块时，不必考虑名字会与其他模块冲突。但是也要注意，尽量不要与内置函数名字冲突。点&lt;a href=&#34;http://docs.python.org/3/library/functions.html&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;查看 Python 的所有内置函数。&lt;/p&gt;

&lt;h2 id=&#34;包&#34;&gt;包&lt;/h2&gt;

&lt;p&gt;你也许还想到，如果不同的人编写的模块名相同怎么办？为了避免模块名冲突，Python 又引入了按目录来组织模块的方法，称为&lt;strong&gt;包&lt;/strong&gt;（Package）。&lt;/p&gt;

&lt;p&gt;举个例子，一个&lt;code&gt;abc.py&lt;/code&gt;的文件就是一个名字叫&lt;code&gt;abc&lt;/code&gt;的模块，一个&lt;code&gt;xyz.py&lt;/code&gt;的文件就是一个名字叫&lt;code&gt;xyz&lt;/code&gt;的模块。&lt;/p&gt;

&lt;p&gt;现在，假设我们的&lt;code&gt;abc&lt;/code&gt;和&lt;code&gt;xyz&lt;/code&gt;这两个模块名字与其他模块冲突了，于是我们可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，比如&lt;code&gt;mycompany&lt;/code&gt;，按照如下目录存放：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ mycompany
    - __init__.py
    - abc.py
    - xyz.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。现在，&lt;code&gt;abc.py&lt;/code&gt;模块的名字就变成了&lt;code&gt;mycompany.abc&lt;/code&gt;，类似的，&lt;code&gt;xyz.py&lt;/code&gt;的模块名变成了&lt;code&gt;mycompany.xyz&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;请注意，每一个包目录下面都会有一个&lt;code&gt;__init__.py&lt;/code&gt;的文件，这个文件是必须存在的，否则，Python 就把这个目录当成普通目录，而不是一个包。&lt;code&gt;__init__.py&lt;/code&gt;可以是空文件，也可以有 Python 代码，因为&lt;code&gt;__init__.py&lt;/code&gt;本身就是一个模块，而它的模块名就是&lt;code&gt;mycompany&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;类似的，可以有多级目录，组成多级层次的包结构。比如如下的目录结构：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+ mycompany
    + web
        - __init__.py
        - utils.py
        - www.py
    - __init__.py
    - abc.py
    - utils.py
    - xyz.py
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;文件&lt;code&gt;www.py&lt;/code&gt;的模块名就是&lt;code&gt;mycompany.web.www&lt;/code&gt;，两个文件&lt;code&gt;utils.py&lt;/code&gt;的模块名分别是&lt;code&gt;mycompany.utils&lt;/code&gt;和&lt;code&gt;mycompany.web.utils&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;自己创建模块时要注意命名，不能和 Python 自带的模块名称冲突。例如，系统自带了&lt;code&gt;sys&lt;/code&gt;模块，自己的模块就不可命名为&lt;code&gt;sys.py&lt;/code&gt;，否则将无法导入系统自带的&lt;code&gt;sys&lt;/code&gt;模块。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mycompany.web&lt;/code&gt;也是一个模块，请指出该模块对应的&lt;code&gt;.py&lt;/code&gt;文件。&lt;/p&gt;

&lt;h1 id=&#34;使用模块-完整示例&#34;&gt;使用模块：完整示例&lt;/h1&gt;

&lt;p&gt;Python 本身就内置了很多非常有用的模块，只要安装完毕，这些模块就可以立刻使用。&lt;/p&gt;

&lt;p&gt;我们以内建的&lt;code&gt;sys&lt;/code&gt;模块为例，编写一个&lt;code&gt;hello&lt;/code&gt;的模块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python3
# -*- coding: utf-8 -*-

&#39; a test module &#39;

__author__ = &#39;Michael Liao&#39;

import sys

def test():
    args = sys.argv
    if len(args)==1:
        print(&#39;Hello, world!&#39;)
    elif len(args)==2:
        print(&#39;Hello, %s!&#39; % args[1])
    else:
        print(&#39;Too many arguments!&#39;)

if __name__==&#39;__main__&#39;:
    test()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;第 1 行和第 2 行是标准注释，第 1 行注释可以让这个&lt;code&gt;hello.py&lt;/code&gt;文件直接在&lt;code&gt;Unix/Linux/Mac&lt;/code&gt;上运行，第 2 行注释表示&lt;code&gt;.py&lt;/code&gt;文件本身使用标准 UTF-8 编码；&lt;/li&gt;
&lt;li&gt;第 4 行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释；&lt;/li&gt;
&lt;li&gt;第 6 行使用&lt;code&gt;__author__&lt;/code&gt;变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上就是 Python 模块的标准文件模板，当然也可以全部删掉不写，但是，按标准办事肯定没错。后面开始就是真正的代码部分。&lt;/p&gt;

&lt;p&gt;你可能注意到了，使用&lt;code&gt;sys&lt;/code&gt;模块的第一步，就是导入该模块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入&lt;code&gt;sys&lt;/code&gt;模块后，我们就有了变量&lt;code&gt;sys&lt;/code&gt;指向该模块，利用&lt;code&gt;sys&lt;/code&gt;这个变量，就可以访问&lt;code&gt;sys&lt;/code&gt;模块的所有功能。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sys&lt;/code&gt;模块有一个&lt;code&gt;argv&lt;/code&gt;变量，用&lt;code&gt;list&lt;/code&gt;存储了命令行的所有参数。&lt;code&gt;argv&lt;/code&gt;至少有一个元素，因为第一个参数永远是该&lt;code&gt;.py&lt;/code&gt;文件的名称，例如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;运行&lt;code&gt;python3 hello.py&lt;/code&gt;获得的&lt;code&gt;sys.argv&lt;/code&gt;就是&lt;code&gt;[&#39;hello.py&#39;]&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;运行&lt;code&gt;python3 hello.py Michael&lt;/code&gt;获得的&lt;code&gt;sys.argv&lt;/code&gt;就是&lt;code&gt;[&#39;hello.py&#39;, &#39;Michael]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最后，注意到这两行代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;if __name__==&#39;__main__&#39;:
    test()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们在命令行运行&lt;code&gt;hello&lt;/code&gt;模块文件时，Python 解释器把一个特殊变量&lt;code&gt;__name__&lt;/code&gt;置为&lt;code&gt;__main__&lt;/code&gt;，而如果在其他地方导入该&lt;code&gt;hello&lt;/code&gt;模块时，&lt;code&gt;if&lt;/code&gt;判断将失败，因此，这种&lt;code&gt;if&lt;/code&gt;测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。&lt;/p&gt;

&lt;p&gt;我们可以用命令行运行&lt;code&gt;hello.py&lt;/code&gt;看看效果：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;$ python3 hello.py
Hello, world!
$ python hello.py Michael
Hello, Michael!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果启动Python交互环境，再导入hello模块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;$ python3
Python 3.4.3 (v3.4.3:9b73f1c3e601, Feb 23 2015, 02:52:03) 
[GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin
Type &amp;quot;help&amp;quot;, &amp;quot;copyright&amp;quot;, &amp;quot;credits&amp;quot; or &amp;quot;license&amp;quot; for more information.
&amp;gt;&amp;gt;&amp;gt; import hello
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;导入时，没有打印&lt;code&gt;Hello, word!&lt;/code&gt;，因为没有执行&lt;code&gt;test()&lt;/code&gt;函数。&lt;/p&gt;

&lt;p&gt;调用&lt;code&gt;hello.test()&lt;/code&gt;时，才能打印出&lt;code&gt;Hello, word!&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; hello.test()
Hello, world!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;作用域&#34;&gt;作用域&lt;/h2&gt;

&lt;p&gt;在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在 Python 中，是通过&lt;code&gt;_&lt;/code&gt;前缀来实现的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正常的函数和变量名是&lt;strong&gt;公开&lt;/strong&gt;的（public），可以被直接引用，比如：&lt;code&gt;abc&lt;/code&gt;，&lt;code&gt;x123&lt;/code&gt;，&lt;code&gt;PI&lt;/code&gt;等；&lt;/li&gt;
&lt;li&gt;类似&lt;code&gt;__xxx__&lt;/code&gt;这样的变量是&lt;strong&gt;特殊&lt;/strong&gt;变量，可以被直接引用，但是有特殊用途，比如上面的&lt;code&gt;__author__&lt;/code&gt;，&lt;code&gt;__name__&lt;/code&gt;就是特殊变量，&lt;code&gt;hello&lt;/code&gt;模块定义的文档注释也可以用特殊变量&lt;code&gt;__doc__&lt;/code&gt;访问，我们自己的变量一般不要用这种变量名；&lt;/li&gt;
&lt;li&gt;类似&lt;code&gt;_xxx&lt;/code&gt;和&lt;code&gt;__xxx&lt;/code&gt;这样的函数或变量就是&lt;strong&gt;非公开&lt;/strong&gt;的（private），不应该被直接引用，比如&lt;code&gt;_abc&lt;/code&gt;，&lt;code&gt;__abc&lt;/code&gt;等；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之所以我们说，private 函数和变量&lt;strong&gt;不应该&lt;/strong&gt;被直接引用，而不是&lt;del&gt;&lt;strong&gt;不能&lt;/strong&gt;&lt;/del&gt;被直接引用，是因为 Python 并没有一种方法可以完全限制访问 private 函数或变量，但是，从编程习惯上不应该引用 private 函数或变量。&lt;/p&gt;

&lt;p&gt;private 函数或变量不应该被别人引用，那它们有什么用呢？请看例子：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def _private_1(name):
    return &#39;Hello, %s&#39; % name

def _private_2(name):
    return &#39;Hi, %s&#39; % name

def greeting(name):
    if len(name) &amp;gt; 3:
        return _private_1(name)
    else:
        return _private_2(name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们在模块里公开&lt;code&gt;greeting()&lt;/code&gt;函数，而把内部逻辑用 private 函数隐藏起来了，这样，调用&lt;code&gt;greeting()&lt;/code&gt;函数不用关心内部的 private 函数细节，这也是一种非常有用的代码封装和抽象的方法，即：&lt;/p&gt;

&lt;p&gt;外部不需要引用的函数全部定义成 private，只有外部需要引用的函数才定义为 public。&lt;/p&gt;

&lt;h1 id=&#34;第三方模块&#34;&gt;第三方模块&lt;/h1&gt;

&lt;p&gt;在 Python 中，安装第三方模块，是通过包管理工具&lt;code&gt;pip&lt;/code&gt;完成的。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果你正在使用 Mac 或 Linux，安装&lt;code&gt;pip&lt;/code&gt;本身这个步骤就可以跳过了。&lt;/li&gt;
&lt;li&gt;如果你正在使用 Windows，请参考&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014316090478912dab2a3a9e8f4ed49d28854b292f85bb000&#34; target=&#34;_blank&#34;&gt;安装 Python&lt;/a&gt; 一节的内容，确保安装时勾选了&lt;code&gt;pip&lt;/code&gt;和&lt;code&gt;Add python.exe to Path&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在命令提示符窗口下尝试运行&lt;code&gt;pip&lt;/code&gt;，如果 Windows 提示未找到命令，可以重新运行安装程序添加&lt;code&gt;pip&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：Mac 或 Linux 上有可能并存 Python 3.x 和 Python 2.x，因此对应的 pip 命令是&lt;code&gt;pip3&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;现在，让我们来安装一个第三方库——&lt;strong&gt;Python Imaging Library&lt;/strong&gt;，这是 Python 下非常强大的处理图像的工具库。不过，&lt;code&gt;PIL&lt;/code&gt;目前只支持到 Python 2.7，并且有年头没有更新了，因此，基于&lt;code&gt;PIL&lt;/code&gt;的&lt;code&gt;Pillow&lt;/code&gt;项目开发非常活跃，并且支持最新的 Python 3。&lt;/p&gt;

&lt;p&gt;一般来说，第三方库都会在 Python 官方的 &lt;pypi.python.org&gt; 网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如 &lt;a href=&#34;https://pypi.python.org/pypi/Pillow/&#34; target=&#34;_blank&#34;&gt;Pillow&lt;/a&gt; 的名称叫&lt;code&gt;Pillow&lt;/code&gt;，因此，安装&lt;code&gt;Pillow&lt;/code&gt;的命令就是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;pip install Pillow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;耐心等待下载并安装后，就可以使用&lt;code&gt;Pillow&lt;/code&gt;了。&lt;/p&gt;

&lt;p&gt;有了&lt;code&gt;Pillow&lt;/code&gt;，处理图片易如反掌。随便找个图片生成缩略图：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from PIL import Image
&amp;gt;&amp;gt;&amp;gt; im = Image.open(&#39;test.png&#39;)
&amp;gt;&amp;gt;&amp;gt; print(im.format, im.size, im.mode)
PNG (400, 300) RGB
&amp;gt;&amp;gt;&amp;gt; im.thumbnail((200, 100))
&amp;gt;&amp;gt;&amp;gt; im.save(&#39;thumb.jpg&#39;, &#39;JPEG&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其他常用的第三方库还有 MySQL 的驱动：&lt;code&gt;mysql-connector-python&lt;/code&gt;，用于科学计算的 NumPy 库：&lt;code&gt;numpy&lt;/code&gt;，用于生成文本的模板工具&lt;code&gt;Jinja2&lt;/code&gt;，等等。&lt;/p&gt;

&lt;h2 id=&#34;模块搜索路径&#34;&gt;模块搜索路径&lt;/h2&gt;

&lt;p&gt;当我们试图加载一个模块时，Python 会在指定的路径下搜索对应的&lt;code&gt;.py&lt;/code&gt;文件，如果找不到，就会报错：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import mymodule
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
ImportError: No module named mymodule
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认情况下，Python 解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在&lt;code&gt;sys&lt;/code&gt;模块的&lt;code&gt;path&lt;/code&gt;变量中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; sys.path
[&#39;&#39;, &#39;/Library/Frameworks/Python.framework/Versions/3.4/lib/python34.zip&#39;, &#39;/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4&#39;, &#39;/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/plat-darwin&#39;, &#39;/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/lib-dynload&#39;, &#39;/Library/Frameworks/Python.framework/Versions/3.4/lib/python3.4/site-packages&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们要添加自己的搜索目录，有两种方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;直接修改&lt;code&gt;sys.path&lt;/code&gt;，添加要搜索的目录：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; sys.path.append(&#39;/Users/michael/my_py_scripts&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种方法是在运行时修改，运行结束后失效。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;设置环境变量&lt;code&gt;PYTHONPATH&lt;/code&gt;，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置&lt;code&gt;Path&lt;/code&gt;环境变量类似。注意只需要添加你自己的搜索路径，Python 自己本身的搜索路径不受影响。&lt;/li&gt;
&lt;/ol&gt;

        
      </description>
    </item>
    
    <item>
      <title>RMarkdown 应用笔记</title>
      <link>/tech/2017/06/15/rmarkdown-notes/</link>
      <pubDate>Thu, 15 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/06/15/rmarkdown-notes/</guid>
      <description>
        

&lt;h1 id=&#34;给-chunk-添加新的-class-name&#34;&gt;给 Chunk 添加新的 Class Name&lt;/h1&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;普通代码高亮&#34;&gt;普通代码高亮&lt;/h2&gt;

&lt;p&gt;根据&lt;a href=&#34;https://stackoverflow.com/questions/37944197/add-a-css-class-to-single-code-chunks-in-rmarkdown&#34; target=&#34;_blank&#34;&gt;https://stackoverflow.com/questions/37944197/add-a-css-class-to-single-code-chunks-in-rmarkdown&lt;/a&gt;的说明，Pandoc 的&lt;code&gt;fenced_code_attributes&lt;/code&gt;默认在 RMarkdown 中已经打开，因此不需要再添加&lt;code&gt;md_extensions: +fenced_code_attributes&lt;/code&gt;语句到 YAML 的&lt;code&gt;html_document&lt;/code&gt;之下；又根据 &lt;a href=&#34;/stylus/2016/10/26/markdown-in-pandoc/&#34;&gt;markdown-in-pandoc&lt;/a&gt; 中 6.2.3 的说明可知，在&lt;code&gt;fenced_code_attributes&lt;/code&gt;扩展启用的前提下，可以将下面的代码&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;```html
这是一个普通段落。

&amp;lt;table&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;Foo&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;

这是另一个普通段落。
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改成&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;```{.html .gray}
      ......
```
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以达到添加新 Class 名称的目的。&lt;/p&gt;

&lt;h2 id=&#34;r-chunk-中的代码高亮&#34;&gt;R Chunk 中的代码高亮&lt;/h2&gt;

&lt;h3 id=&#34;推荐做法&#34;&gt;推荐做法&lt;/h3&gt;

&lt;p&gt;根据&lt;a href=&#34;https://github.com/yihui/knitr-examples/&#34; target=&#34;_blank&#34;&gt;https://github.com/yihui/knitr-examples/&lt;/a&gt;第 &lt;a href=&#34;https://github.com/yihui/knitr-examples/blob/master/116-html-class.Rmd&#34; target=&#34;_blank&#34;&gt;116 号示例&lt;/a&gt;以及 &lt;a href=&#34;https://github.com/yihui/knitr/issues/1333&#34; target=&#34;_blank&#34;&gt;knitr 133 号问题&lt;/a&gt;的讨论，可以给 R Chunk 一个&lt;code&gt;class.output&lt;/code&gt;属性，如&lt;code&gt;,class.output=&#39;myClass&#39;&lt;/code&gt;的方式添加一个输出样式类名称，如果需要多个，可以用&lt;code&gt;,class.output=c(&amp;quot;myclass1&amp;quot;, &amp;quot;myclass2&amp;quot;)&lt;/code&gt;达到目的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;```{r df-drop-ok, class.source=&#39;bg-success&#39;, class.output=&#39;bg-success&#39;}
mtcars[, &amp;quot;mpg&amp;quot;, drop=FALSE]
```
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;不推荐做法&#34;&gt;不推荐做法&lt;/h3&gt;

&lt;p&gt;可以参考&lt;a href=&#34;https://stackoverflow.com/questions/37944197/add-a-css-class-to-single-code-chunks-in-rmarkdown&#34; target=&#34;_blank&#34;&gt;https://stackoverflow.com/questions/37944197/add-a-css-class-to-single-code-chunks-in-rmarkdown&lt;/a&gt;，这种做法一是不如谢给出的官方做法适用，另一个原因是只能针对 R 起作用，换言之，想要高亮的代码是 html 时，需要将其中的钩子函数中的&lt;code&gt;.r&lt;/code&gt;改成&lt;code&gt;.html&lt;/code&gt;，一旦这样，又会只能对 html 代码起作用，所以不推荐。&lt;/p&gt;

&lt;h1 id=&#34;属性解释&#34;&gt;属性解释&lt;/h1&gt;

&lt;h2 id=&#34;不理解&#34;&gt;不理解&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;class.source&lt;/code&gt;和&lt;code&gt;class.output&lt;/code&gt;同时出现在第 &lt;a href=&#34;https://github.com/yihui/knitr-examples/blob/master/116-html-class.Rmd&#34; target=&#34;_blank&#34;&gt;116 号示例&lt;/a&gt;中，但目前不清楚其作用。&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>《廖雪峰 Python 教程》笔记 2：函数式编程</title>
      <link>/tech/2017/06/14/python/</link>
      <pubDate>Wed, 14 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/06/14/python/</guid>
      <description>
        

&lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317848428125ae6aa24068b4c50a7e71501ab275d52000&#34; target=&#34;_blank&#34;&gt;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317848428125ae6aa24068b4c50a7e71501ab275d52000&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;函数式编程&#34;&gt;函数式编程&lt;/h1&gt;

&lt;p&gt;函数式编程是一种抽象程度很高的编程范式，&lt;code&gt;纯粹的&lt;/code&gt;函数式编程语言编写的函数没有&lt;del&gt;&lt;code&gt;变量&lt;/code&gt;&lt;/del&gt;，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;函数式编程的一个&lt;strong&gt;特点&lt;/strong&gt;就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Python 对函数式编程提供&lt;code&gt;部分&lt;/code&gt;支持。由于 Python 允许使用变量，因此，Python 不是纯函数式编程语言。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;高阶函数&#34;&gt;高阶函数&lt;/h2&gt;

&lt;h3 id=&#34;变量可以指向函数&#34;&gt;变量可以指向函数&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; abs(-10)
10

&amp;gt;&amp;gt;&amp;gt; abs
&amp;lt;built-in function abs&amp;gt;

&amp;gt;&amp;gt;&amp;gt; f = abs
&amp;gt;&amp;gt;&amp;gt; f
&amp;lt;built-in function abs&amp;gt;

&amp;gt;&amp;gt;&amp;gt; f = abs
&amp;gt;&amp;gt;&amp;gt; f(-10)
10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的代码运行结果可以看到，函数本身也可以赋值给变量，即：变量可以指向函数。如果一个变量指向了一个函数，那么可以通过该变量来调用这个函数。&lt;/p&gt;

&lt;h3 id=&#34;函数名也是变量&#34;&gt;函数名也是变量&lt;/h3&gt;

&lt;p&gt;函数名其实就是指向函数的变量！对于&lt;code&gt;abs()&lt;/code&gt;这个函数，完全可以把函数名&lt;code&gt;abs&lt;/code&gt;看成变量，它指向一个可以计算绝对值的函数！如果把&lt;code&gt;abs&lt;/code&gt;指向其他对象，例如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; abs = 10
&amp;gt;&amp;gt;&amp;gt; abs(-10)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: &#39;int&#39; object is not callable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把&lt;code&gt;abs&lt;/code&gt;指向&lt;code&gt;10&lt;/code&gt;后，就无法通过&lt;code&gt;abs(-10)&lt;/code&gt;调用该函数了！因为&lt;code&gt;abs&lt;/code&gt;这个变量已经不指向求绝对值函数而是指向一个整数&lt;code&gt;10&lt;/code&gt;！当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复&lt;code&gt;abs&lt;/code&gt;函数，请重启 Python 交互环境。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注&lt;/strong&gt;：由于&lt;code&gt;abs&lt;/code&gt;函数实际上是定义在&lt;code&gt;import builtins&lt;/code&gt;模块中的，所以要让修改&lt;code&gt;abs&lt;/code&gt;变量的指向在其它模块也生效，要用&lt;code&gt;import builtins; builtins.abs = 10&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;高阶函数-变量名作为参数&#34;&gt;高阶函数：变量名作为参数&lt;/h3&gt;

&lt;p&gt;变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为&lt;strong&gt;高阶函数&lt;/strong&gt;。编写高阶函数，就是让函数的参数能够接收别的函数，函数式编程就是指这种高度抽象的编程范式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add(x, y, f):
    return f(x) + f(y)

x = -5
y = 6
f = abs
f(x) + f(y) ==&amp;gt; abs(-5) + abs(6) ==&amp;gt; 11
return 11
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;map-reduce-filter-sorted&#34;&gt;map, reduce, filter, sorted&lt;/h2&gt;

&lt;p&gt;读过论文 &lt;a href=&#34;http://research.google.com/archive/mapreduce.html&#34; target=&#34;_blank&#34;&gt;MapReduce: Simplified Data Processing on Large Clusters&lt;/a&gt;，就能大概明白&lt;code&gt;map/reduce&lt;/code&gt;的概念：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;map&lt;/code&gt;类似于 Matlab 或者 R 中的&lt;code&gt;apply&lt;/code&gt;系数函数，将函数&lt;code&gt;f&lt;/code&gt;作用于&lt;code&gt;list&lt;/code&gt;中的每个元素；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reduce&lt;/code&gt;类似于 R 中的&lt;code&gt;cumsum&lt;/code&gt;，将函数&lt;code&gt;f&lt;/code&gt;累积作用于序列中的每个元素；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filter&lt;/code&gt;作用于每个元素，然后根据返回值是&lt;code&gt;True&lt;/code&gt;还是&lt;code&gt;False&lt;/code&gt;决定保留还是丢弃该元素；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sorted&lt;/code&gt;函数可以指定排序的依据，默认时数值按大小、字符串按 ASCII 编号，但可将排序改为按绝对值大小、忽略字符大小写、按升序还是降序等；&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;map&#34;&gt;map()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;map()&lt;/code&gt;函数接收两个参数，一个是&lt;code&gt;函数名&lt;/code&gt;，一个是&lt;code&gt;Iterable&lt;/code&gt;，&lt;code&gt;map&lt;/code&gt;将传入的函数依次作用到序列的每个元素，并把结果作为一个&lt;code&gt;Iterator&lt;/code&gt;型返回。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def f(x):
...     return x * x
...
&amp;gt;&amp;gt;&amp;gt; r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])
&amp;gt;&amp;gt;&amp;gt; list(r)
[1, 4, 9, 16, 25, 36, 49, 64, 81]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面结果&lt;code&gt;r&lt;/code&gt;是一个 Iterator，Iterator 是&lt;code&gt;惰性&lt;/code&gt;序列，因此通过&lt;code&gt;list()&lt;/code&gt;函数让它把整个序列都计算出来并返回一个&lt;code&gt;list&lt;/code&gt;。&lt;code&gt;map()&lt;/code&gt;作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的$f(x)=x^2$，还可以计算任意复杂的函数，比如，把这个&lt;code&gt;list&lt;/code&gt;中的所有数字转为字符串：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;reduce&#34;&gt;reduce()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;reduce()&lt;/code&gt;把一个函数作用在一个序列&lt;code&gt;[x1, x2, x3, ...]&lt;/code&gt;上，这个函数必须接收两个参数，&lt;code&gt;reduce()&lt;/code&gt;把结果继续和序列的下一个元素做累积计算，其效果就是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比方说对一个序列求和，就可以用&lt;code&gt;reduce()&lt;/code&gt;实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from functools import reduce
&amp;gt;&amp;gt;&amp;gt; def add(x, y):
...     return x + y
...
&amp;gt;&amp;gt;&amp;gt; reduce(add, [1, 3, 5, 7, 9])
25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然求和运算可以直接用 Python 内建函数&lt;code&gt;sum()&lt;/code&gt;，没必要动用&lt;code&gt;reduce()&lt;/code&gt;。但是如果要把序列&lt;code&gt;[1, 3, 5, 7, 9]&lt;/code&gt;变换成整数&lt;code&gt;13579&lt;/code&gt;，&lt;code&gt;reduce()&lt;/code&gt;就可以派上用场：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from functools import reduce
&amp;gt;&amp;gt;&amp;gt; def fn(x, y):
...     return x * 10 + y
...
&amp;gt;&amp;gt;&amp;gt; reduce(fn, [1, 3, 5, 7, 9])
13579
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子本身没多大用处，但是，如果考虑到字符串&lt;code&gt;str&lt;/code&gt;也是一个序列，对上面的例子稍加改动，配合&lt;code&gt;map()&lt;/code&gt;，我们就可以写出把&lt;code&gt;str&lt;/code&gt;转换为&lt;code&gt;int&lt;/code&gt;的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from functools import reduce
&amp;gt;&amp;gt;&amp;gt; def fn(x, y):
...     return x * 10 + y
...
&amp;gt;&amp;gt;&amp;gt; def char2num(s):
...     return {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}[s]
...
&amp;gt;&amp;gt;&amp;gt; reduce(fn, map(char2num, &#39;13579&#39;))
13579
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的函数中，先用&lt;code&gt;map()&lt;/code&gt;将字符串&lt;code&gt;13579&lt;/code&gt;转换成一个整数序列&lt;code&gt;[1, 3, 5, 7, 9]&lt;/code&gt;，再用&lt;code&gt;reduce()&lt;/code&gt;将整数序列转换成一个整数，这个过程整理成一个&lt;code&gt;str2int()&lt;/code&gt;函数就是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from functools import reduce

def str2int(s):
    def fn(x, y):
        return x * 10 + y
    def char2num(s):
        return {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}[s]
    return reduce(fn, map(char2num, s))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还可以用&lt;code&gt;lambda&lt;/code&gt;函数进一步简化成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;from functools import reduce

def char2num(s):
    return {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9}[s]

def str2int(s):
    return reduce(lambda x, y: x * 10 + y, map(char2num, s))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也就是说，假设 Python 没有提供&lt;code&gt;int()&lt;/code&gt;函数，你完全可以自己写一个把字符串转化为整数的函数，而且只需要几行代码！&lt;code&gt;lambda&lt;/code&gt;函数的用法在后面介绍。&lt;/p&gt;

&lt;h3 id=&#34;filter&#34;&gt;filter()&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;filter()&lt;/code&gt;也接收一个函数和一个序列。和&lt;code&gt;map()&lt;/code&gt;不同的是，&lt;code&gt;filter()&lt;/code&gt;把传入的函数依次作用于每个元素，然后根据返回值是&lt;code&gt;True&lt;/code&gt;还是&lt;code&gt;False&lt;/code&gt;决定保留还是丢弃该元素。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def is_odd(n):
    return n % 2 == 1
list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))
# 结果: [1, 5, 9, 15]

// 删除序列中的空字符串
def not_empty(s):
    return s and s.strip()
list(filter(not_empty, [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, None, &#39;C&#39;, &#39;  &#39;]))
# 结果: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用&lt;code&gt;filter()&lt;/code&gt;这个高阶函数，关键在于正确实现一个&lt;strong&gt;筛选&lt;/strong&gt;函数。注意到&lt;code&gt;filter()&lt;/code&gt;函数返回的是一个 Iterator，也就是一个惰性序列，所以要强迫&lt;code&gt;filter()&lt;/code&gt;完成计算结果，需要用&lt;code&gt;list()&lt;/code&gt;函数获得所有结果并返回&lt;code&gt;list&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;讲义中用&lt;a href=&#34;http://baike.baidu.com/view/3784258.htm&#34; target=&#34;_blank&#34;&gt;埃氏筛法&lt;/a&gt;筛选中全部素数的方法，首先是利用了&lt;code&gt;filter()&lt;/code&gt;函数，其次还用到了 Iterator 型变量惰性计算特征下可以表示出全体自然数的优点，应该说是 Python 语言特征的一次典型应用，实际上在利用 Python 的这两个特殊技巧操作数据也是非常方便的。&lt;/p&gt;

&lt;h3 id=&#34;sorted&#34;&gt;sorted()&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; sorted([36, 5, -12, 9, -21])
[-21, -12, 5, 9, 36]

&amp;gt;&amp;gt;&amp;gt; sorted([36, 5, -12, 9, -21], key=abs)
[5, 9, -12, -21, 36]

&amp;gt;&amp;gt;&amp;gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;])
[&#39;Credit&#39;, &#39;Zoo&#39;, &#39;about&#39;, &#39;bob&#39;]

&amp;gt;&amp;gt;&amp;gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower)
[&#39;about&#39;, &#39;bob&#39;, &#39;Credit&#39;, &#39;Zoo&#39;]

&amp;gt;&amp;gt;&amp;gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True)
[&#39;Zoo&#39;, &#39;Credit&#39;, &#39;bob&#39;, &#39;about&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;返回值为函数-闭包-难度较高&#34;&gt;返回值为函数、闭包（难度较高）&lt;/h2&gt;

&lt;p&gt;高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。一个可变参数的求和通常情况下是这样定义的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def calc_sum(*args):
    ax = 0
    for n in args:
        ax = ax + n
    return ax
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def lazy_sum(*args):
    def sum():
        ax = 0
        for n in args:
            ax = ax + n
        return ax
    return sum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我们调用&lt;code&gt;lazy_sum()&lt;/code&gt;时，返回的并不是&lt;del&gt;&lt;strong&gt;求和结果&lt;/strong&gt;&lt;/del&gt;，而是&lt;strong&gt;求和函数&lt;/strong&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; f = lazy_sum(1, 3, 5, 7, 9)
&amp;gt;&amp;gt;&amp;gt; f
&amp;lt;function lazy_sum.&amp;lt;locals&amp;gt;.sum at 0x101c6ed90&amp;gt;

&amp;gt;&amp;gt;&amp;gt; f()     // 调用函数 f 时，才真正计算求和的结果：
25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，我们在函数&lt;code&gt;lazy_sum&lt;/code&gt;中又定义了函数&lt;code&gt;sum&lt;/code&gt;，并且，内部函数&lt;code&gt;sum&lt;/code&gt;可以引用外部函数&lt;code&gt;lazy_sum&lt;/code&gt;的参数和局部变量，当&lt;code&gt;lazy_sum&lt;/code&gt;返回函数&lt;code&gt;sum&lt;/code&gt;时，相关参数和变量都保存在返回的函数中&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:-&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:-&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;，这种称为&lt;strong&gt;闭包（Closure）&lt;/strong&gt;的程序结构拥有极大的威力。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：调用&lt;code&gt;lazy_sum()&lt;/code&gt;时，每次调用都会返回一个新的函数，即使传入相同的参数：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; f1 = lazy_sum(1, 3, 5, 7, 9)
&amp;gt;&amp;gt;&amp;gt; f2 = lazy_sum(1, 3, 5, 7, 9)
&amp;gt;&amp;gt;&amp;gt; f1==f2
False
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;f1()&lt;/code&gt;和&lt;code&gt;f2()&lt;/code&gt;的调用结果互不影响。&lt;/p&gt;

&lt;p&gt;注意到返回的函数在其定义内部引用了局部变量&lt;code&gt;args&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:sum-args&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:sum-args&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。&lt;strong&gt;疑惑&lt;/strong&gt;的是这里&lt;strong&gt;其&lt;/strong&gt;指的是什么、&lt;strong&gt;新函数&lt;/strong&gt;是什么没有弄明白。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：返回的函数并没有立刻执行，而是直到调用了&lt;code&gt;f()&lt;/code&gt;才执行&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;def count():
    fs = []
    for i in range(1, 4):
        def f():
             return i*i
        fs.append(f)
    return fs

f1, f2, f3 = count()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中，&lt;code&gt;range(1,4)&lt;/code&gt;对应&lt;code&gt;[1, 2, 3]&lt;/code&gt;，每次循环都创建了一个新的函数，然后，把创建的 3 个函数都返回了。可能会认为调用&lt;code&gt;f1()&lt;/code&gt;，&lt;code&gt;f2()&lt;/code&gt;和&lt;code&gt;f3()&lt;/code&gt;结果应该是&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;4&lt;/code&gt;，&lt;code&gt;9&lt;/code&gt;，但实际结果是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; f1()
9
&amp;gt;&amp;gt;&amp;gt; f2()
9
&amp;gt;&amp;gt;&amp;gt; f3()
9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全部都是&lt;code&gt;9&lt;/code&gt;！原因就在于返回的函数引用了变量&lt;code&gt;i&lt;/code&gt;，但它并非立刻执行。等到 3 个函数都返回时，它们所引用的变量&lt;code&gt;i&lt;/code&gt;已经变成了&lt;code&gt;3&lt;/code&gt;，因此最终结果为&lt;code&gt;9&lt;/code&gt;。返回闭包时牢记的一点就是：&lt;strong&gt;返回函数不要引用任何循环变量，或者后续会发生变化的变量&lt;/strong&gt;。如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;疑惑&lt;/strong&gt;：什么时候&lt;code&gt;f1()&lt;/code&gt;、&lt;code&gt;f2()&lt;/code&gt;和&lt;code&gt;f3()&lt;/code&gt;会有参数，该怎么操作？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def count():
    def f(j):
        def g():
            return j*j
        return g
    fs = []
    for i in range(1, 4):
        fs.append(f(i))     # f(i)立刻被执行，因此i的当前值被传入f()
    return fs

&amp;gt;&amp;gt;&amp;gt; f1, f2, f3 = count()
&amp;gt;&amp;gt;&amp;gt; f1()
1
&amp;gt;&amp;gt;&amp;gt; f2()
4
&amp;gt;&amp;gt;&amp;gt; f3()
9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这种做法的缺点是代码较长，可利用&lt;code&gt;lambda()&lt;/code&gt;函数缩短代码。&lt;/p&gt;

&lt;h2 id=&#34;匿名函数-lambda&#34;&gt;匿名函数(lambda)&lt;/h2&gt;

&lt;p&gt;有些时候，不需要显式地定义函数，直接传入匿名函数更方便。在 Python 中，对匿名函数提供了有限支持。还是以&lt;code&gt;map()&lt;/code&gt;函数为例，计算$f(x)=x^2$时，除了定义一个$f(x)$的函数外，还可以直接传入匿名函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))
[1, 4, 9, 16, 25, 36, 49, 64, 81]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过对比可以看出，匿名函数&lt;code&gt;lambda x: x * x&lt;/code&gt;实际上就是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def f(x):
    return x * x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键字&lt;code&gt;lambda&lt;/code&gt;表示匿名函数，冒号前面的&lt;code&gt;x&lt;/code&gt;表示函数参数。&lt;/p&gt;

&lt;p&gt;匿名函数有个限制，就是只能有一个表达式，不用写&lt;code&gt;return&lt;/code&gt;，返回值就是该表达式的结果。用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; f = lambda x: x * x
&amp;gt;&amp;gt;&amp;gt; f
&amp;lt;function &amp;lt;lambda&amp;gt; at 0x101c6ef28&amp;gt;
&amp;gt;&amp;gt;&amp;gt; f(5)
25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样，也可以把匿名函数作为返回值返回，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def build(x, y):
    return lambda: x * x + y * y
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;装饰器-decorator&#34;&gt;装饰器(decorator)&lt;/h2&gt;

&lt;p&gt;在面向对象（OOP）的设计模式中，decorator 被称为装饰模式。OOP 的装饰模式需要通过继承和组合来实现，而 Python 除了能支持 OOP 的 decorator 外，直接从语法层次支持 decorator。Python 的 decorator 可以用函数实现，也可以用类实现。decorator 可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。&lt;/p&gt;

&lt;p&gt;由于函数也是一个对象，而且函数对象可以被赋值给变量，所以，通过变量也能调用该函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; def now():
...     print(&#39;2015-3-25&#39;)
...
&amp;gt;&amp;gt;&amp;gt; f = now
&amp;gt;&amp;gt;&amp;gt; f()
2015-3-25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数对象有一个&lt;code&gt;__name__&lt;/code&gt;属性，可以得到函数的名字：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; now.__name__
&#39;now&#39;
&amp;gt;&amp;gt;&amp;gt; f.__name__
&#39;now&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，假设我们要增强&lt;code&gt;now()&lt;/code&gt;函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改&lt;code&gt;now()&lt;/code&gt;函数的定义，这种在代码运行期间动态增加功能的方式，称之为&lt;strong&gt;装饰器&lt;/strong&gt;（Decorator）。&lt;/p&gt;

&lt;p&gt;本质上，decorator 就是一个返回函数的高阶函数，其参数为指定的函数名称，返回值为一个函数，目的是在不改变输入函数功能的前提下对原始函数进行功能增加。所以，我们要定义一个能打印日志的 decorator，可以定义如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def log(func):
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;观察上面的&lt;code&gt;log()&lt;/code&gt;，因为它是一个 decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助 Python 的&lt;code&gt;@&lt;/code&gt;语法，把 decorator 置于函数的定义处：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@log
def now():
    print(&#39;2015-3-25&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调用&lt;code&gt;now()&lt;/code&gt;函数，不仅会运行&lt;code&gt;now()&lt;/code&gt;函数本身，还会在运行&lt;code&gt;now()&lt;/code&gt;函数前打印一行日志：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; now()
call now():
2015-3-25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;把&lt;code&gt;@log&lt;/code&gt;放到&lt;code&gt;now()&lt;/code&gt;函数的定义处，相当于执行了语句：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;now = log(now)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于&lt;code&gt;log()&lt;/code&gt;是一个 decorator，返回一个函数，所以，原来的&lt;code&gt;now()&lt;/code&gt;函数仍然存在，只是现在同名的&lt;code&gt;now&lt;/code&gt;变量指向了新的函数，于是调用&lt;code&gt;now()&lt;/code&gt;将执行新函数，即在&lt;code&gt;log()&lt;/code&gt;函数中返回的&lt;code&gt;wrapper()&lt;/code&gt;函数。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wrapper()&lt;/code&gt;函数的参数定义是&lt;code&gt;(*args, **kw)&lt;/code&gt;，因此，&lt;code&gt;wrapper()&lt;/code&gt;函数可以接受任意参数的调用。在&lt;code&gt;wrapper()&lt;/code&gt;函数内，首先打印日志，再紧接着调用原始函数。&lt;/p&gt;

&lt;p&gt;如果 decorator 本身需要传入参数，那就需要编写一个返回 decorator 的高阶函数，写出来会更复杂。比如，要自定义&lt;code&gt;log()&lt;/code&gt;的文本：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def log(text):
    def decorator(func):
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个 3 层嵌套的 decorator 用法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;@log(&#39;execute&#39;)
def now():
    print(&#39;2015-3-25&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行结果如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; now()
execute now():
2015-3-25
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和两层嵌套的 decorator 相比，3 层嵌套的效果是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; now = log(&#39;execute&#39;)(now)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们来剖析上面的语句，首先执行&lt;code&gt;log(&#39;execute&#39;)&lt;/code&gt;，返回的是&lt;code&gt;decorator()&lt;/code&gt;函数，再调用返回的函数，参数是&lt;code&gt;now()&lt;/code&gt;函数，返回值最终是&lt;code&gt;wrapper()&lt;/code&gt;函数。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提醒&lt;/strong&gt;：以上两种 decorator 的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有&lt;code&gt;__name__&lt;/code&gt;等属性，但你去看经过 decorator 装饰之后的函数，它们的&lt;code&gt;__name__&lt;/code&gt;已经从原来的&lt;code&gt;&#39;now&#39;&lt;/code&gt;变成了&lt;code&gt;&#39;wrapper&#39;&lt;/code&gt;：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-pyhon&#34;&gt;&amp;gt;&amp;gt;&amp;gt; now.__name__
&#39;wrapper&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为返回的那个&lt;code&gt;wrapper()&lt;/code&gt;函数名字就是&lt;code&gt;&#39;wrapper&#39;&lt;/code&gt;，所以，需要把原始函数的&lt;code&gt;__name__&lt;/code&gt;等属性复制到&lt;code&gt;wrapper()&lt;/code&gt;函数中，否则，有些依赖函数签名的代码执行就会出错。&lt;/p&gt;

&lt;p&gt;不需要编写&lt;code&gt;wrapper.__name__ = func.__name__&lt;/code&gt;这样的代码，Python 内置的&lt;code&gt;functools.wraps&lt;/code&gt;就是干这个事的，所以，一个完整的 decorator 的写法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import functools

def log(func):
    @functools.wraps(func)
    def wrapper(*args, **kw):
        print(&#39;call %s():&#39; % func.__name__)
        return func(*args, **kw)
    return wrapper
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者针对带参数的 decorator：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import functools

def log(text):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kw):
            print(&#39;%s %s():&#39; % (text, func.__name__))
            return func(*args, **kw)
        return wrapper
    return decorator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;import functools&lt;/code&gt;是导入&lt;code&gt;functools&lt;/code&gt;模块。模块的概念稍候讲解。现在，只需记住在定义&lt;code&gt;wrapper()&lt;/code&gt;的前面加上&lt;code&gt;@functools.wraps(func)&lt;/code&gt;即可。&lt;/p&gt;

&lt;h2 id=&#34;偏函数&#34;&gt;偏函数&lt;/h2&gt;

&lt;p&gt;当函数的参数个数太多，需要简化时，使用&lt;code&gt;functools.partial&lt;/code&gt;可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。&lt;/p&gt;

&lt;p&gt;Python 的&lt;code&gt;functools&lt;/code&gt;模块提供了很多有用的功能，其中一个就是&lt;strong&gt;偏函数&lt;/strong&gt;（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。&lt;/p&gt;

&lt;p&gt;在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;int()&lt;/code&gt;函数可以把字符串转换为整数，当仅传入字符串时，&lt;code&gt;int()&lt;/code&gt;函数默认按十进制转换：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; int(&#39;12345&#39;)
12345
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但&lt;code&gt;int()&lt;/code&gt;函数还提供额外的&lt;code&gt;base&lt;/code&gt;参数，默认值为&lt;code&gt;10&lt;/code&gt;。如果传入&lt;code&gt;base&lt;/code&gt;参数，就可以做&lt;code&gt;N&lt;/code&gt;进制的转换：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; int(&#39;12345&#39;, base=8)
5349
&amp;gt;&amp;gt;&amp;gt; int(&#39;12345&#39;, 16)
74565
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设要转换大量的二进制字符串，每次都传入&lt;code&gt;int(x, base=2)&lt;/code&gt;非常麻烦，于是，我们想到，可以定义一个&lt;code&gt;int2()&lt;/code&gt;的函数，默认把&lt;code&gt;base=2&lt;/code&gt;传进去：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def int2(x, base=2):
    return int(x, base)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，我们转换二进制就非常方便了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; int2(&#39;1000000&#39;)
64
&amp;gt;&amp;gt;&amp;gt; int2(&#39;1010101&#39;)
85
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;functools.partial&lt;/code&gt;就是帮助我们创建一个偏函数的，不需要我们自己定义&lt;code&gt;int2()&lt;/code&gt;，可以直接使用下面的代码创建一个新的函数&lt;code&gt;int2&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import functools
&amp;gt;&amp;gt;&amp;gt; int2 = functools.partial(int, base=2)
&amp;gt;&amp;gt;&amp;gt; int2(&#39;1000000&#39;)
64
&amp;gt;&amp;gt;&amp;gt; int2(&#39;1010101&#39;)
85
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，简单总结&lt;code&gt;functools.partial&lt;/code&gt;的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。&lt;/p&gt;

&lt;p&gt;注意到上面的新的&lt;code&gt;int2()&lt;/code&gt;函数，仅仅是把&lt;code&gt;base&lt;/code&gt;参数重新设定默认值为&lt;code&gt;2&lt;/code&gt;，但也可以在函数调用时传入其他值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; int2(&#39;1000000&#39;, base=10)
1000000
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提醒&lt;/strong&gt;：最后，创建偏函数时，实际上可以接收&lt;code&gt;函数对象&lt;/code&gt;、&lt;code&gt;*args&lt;/code&gt;和&lt;code&gt;**kw&lt;/code&gt;这&lt;code&gt;3&lt;/code&gt;个参数，当传入：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;int2 = functools.partial(int, base=2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上固定了&lt;code&gt;int()&lt;/code&gt;函数的关键字参数&lt;code&gt;base&lt;/code&gt;，也就是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;int2(&#39;10010&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相当于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;kw = { &#39;base&#39;: 2 }
int(&#39;10010&#39;, **kw)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当传入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;max2 = functools.partial(max, 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;实际上会把&lt;code&gt;10&lt;/code&gt;作为&lt;code&gt;*args&lt;/code&gt;的一部分自动加到左边，也就是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;max2(5, 6, 7)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相当于：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;args = (10, 5, 6, 7)
max(*args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;结果为&lt;code&gt;10&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:-&#34;&gt;这里的相关参数和变量指什么？ &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:-&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:sum-args&#34;&gt;指&lt;code&gt;sum&lt;/code&gt;函数中用到了&lt;code&gt;args&lt;/code&gt;？ &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:sum-args&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>《廖雪峰 Python 教程》笔记 1：基础语法、函数</title>
      <link>/tech/2017/06/13/python/</link>
      <pubDate>Tue, 13 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/06/13/python/</guid>
      <description>
        

&lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000&#34; target=&#34;_blank&#34;&gt;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;python-简介&#34;&gt;Python 简介&lt;/h1&gt;

&lt;h2 id=&#34;python解释器&#34;&gt;Python解释器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPython&lt;/strong&gt;: 官方版本的解释器。这个解释器是用 C 语言开发的，所以叫 CPython。在命令行下运行 Python 就是启动 CPython 解释器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IPython&lt;/strong&gt;: CPython 之上的一个交互式解释器，也就是说，IPython 只是在交互方式上有所增强，但是执行 Python 代码的功能和 CPython 是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了 IE。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CPython&lt;/strong&gt; 用 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 作为提示符，而 IPython 用 &lt;code&gt;In [序号]:&lt;/code&gt; 作为提示符。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Jython&lt;/strong&gt;: 运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IronPython&lt;/strong&gt;: 和 Jython 类似，只不过 IronPython 是运行在微软 .Net 平台上的 Python 解释器，可以直接把 Python 代码编译成 .Net 的字节码。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Jupyter Notebook&lt;/strong&gt;: 此前被称为IPython notebook，是一个交互式笔记本，支持运行 40 多种编程语言。本质是一个 Web 应用程序，便于创建和共享文学化程序文档，支持实时代码，数学方程，可视化和 markdown。 用途包括数据清理和转换、数值模拟、统计建模、机器学习等等。&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- more --&gt;

&lt;h2 id=&#34;第一个-python-程序&#34;&gt;第一个 Python 程序&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;exit()&lt;/code&gt;退出 Python。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;python hello.py&lt;/code&gt;执行程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提醒&lt;/strong&gt;：能不能像&lt;code&gt;.exe&lt;/code&gt;文件那样直接运行&lt;code&gt;.py&lt;/code&gt;文件呢？在 Windows 上是不行的，但是，在 Mac 和 Linux 上是可以的，方法是在&lt;code&gt;.py&lt;/code&gt;文件的第一行加上一个特殊的注释：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python3
print(&#39;hello, world&#39;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后，通过命令给&lt;code&gt;hello.py&lt;/code&gt;以执行权限：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ chmod a+x hello.py
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python代码运行助手&#34;&gt;Python代码运行助手&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;print()&lt;/code&gt;会依次打印每个字符串，遇到逗号&lt;code&gt;,&lt;/code&gt;会输出一个&lt;strong&gt;空格&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;name = input()
name = input(&#39;please enter your name: &#39;)
print(&#39;hello,&#39;, name)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;input()&lt;/code&gt;返回的数据类型是&lt;code&gt;str&lt;/code&gt;，&lt;code&gt;str&lt;/code&gt;不能直接和整数比较，必须先把&lt;code&gt;str&lt;/code&gt;转换成整数。Python 提供了&lt;code&gt;int()&lt;/code&gt;函数来完成这件事情。&lt;/p&gt;

&lt;h1 id=&#34;python-基础语法&#34;&gt;Python 基础语法&lt;/h1&gt;

&lt;h2 id=&#34;预备知识&#34;&gt;预备知识&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;注释&lt;/strong&gt;：用&lt;code&gt;#&lt;/code&gt;开头，行内最后的注释也有用&lt;code&gt;//&lt;/code&gt;的；&lt;/li&gt;
&lt;li&gt;Python 大小写敏感；&lt;/li&gt;
&lt;li&gt;代码段由&lt;strong&gt;缩进&lt;/strong&gt;控制，因此复制可能导致意外发生，为了尽量减少意外，可能需要少用多重缩进，并且习惯上用将 1 个&lt;code&gt;tab&lt;/code&gt;对应为 4 个空格；&lt;/li&gt;
&lt;li&gt;注意&lt;code&gt;if&lt;/code&gt;和&lt;code&gt;else&lt;/code&gt;后面的&lt;code&gt;:&lt;/code&gt;，这表明接下来是一个&lt;code&gt;block&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;转义&lt;/strong&gt;：&lt;code&gt;\&lt;/code&gt;用于字符的转义，而&lt;code&gt;%%&lt;/code&gt;则用于占位符情形下&lt;code&gt;%&lt;/code&gt;的转义；&lt;code&gt;r&#39;&#39;&lt;/code&gt;用于简化转义；如果字符串内部有很多换行，用&lt;code&gt;\n&lt;/code&gt;写在一行里不好阅读，因此可以用&lt;code&gt;&#39;&#39;&#39;...&#39;&#39;&#39;&lt;/code&gt;定义多行文本，类似的，用&lt;code&gt;r&#39;&#39;&#39;...&#39;&#39;&#39;&lt;/code&gt;定义不必转义的多行文本，关于字符串中的&lt;code&gt;&#39;&lt;/code&gt;和&lt;code&gt;&amp;quot;&lt;/code&gt;，如果只有一种，则用另一种引括即可，如果两种都有，就需要用&lt;code&gt;\&#39;&lt;/code&gt;和&lt;code&gt;\&amp;quot;&lt;/code&gt;进行转义；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;占位符&lt;/strong&gt;：&lt;code&gt;%d&lt;/code&gt;对应整数，&lt;code&gt;%f&lt;/code&gt;对应浮点数，&lt;code&gt;%s&lt;/code&gt;对应字符串，&lt;code&gt;%x&lt;/code&gt;对应十六进制数，其中&lt;code&gt;%s&lt;/code&gt;是万金油，而&lt;code&gt;%f&lt;/code&gt;还可以指定显示格式，如&lt;code&gt;%.1f&lt;/code&gt;对应只显示 1 位小数的浮点数；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;基础语法&#34;&gt;基础语法&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;常见运算符与常量&lt;/strong&gt;：&lt;code&gt;+, -, *, **, /, //, True, False, and, or, not, &amp;amp;, |, !=, &amp;gt;=, &amp;lt;=, None, PI(常量经常用大写), /, //(地板除), %(余数)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Python 的&lt;strong&gt;整数&lt;/strong&gt;没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如 Java 对 32 位整数的范围限制在&lt;code&gt;-2147483648&lt;/code&gt;-&lt;code&gt;2147483647&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Python 的&lt;strong&gt;浮点数&lt;/strong&gt;也没有大小限制，但是超出一定范围就直接表示为&lt;code&gt;inf&lt;/code&gt;（无限大）。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;数据类型&#34;&gt;数据类型&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;基础&lt;/strong&gt;的类型有&lt;code&gt;字符串&lt;/code&gt;、&lt;code&gt;整数&lt;/code&gt;、&lt;code&gt;浮点数&lt;/code&gt;、&lt;code&gt;布尔值&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;复杂&lt;/strong&gt;的类型有&lt;code&gt;list, tuple&lt;/code&gt;，其中的&lt;code&gt;list&lt;/code&gt;类似于 Matlab 中的&lt;code&gt;cell&lt;/code&gt;类型，用&lt;code&gt;[]&lt;/code&gt;进行定义，&lt;code&gt;tuple&lt;/code&gt;中的内容一旦定义，不能再修改，用&lt;code&gt;()&lt;/code&gt;定义&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:tuple-myTuple-1&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:tuple-myTuple-1&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;；&lt;/li&gt;
&lt;li&gt;其它还有&lt;code&gt;dict, set&lt;/code&gt;，其中&lt;code&gt;dict&lt;/code&gt;对应&lt;code&gt;key-value&lt;/code&gt;对，如&lt;code&gt;d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}&lt;/code&gt;所示，用&lt;code&gt;{:,}&lt;/code&gt;的方式定义，包含&lt;code&gt;get()&lt;/code&gt;与&lt;code&gt;pop()&lt;/code&gt;方法，如&lt;code&gt;&#39;Thomas&#39; in d&lt;/code&gt;所示，还可以用&lt;code&gt;in&lt;/code&gt;这一操作；&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;dict&lt;/code&gt;类似，也是一组&lt;code&gt;key&lt;/code&gt;的集合，但不存储&lt;code&gt;value&lt;/code&gt;。由于&lt;code&gt;key&lt;/code&gt;不能重复，所以，在&lt;code&gt;set&lt;/code&gt;中，没有重复的&lt;code&gt;key&lt;/code&gt;，用&lt;code&gt;set([,])&lt;/code&gt;方式定义，可以使用&lt;code&gt;add()&lt;/code&gt;和&lt;code&gt;remove()&lt;/code&gt;方法，参考下面的例子：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; s = set([1, 1, 2, 2, 3, 3])
&amp;gt;&amp;gt;&amp;gt; s
{1, 2, 3}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字符串&#34;&gt;字符串&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;对于字符串而言，在内存中统一为 Unicode，但是具体到终端时，可能是各种类型的编码；&lt;/li&gt;
&lt;li&gt;对于单个字符的编码，Python 提供了&lt;code&gt;ord()&lt;/code&gt;函数获取字符的整数表示，&lt;code&gt;chr()&lt;/code&gt;函数把编码转换为对应的字符；&lt;/li&gt;
&lt;li&gt;如果知道字符的整数编码，还可以用十六进制这么写 str：&lt;code&gt;&#39;\u4e2d\u6587&#39;&lt;/code&gt;，这其实对应于字符串&lt;code&gt;中文&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;由于 Python 的字符串类型是&lt;code&gt;str&lt;/code&gt;，在内存中以 Unicode 表示，一个字符对应若干个字节（英文字母是 1 个字节，汉字是 3 个字节）。如果要在网络上传输，或者保存到磁盘上，就需要把&lt;code&gt;str&lt;/code&gt;变为以字节为单位的&lt;code&gt;bytes&lt;/code&gt;。Python 对&lt;code&gt;bytes&lt;/code&gt;类型的数据用带&lt;code&gt;b&lt;/code&gt;前缀的单引号或双引号表示：&lt;code&gt;x = b&#39;ABC&#39;&lt;/code&gt;，要注意区分&lt;code&gt;&#39;ABC&#39;&lt;/code&gt;和&lt;code&gt;b&#39;ABC&#39;&lt;/code&gt;，前者是&lt;code&gt;str&lt;/code&gt;，后者虽然内容显示得和前者一样，但&lt;code&gt;bytes&lt;/code&gt;的每个字符都只占用一个字节&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:3-ASCII&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:3-ASCII&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以 Unicode 表示的&lt;code&gt;str&lt;/code&gt;通过&lt;code&gt;encode()&lt;/code&gt;方法可以编码为指定的&lt;code&gt;bytes&lt;/code&gt;，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; &#39;ABC&#39;.encode(&#39;ascii&#39;)
b&#39;ABC&#39;
&amp;gt;&amp;gt;&amp;gt; &#39;中文&#39;.encode(&#39;utf-8&#39;)
b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;
&amp;gt;&amp;gt;&amp;gt; &#39;中文&#39;.encode(&#39;ascii&#39;)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
UnicodeEncodeError: &#39;ascii&#39; codec can&#39;t encode characters in position 0-1: ordinal not in range(128)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;纯英文的&lt;code&gt;str&lt;/code&gt;可以用 ASCII 编码为&lt;code&gt;bytes&lt;/code&gt;，内容是一样的，含有中文的&lt;code&gt;str&lt;/code&gt;可以用 UTF-8 编码为&lt;code&gt;bytes&lt;/code&gt;。含有中文的&lt;code&gt;str&lt;/code&gt;无法用 ASCII 编码，因为中文编码的范围超过了 ASCII 编码的范围，Python 会报错。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;bytes&lt;/code&gt;中，无法显示为 ASCII 字符的字节，用&lt;code&gt;\x##&lt;/code&gt;显示。&lt;/p&gt;

&lt;p&gt;反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是&lt;code&gt;bytes&lt;/code&gt;。要把&lt;code&gt;bytes&lt;/code&gt;变为&lt;code&gt;str&lt;/code&gt;，就需要用&lt;code&gt;decode()&lt;/code&gt;方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; b&#39;ABC&#39;.decode(&#39;ascii&#39;)
&#39;ABC&#39;
&amp;gt;&amp;gt;&amp;gt; b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;.decode(&#39;utf-8&#39;)
&#39;中文&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要计算 str 包含多少个字符，可以用&lt;code&gt;len()&lt;/code&gt;函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; len(&#39;ABC&#39;)
3
&amp;gt;&amp;gt;&amp;gt; len(&#39;中文&#39;)
2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;len()&lt;/code&gt;函数计算的是&lt;code&gt;str&lt;/code&gt;的&lt;strong&gt;字符&lt;/strong&gt;数，如果换成&lt;code&gt;bytes&lt;/code&gt;，&lt;code&gt;len()&lt;/code&gt;函数就计算&lt;strong&gt;字节&lt;/strong&gt;数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; len(b&#39;ABC&#39;)
3
&amp;gt;&amp;gt;&amp;gt; len(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)
6
&amp;gt;&amp;gt;&amp;gt; len(&#39;中文&#39;.encode(&#39;utf-8&#39;))
6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可见，1 个中文字符经过 UTF-8 编码后通常会占用 3 个字节，而 1 个英文字符只占用 1 个字节。&lt;/p&gt;

&lt;p&gt;在操作字符串时，我们经常遇到&lt;code&gt;str&lt;/code&gt;和&lt;code&gt;bytes&lt;/code&gt;的互相转换。为了避免乱码问题，应当始终坚持使用 UTF-8 编码对&lt;code&gt;str&lt;/code&gt;和&lt;code&gt;bytes&lt;/code&gt;进行转换。&lt;/p&gt;

&lt;h3 id=&#34;list-和-tuple&#34;&gt;List 和 tuple&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;list&lt;/strong&gt;：是一种&lt;code&gt;有序&lt;/code&gt;的集合，可以随时&lt;code&gt;添加[append, insert(i, value)]&lt;/code&gt;和&lt;code&gt;删除[pop, pop(i)]&lt;/code&gt;其中的元素，&lt;code&gt;list&lt;/code&gt;中的元素从&lt;code&gt;0&lt;/code&gt;号开始，其中&lt;code&gt;-1&lt;/code&gt;表示最后一个元素，索引越界时，会抛出&lt;code&gt;IndexError&lt;/code&gt;错误；&lt;code&gt;list&lt;/code&gt;可以作为另一个&lt;code&gt;list&lt;/code&gt;的元素，此时的访问方法是&lt;code&gt;myList[i][j]&lt;/code&gt;，初始的赋值用&lt;code&gt;classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;]&lt;/code&gt;完成，注意其中用的是&lt;code&gt;[]&lt;/code&gt;，之后操纵元素时用的是函数的&lt;code&gt;()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;tuple&lt;/strong&gt;：和&lt;code&gt;list&lt;/code&gt;非常类似，但是&lt;code&gt;tuple&lt;/code&gt;一旦初始化就不能&lt;del&gt;&lt;code&gt;修改&lt;/code&gt;&lt;/del&gt;，初始的赋值用&lt;code&gt;classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)&lt;/code&gt;完成，注意其中用的是&lt;code&gt;()&lt;/code&gt;，并且之后元素的不可&lt;del&gt;&lt;code&gt;改变&lt;/code&gt;&lt;/del&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:tuple-list-list&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:tuple-list-list&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;code&gt;tuple&lt;/code&gt;所谓的&lt;code&gt;不变&lt;/code&gt;是说，&lt;code&gt;tuple&lt;/code&gt;的每个元素，指向永远不变。即指向&lt;code&gt;&#39;a&#39;&lt;/code&gt;，就不能改成指向&lt;code&gt;&#39;b&#39;&lt;/code&gt;，指向一个&lt;code&gt;list&lt;/code&gt;，就不能改成指向其他对象，但指向的这个&lt;code&gt;list&lt;/code&gt;本身是可变的！&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;dict-和-list&#34;&gt;dict 和 list&lt;/h3&gt;

&lt;p&gt;注意&lt;code&gt;dict&lt;/code&gt;内部存放的顺序和&lt;code&gt;key&lt;/code&gt;放入的顺序没有关系。和&lt;code&gt;list&lt;/code&gt;比较，&lt;code&gt;dict&lt;/code&gt;有以下几个特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;查找和插入的速度极快，不会随着&lt;code&gt;key&lt;/code&gt;的增加而变慢；&lt;/li&gt;
&lt;li&gt;需要占用大量的内存，内存浪费多。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而&lt;code&gt;list&lt;/code&gt;相反，所以，&lt;code&gt;dict&lt;/code&gt;是用空间来换取时间的一种方法。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dict&lt;/code&gt;可以用在需要高速查找的很多地方，在 Python 代码中几乎无处不在，正确使用&lt;code&gt;dict&lt;/code&gt;非常重要，需要牢记的第一条就是&lt;code&gt;dict&lt;/code&gt;的&lt;code&gt;key&lt;/code&gt;必须是不可变对象。&lt;/p&gt;

&lt;h2 id=&#34;循环-判断&#34;&gt;循环、判断&lt;/h2&gt;

&lt;h3 id=&#34;if-语句&#34;&gt;if 语句&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;if &amp;lt;条件判断1&amp;gt;:
    &amp;lt;执行1&amp;gt;
elif &amp;lt;条件判断2&amp;gt;:
    &amp;lt;执行2&amp;gt;
elif &amp;lt;条件判断3&amp;gt;:
    &amp;lt;执行3&amp;gt;
else:
    &amp;lt;执行4&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;循环语句-for-和-while&#34;&gt;循环语句：for 和 while&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for...in&lt;/code&gt;循环，依次把&lt;code&gt;list&lt;/code&gt;或&lt;code&gt;tuple&lt;/code&gt;中的每个元素迭代出来&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sum = 0
for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
    sum = sum + x
print(sum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要计算 1-100 的整数之和，从 1 写到 100 有点困难，幸好 Python 提供一个&lt;code&gt;range()&lt;/code&gt;函数，可以生成一个整数序列，再通过&lt;code&gt;list()&lt;/code&gt;函数可以转换为&lt;code&gt;list&lt;/code&gt;。比如&lt;code&gt;range(5)&lt;/code&gt;生成的序列是从 0 开始小于 5 的整数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; list(range(5))
[0, 1, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;range(101)&lt;/code&gt;就可以生成 0-100 的整数序列，计算如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sum = 0
for x in range(101):
    sum = sum + x
print(sum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面的例子看业，&lt;code&gt;range()&lt;/code&gt;生成的序列，即使不转换成&lt;code&gt;list&lt;/code&gt;，也可以循环操作。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;while&lt;/code&gt;循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算 100 以内所有奇数之和，可以用 while 循环实现：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;sum = 0
n = 99
while n &amp;gt; 0:
    sum = sum + n
    n = n - 2
print(sum)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以用&lt;code&gt;break&lt;/code&gt;以及&lt;code&gt;continue&lt;/code&gt;跳出循环，有些时候，如果代码写得有问题，会让程序陷入&lt;strong&gt;死循环&lt;/strong&gt;，也就是永远循环下去。这时可以用&lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;C&lt;/kbd&gt;退出程序，或者强制结束 Python 进程。&lt;/p&gt;

&lt;h1 id=&#34;函数&#34;&gt;函数&lt;/h1&gt;

&lt;p&gt;内置函数列表：&lt;a href=&#34;https://docs.python.org/3/library/functions.html&#34; target=&#34;_blank&#34;&gt;https://docs.python.org/3/library/functions.html&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;类型转换&lt;/strong&gt;：&lt;code&gt;int()&lt;/code&gt;, &lt;code&gt;float()&lt;/code&gt;, &lt;code&gt;str()&lt;/code&gt;, &lt;code&gt;bool()&lt;/code&gt;, &lt;code&gt;hex()&lt;/code&gt;, &lt;code&gt;enumerate()&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:list-for&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:list-for&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;, &lt;code&gt;iter()&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:iterable-iterato&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:iterable-iterato&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;, &lt;code&gt;list()&lt;/code&gt;&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:iterator-iterabl&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:iterator-iterabl&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类型检查&lt;/strong&gt;：&lt;code&gt;isinstance(x, str)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是否包含关键字&lt;/strong&gt;：&lt;code&gt;in&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;定义函数&#34;&gt;定义函数&lt;/h2&gt;

&lt;p&gt;在 Python 中，定义一个函数要使用&lt;code&gt;def&lt;/code&gt;语句，依次写出函数名、括号、括号中的参数和冒号&lt;code&gt;:&lt;/code&gt;，然后，在缩进块中编写函数体，函数的返回值用&lt;code&gt;return&lt;/code&gt;语句返回。如果没有&lt;code&gt;return&lt;/code&gt;语句，函数执行完毕后也会返回结果，只是结果为&lt;code&gt;None&lt;/code&gt;。&lt;code&gt;return None&lt;/code&gt;可以简写为&lt;code&gt;return&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def my_abs(x):
    if x &amp;gt;= 0:
        return x
    else:
        return -x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果已经把&lt;code&gt;my_abs()&lt;/code&gt;的函数定义保存为&lt;code&gt;abstest.py&lt;/code&gt;文件了，那么，可以在该文件的当前目录下启动 Python 解释器，用&lt;code&gt;from abstest import my_abs&lt;/code&gt;来导入&lt;code&gt;my_abs()&lt;/code&gt;函数，注意&lt;code&gt;abstest&lt;/code&gt;是文件名（不含&lt;code&gt;.py&lt;/code&gt;扩展名）。&lt;/p&gt;

&lt;h2 id=&#34;更稳健的函数&#34;&gt;更稳健的函数&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;空函数&lt;/strong&gt;：如果想定义一个什么事也不做的空函数，可以用&lt;code&gt;pass&lt;/code&gt;语句。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def nop():
    pass
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;参数检查&lt;/strong&gt;：调用函数时，如果参数个数不对，Python 解释器会自动检查出来，并抛出&lt;code&gt;TypeError&lt;/code&gt;，但是如果参数类型不对，Python 解释器就无法帮我们检查。数据类型检查可以用内置函数&lt;code&gt;isinstance()&lt;/code&gt;实现。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def my_abs(x):
    if not isinstance(x, (int, float)):
        raise TypeError(&#39;bad operand type&#39;)
    if x &amp;gt;= 0:
        return x
    else:
        return -x
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;返回多个值&lt;/strong&gt;：返回值是一个&lt;code&gt;tuple&lt;/code&gt;！但是，在语法上，返回一个&lt;code&gt;tuple&lt;/code&gt;可以省略括号，而多个变量可以同时接收一个&lt;code&gt;tuple&lt;/code&gt;，按位置赋给对应的值，所以，Python 的函数返回多值其实就是返回一个&lt;code&gt;tuple&lt;/code&gt;，但写起来更方便。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import math

def move(x, y, step, angle=0):
    nx = x + step * math.cos(angle)
    ny = y - step * math.sin(angle)
    return nx, ny

&amp;gt;&amp;gt;&amp;gt; x, y = move(100, 100, 60, math.pi / 6)
&amp;gt;&amp;gt;&amp;gt; print(x, y)
151.96152422706632 70.0

&amp;gt;&amp;gt;&amp;gt; r = move(100, 100, 60, math.pi / 6)
&amp;gt;&amp;gt;&amp;gt; print(r)
(151.96152422706632, 70.0)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;函数的参数&#34;&gt;函数的参数&lt;/h2&gt;

&lt;p&gt;Python 的函数定义非常简单，但灵活度却非常大。除了正常定义的&lt;strong&gt;必选参数&lt;/strong&gt;外，还可以使用&lt;strong&gt;默认参数&lt;/strong&gt;、&lt;strong&gt;可变参数&lt;/strong&gt;、&lt;strong&gt;关键字参数&lt;/strong&gt;和&lt;strong&gt;命名关键字参数&lt;/strong&gt;，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。下面是关于函数参数的一些重要规则的总结：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;默认参数必须指向不变对象；&lt;/li&gt;
&lt;li&gt;可变参数内部是&lt;code&gt;()-tuple&lt;/code&gt;，关键字参数内部是&lt;code&gt;{}-dict&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;可变参数在语法上是&lt;code&gt;*&lt;/code&gt;，关键字参数是&lt;code&gt;**&lt;/code&gt;，命名关键字参数是&lt;code&gt;单独的 *&lt;/code&gt;，如果有可变参数，则命名关键字参数不再需要单独的使用特殊分隔符&lt;code&gt;*&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;可变参数本身调用时，参数可以是&lt;code&gt;list-()&lt;/code&gt;或&lt;code&gt;tuple-[]&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;对于任意函数，都可以通过类似&lt;code&gt;func(*args, **kw)&lt;/code&gt;的形式调用它，无论它的参数是如何定义的，但是这种做法容易引起混淆，不推荐；&lt;/li&gt;
&lt;li&gt;参数定义的顺序必须是：&lt;code&gt;必选参数&lt;/code&gt;、&lt;code&gt;默认参数&lt;/code&gt;、&lt;code&gt;可变参数&lt;/code&gt;、&lt;code&gt;命名关键字参数&lt;/code&gt;和&lt;code&gt;关键字参数&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;默认参数-必须指向不变对象&#34;&gt;默认参数(必须指向不变对象)&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def power(x, n=2):
    s = 1
    while n &amp;gt; 0:
        n = n - 1
        s = s * x
    return s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;必选参数在前，默认参数在后，否则 Python 的解释器会报错；当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。&lt;/p&gt;

&lt;p&gt;默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用&lt;code&gt;enroll(&#39;Bob&#39;, &#39;M&#39;, 7)&lt;/code&gt;，意思是，除了&lt;code&gt;name&lt;/code&gt;，&lt;code&gt;gender&lt;/code&gt;这两个参数外，最后 1 个参数应用在参数&lt;code&gt;age&lt;/code&gt;上，&lt;code&gt;city&lt;/code&gt;参数由于没有提供，仍然使用默认值。也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用&lt;code&gt;enroll(&#39;Adam&#39;, &#39;M&#39;, city=&#39;Tianjin&#39;)&lt;/code&gt;，意思是，&lt;code&gt;city&lt;/code&gt;参数用传进去的值，其他默认参数继续使用默认值。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;警告&lt;/strong&gt;：默认参数很有用，但使用不当，会有很大的麻烦。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;下面的例子先定义一个函数，传入一个&lt;code&gt;list&lt;/code&gt;，添加一个&lt;code&gt;&#39;END&#39;&lt;/code&gt;再返回：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add_end(L=[]):
    L.append(&#39;END&#39;)
    return L
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;正常调用时，结果似乎不错：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; add_end([1, 2, 3])
[1, 2, 3, &#39;END&#39;]
&amp;gt;&amp;gt;&amp;gt; add_end([&#39;x&#39;, &#39;y&#39;, &#39;z&#39;])
[&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;END&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用默认参数调用时，一开始结果也是对的：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; add_end()
[&#39;END&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，再次调用&lt;code&gt;add_end()&lt;/code&gt;时，结果就不对了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; add_end()
[&#39;END&#39;, &#39;END&#39;]
&amp;gt;&amp;gt;&amp;gt; add_end()
[&#39;END&#39;, &#39;END&#39;, &#39;END&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;默认参数是&lt;code&gt;[]&lt;/code&gt;，但是函数似乎每次都&lt;strong&gt;记住了&lt;/strong&gt;上次添加了&lt;code&gt;&#39;END&#39;&lt;/code&gt;后的&lt;code&gt;list&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;原因是 Python 函数在定义的时候，默认参数&lt;code&gt;L&lt;/code&gt;的值就被计算出来了，即&lt;code&gt;[]&lt;/code&gt;，因为默认参数&lt;code&gt;L&lt;/code&gt;也是一个变量，它指向对象&lt;code&gt;[]&lt;/code&gt;，每次调用该函数，如果改变了&lt;code&gt;L&lt;/code&gt;的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的&lt;code&gt;[]&lt;/code&gt;了。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提醒：&lt;/strong&gt;默认参数必须指向不变对象！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要修改上面的例子，我们可以用&lt;code&gt;None&lt;/code&gt;这个不变对象来实现：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def add_end(L=None):
    if L is None:
        L = []
    L.append(&#39;END&#39;)
    return L
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在，无论调用多少次，都不会有问题：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; add_end()
[&#39;END&#39;]
&amp;gt;&amp;gt;&amp;gt; add_end()
[&#39;END&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为什么要设计&lt;code&gt;str&lt;/code&gt;、&lt;code&gt;None&lt;/code&gt;这样的&lt;strong&gt;不变对象&lt;/strong&gt;呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。&lt;/p&gt;

&lt;h3 id=&#34;可变参数-函数内部为-tuple-定义和引用都可以用&#34;&gt;可变参数(函数内部为 tuple，定义和引用都可以用 *)&lt;/h3&gt;

&lt;p&gt;要定义出这种函数，必须确定输入的参数。由于参数个数不确定，首先想到可以把&lt;code&gt;a&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;，&lt;code&gt;c&lt;/code&gt;……作为一个&lt;code&gt;list&lt;/code&gt;或&lt;code&gt;tuple&lt;/code&gt;传进来，但是调用的时候，需要先组装出一个&lt;code&gt;list&lt;/code&gt;或&lt;code&gt;tuple&lt;/code&gt;，如果利用可变参数，调用函数的方式可以简化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def calc(*numbers):
    sum = 0
    for n in numbers:
        sum = sum + n * n
    return sum
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义可变参数和定义一个&lt;code&gt;list&lt;/code&gt;或&lt;code&gt;tuple&lt;/code&gt;参数相比，仅仅在参数前面加了一个&lt;code&gt;*&lt;/code&gt;号。在函数内部，参数&lt;code&gt;numbers&lt;/code&gt;接收到的是一个&lt;code&gt;tuple&lt;/code&gt;，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括 0 个参数。如果已经有一个&lt;code&gt;list&lt;/code&gt;或者&lt;code&gt;tuple&lt;/code&gt;，可以将其中的元素一个一个传递给可变参数函数，但是太繁琐，所以 Python 允许在&lt;code&gt;list&lt;/code&gt;或&lt;code&gt;tuple&lt;/code&gt;前面加一个&lt;code&gt;*&lt;/code&gt;号，把&lt;code&gt;list&lt;/code&gt;或&lt;code&gt;tuple&lt;/code&gt;的元素变成可变参数传进去，这种写法相当有用，而且很常见。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; nums = [1, 2, 3]
&amp;gt;&amp;gt;&amp;gt; calc(*nums)
14
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;关键字参数-函数内部为-dict-定义和引用都可以用&#34;&gt;关键字参数(函数内部为 dict，定义和引用都可以用 **)&lt;/h3&gt;

&lt;p&gt;可变参数允许你传入 0 个或任意个参数，这些可变参数在函数调用时自动组装为一个&lt;code&gt;tuple&lt;/code&gt;。而关键字参数允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个&lt;code&gt;dict&lt;/code&gt;。请看示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def person(name, age, **kw):
    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数&lt;code&gt;person&lt;/code&gt;除了必选参数&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;age&lt;/code&gt;外，还接受关键字参数&lt;code&gt;kw&lt;/code&gt;。在调用该函数时，可以只传入必选参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; person(&#39;Michael&#39;, 30)
name: Michael age: 30 other: {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以传入任意个数的关键字参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; person(&#39;Bob&#39;, 35, city=&#39;Beijing&#39;)
name: Bob age: 35 other: {&#39;city&#39;: &#39;Beijing&#39;}
&amp;gt;&amp;gt;&amp;gt; person(&#39;Adam&#39;, 45, gender=&#39;M&#39;, job=&#39;Engineer&#39;)
name: Adam age: 45 other: {&#39;gender&#39;: &#39;M&#39;, &#39;job&#39;: &#39;Engineer&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关键字参数有什么用？它可以&lt;code&gt;扩展函数的功能&lt;/code&gt;。比如，在&lt;code&gt;person&lt;/code&gt;函数里，我们保证能接收到&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;age&lt;/code&gt;这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。&lt;/p&gt;

&lt;p&gt;和可变参数类似，也可以先组装出一个&lt;code&gt;dict&lt;/code&gt;，然后，把该&lt;code&gt;dict&lt;/code&gt;转换为关键字参数传进去：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; extra = {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}
&amp;gt;&amp;gt;&amp;gt; person(&#39;Jack&#39;, 24, city=extra[&#39;city&#39;], job=extra[&#39;job&#39;])
name: Jack age: 24 other: {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，上面复杂的调用可以用简化的写法&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:dict-dict&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:dict-dict&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; extra = {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}
&amp;gt;&amp;gt;&amp;gt; person(&#39;Jack&#39;, 24, **extra)
name: Jack age: 24 other: {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;**extra&lt;/code&gt;表示把&lt;code&gt;extra&lt;/code&gt;这个&lt;code&gt;dict&lt;/code&gt;的所有&lt;code&gt;key-value&lt;/code&gt;用关键字参数传入到函数的&lt;code&gt;**kw&lt;/code&gt;参数，&lt;code&gt;kw&lt;/code&gt;将获得一个&lt;code&gt;dict&lt;/code&gt;，注意&lt;code&gt;kw&lt;/code&gt;获得的&lt;code&gt;dict&lt;/code&gt;是&lt;code&gt;extra&lt;/code&gt;的一份拷贝，对&lt;code&gt;kw&lt;/code&gt;的改动不会影响到函数外的&lt;code&gt;extra&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;命名关键字参数-限制参数名称-单独的&#34;&gt;命名关键字参数(限制参数名称，单独的 *)&lt;/h3&gt;

&lt;p&gt;对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过&lt;code&gt;kw&lt;/code&gt;检查。&lt;/p&gt;

&lt;p&gt;仍以&lt;code&gt;person()&lt;/code&gt;函数为例，我们希望检查是否有&lt;code&gt;city&lt;/code&gt;和&lt;code&gt;job&lt;/code&gt;参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;// 这种做法更灵活
def person(name, age, **kw):
    if &#39;city&#39; in kw:
        # 有city参数
        pass
    if &#39;job&#39; in kw:
        # 有job参数
        pass
    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是调用者仍可以传入&lt;code&gt;不受限制&lt;/code&gt;的关键字参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; person(&#39;Jack&#39;, 24, city=&#39;Beijing&#39;, addr=&#39;Chaoyang&#39;, zipcode=123456)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收&lt;code&gt;city&lt;/code&gt;和&lt;code&gt;job&lt;/code&gt;作为关键字参数。这种方式定义的函数如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;// 这种做法更严谨
def person(name, age, *, city, job):
    print(name, age, city, job)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;：和关键字参数&lt;code&gt;**kw&lt;/code&gt;不同，命名关键字参数需要一个特殊分隔符&lt;code&gt;*&lt;/code&gt;，&lt;code&gt;*&lt;/code&gt;后面的参数被视为命名关键字参数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;调用方式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; person(&#39;Jack&#39;, 24, city=&#39;Beijing&#39;, job=&#39;Engineer&#39;)
Jack 24 Beijing Engineer
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;：如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符&lt;code&gt;*&lt;/code&gt;了：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def person(name, age, *args, city, job):
    print(name, age, args, city, job)
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;警告&lt;/strong&gt;：命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; person(&#39;Jack&#39;, 24, &#39;Beijing&#39;, &#39;Engineer&#39;)
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: person() takes 2 positional arguments but 4 were given
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于调用时缺少参数名&lt;code&gt;city&lt;/code&gt;和&lt;code&gt;job&lt;/code&gt;，Python 解释器把这 4 个参数均视为位置参数，但&lt;code&gt;person()&lt;/code&gt;函数仅接受 2 个位置参数。&lt;/p&gt;

&lt;p&gt;命名关键字参数可以有缺省值，从而简化调用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def person(name, age, *, city=&#39;Beijing&#39;, job):
    print(name, age, city, job)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由于命名关键字参数&lt;code&gt;city&lt;/code&gt;具有默认值，调用时，可不传入&lt;code&gt;city&lt;/code&gt;参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; person(&#39;Jack&#39;, 24, job=&#39;Engineer&#39;)
Jack 24 Beijing Engineer
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个&lt;code&gt;*&lt;/code&gt;作为特殊分隔符。如果缺少&lt;code&gt;*&lt;/code&gt;，Python 解释器将无法识别位置参数和命名关键字参数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def person(name, age, city, job):
    # 缺少 *，city和job被视为位置参数
    pass
````

### 不同类型参数的优先级

&amp;gt; **提示**：在 Python 中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这 5 种参数都可以组合使用。但是请注意，参数定义的顺序必须是：`必选参数`、`默认参数`、`可变参数`、`命名关键字参数`和`关键字参数`。

比如定义一个函数，包含上述若干种参数：

```python
def f1(a, b, c=0, *args, **kw):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;args =&#39;, args, &#39;kw =&#39;, kw)

def f2(a, b, c=0, *, d, **kw):
    print(&#39;a =&#39;, a, &#39;b =&#39;, b, &#39;c =&#39;, c, &#39;d =&#39;, d, &#39;kw =&#39;, kw)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在函数调用的时候，Python 解释器自动按照参数位置和参数名把对应的参数传进去。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; f1(1, 2)
a = 1 b = 2 c = 0 args = () kw = {}
&amp;gt;&amp;gt;&amp;gt; f1(1, 2, c=3)
a = 1 b = 2 c = 3 args = () kw = {}
&amp;gt;&amp;gt;&amp;gt; f1(1, 2, 3, &#39;a&#39;, &#39;b&#39;)
a = 1 b = 2 c = 3 args = (&#39;a&#39;, &#39;b&#39;) kw = {}
    // 这里是直接一个一个参数的传递

&amp;gt;&amp;gt;&amp;gt; f1(1, 2, 3, &#39;a&#39;, &#39;b&#39;, x=99)
a = 1 b = 2 c = 3 args = (&#39;a&#39;, &#39;b&#39;) kw = {&#39;x&#39;: 99}
&amp;gt;&amp;gt;&amp;gt; f2(1, 2, d=99, ext=None)
a = 1 b = 2 c = 0 d = 99 kw = {&#39;ext&#39;: None}
    // c 用默认值，d 对应可变参数, ext 对应关键字参数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最神奇的是通过一个&lt;code&gt;tuple&lt;/code&gt;和&lt;code&gt;dict&lt;/code&gt;，你也可以调用上述函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; args = (1, 2, 3, 4)
&amp;gt;&amp;gt;&amp;gt; kw = {&#39;d&#39;: 99, &#39;x&#39;: &#39;#&#39;}
&amp;gt;&amp;gt;&amp;gt; f1(*args, **kw)
a = 1 b = 2 c = 3 args = (4,) kw = {&#39;d&#39;: 99, &#39;x&#39;: &#39;#&#39;}
    // 直接用 list 或 tuple 作为参数
    // 注意 args = (4,) 后面有一个逗号，(4) 对应一个数 4，而 (4, ) 才对应只有一个元素 4 的 tuple

&amp;gt;&amp;gt;&amp;gt; args = (1, 2, 3)
&amp;gt;&amp;gt;&amp;gt; kw = {&#39;d&#39;: 88, &#39;x&#39;: &#39;#&#39;}
&amp;gt;&amp;gt;&amp;gt; f2(*args, **kw)
a = 1 b = 2 c = 3 d = 88 kw = {&#39;x&#39;: &#39;#&#39;}
    // 这里的 args 和 kw 不是直接对应 * 和 **
    // 而是要先满足必选参数的 1,2,3，之后再用 kw 的第一项满足可变参数
    // 最后用 kw 的第二项满足关键字参数
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，对于任意函数，都可以通过类似&lt;code&gt;func(*args, **kw)&lt;/code&gt;的形式调用它，无论它的参数是如何定义的&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:-&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:-&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;h2 id=&#34;递归&#34;&gt;递归&lt;/h2&gt;

&lt;p&gt;教程上说用尾递归的方法可以避免栈溢出，但 Python 也没有提供针对尾递归的优化，考虑到平时用的很少，并且尾递归代码的写法比较麻烦&lt;sup class=&#34;footnote-ref&#34; id=&#34;fnref:return&#34;&gt;&lt;a rel=&#34;footnote&#34; href=&#34;#fn:return&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;，所以干脆不要使用。&lt;/p&gt;

&lt;h1 id=&#34;高级特性&#34;&gt;高级特性&lt;/h1&gt;

&lt;h2 id=&#34;切片&#34;&gt;切片&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L[0:3]
&amp;gt;&amp;gt;&amp;gt; L[:3]            // 取前 3 个元素

&amp;gt;&amp;gt;&amp;gt; L[1:3]           // 取 1, 2 号元素，0 号不取
&amp;gt;&amp;gt;&amp;gt; L[:10:2]         // 前 10 个元素，每两个取 1 个
&amp;gt;&amp;gt;&amp;gt; L[::5]           // 所有数，每5个取一个
&amp;gt;&amp;gt;&amp;gt; [:]              // 复制

&amp;gt;&amp;gt;&amp;gt; L[-1]            // 取倒数第一个元素
&amp;gt;&amp;gt;&amp;gt; L[-2:-1]         // 取最后两个元素
&amp;gt;&amp;gt;&amp;gt; L[-10:]          // 取最后 10 个元素

&amp;gt;&amp;gt;&amp;gt; &#39;ABCDEFG&#39;[:3]    // 字符串也可以视作一个 list
&#39;ABC&#39;
&amp;gt;&amp;gt;&amp;gt; &#39;ABCDEFG&#39;[::2]
&#39;ACEG&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;迭代&#34;&gt;迭代&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;通常用&lt;code&gt;for ... in&lt;/code&gt;完成迭代；&lt;/li&gt;
&lt;li&gt;默认情况下，&lt;code&gt;dict&lt;/code&gt;迭代的是&lt;code&gt;key&lt;/code&gt;。如果要迭代&lt;code&gt;value&lt;/code&gt;，可以用&lt;code&gt;for value in d.values()&lt;/code&gt;，如果要同时迭代&lt;code&gt;key&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;，可以用&lt;code&gt;for k, v in d.items()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;字符串也是可迭代对象，因此，也可以作用于&lt;code&gt;for&lt;/code&gt;循环；&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;collections&lt;/code&gt;模块的&lt;code&gt;Iterable&lt;/code&gt;类型判断一个对象是可迭代对象；&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; from collections import Iterable
&amp;gt;&amp;gt;&amp;gt; isinstance(&#39;abc&#39;, Iterable) # str是否可迭代
True
&amp;gt;&amp;gt;&amp;gt; isinstance([1,2,3], Iterable) # list是否可迭代
True
&amp;gt;&amp;gt;&amp;gt; isinstance(123, Iterable) # 整数是否可迭代
False
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;可以同时引用了两个变量；&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; for x, y in [(1, 1), (2, 4), (3, 9)]:
...     print(x, y)
...
1 1
2 4
3 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;要对&lt;code&gt;list&lt;/code&gt;实现类似 Java 那样的下标循环，Python 内置的&lt;code&gt;enumerate()&lt;/code&gt;函数可以把一个&lt;code&gt;list&lt;/code&gt;变成&lt;code&gt;索引-元素对&lt;/code&gt;，这样就可以在&lt;code&gt;for&lt;/code&gt;循环中同时迭代索引和元素本身；&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):
...     print(i, value)
...
0 A
1 B
2 C
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;list-生成器&#34;&gt;list 生成器&lt;/h2&gt;

&lt;h3 id=&#34;静态-list&#34;&gt;静态 list&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11)]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

&amp;gt;&amp;gt;&amp;gt; [x * x for x in range(1, 11) if x % 2 == 0]         // 用 if 后，只输出偶数的平方
[4, 16, 36, 64, 100]

&amp;gt;&amp;gt;&amp;gt; [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]
[&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;]  // 使用两层循环，可以生成全排列

&amp;gt;&amp;gt;&amp;gt; import os                                           // 导入 os 模块，模块的概念后面讲到
&amp;gt;&amp;gt;&amp;gt; [d for d in os.listdir(&#39;.&#39;)]                        // os.listdir 可以列出文件和目录
[&#39;.emacs.d&#39;, &#39;.ssh&#39;, &#39;.Trash&#39;, &#39;Desktop&#39;, &#39;Documents&#39;, &#39;Downloads&#39;, &#39;Library&#39;, &#39;VirtualBox VMs&#39;]

&amp;gt;&amp;gt;&amp;gt; d = {&#39;x&#39;: &#39;A&#39;, &#39;y&#39;: &#39;B&#39;, &#39;z&#39;: &#39;C&#39; }                 // 使用两个变量来生成 list
&amp;gt;&amp;gt;&amp;gt; [k + &#39;=&#39; + v for k, v in d.items()]
[&#39;y=B&#39;, &#39;x=A&#39;, &#39;z=C&#39;]

&amp;gt;&amp;gt;&amp;gt; L = [&#39;Hello&#39;, &#39;World&#39;, &#39;IBM&#39;, &#39;Apple&#39;]              // 把一个 list 中所有的字符串变成小写
&amp;gt;&amp;gt;&amp;gt; [s.lower() for s in L]
[&#39;hello&#39;, &#39;world&#39;, &#39;ibm&#39;, &#39;apple&#39;]

&amp;gt;&amp;gt;&amp;gt; L = [&#39;Hello&#39;, &#39;World&#39;, 18, &#39;Apple&#39;, None]           // 非字符串类型没有 lower() 方法，列表生成式会报错
&amp;gt;&amp;gt;&amp;gt; [s.lower() for s in L]
Traceback (most recent call last):
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
  File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;listcomp&amp;gt;
AttributeError: &#39;int&#39; object has no attribute &#39;lower&#39;

&amp;gt;&amp;gt;&amp;gt; x = &#39;abc&#39;                                           // 用内建 isinstance 函数可判断变量是否为字符串
&amp;gt;&amp;gt;&amp;gt; y = 123
&amp;gt;&amp;gt;&amp;gt; isinstance(x, str)
True
&amp;gt;&amp;gt;&amp;gt; isinstance(y, str)
False

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;动态-list-generator&#34;&gt;动态 list：generator&lt;/h3&gt;

&lt;p&gt;通过静态 list 生成式，我们可以直接创建一个&lt;code&gt;list&lt;/code&gt;。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含 100 万个元素的列表，会占用很大的存储空间，如果仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。&lt;/p&gt;

&lt;p&gt;所以，如果&lt;code&gt;list&lt;/code&gt;中的元素可以按照某种算法推算出来，就不必创建完整的&lt;code&gt;list&lt;/code&gt;，从而节省大量的空间。在 Python 中，这种一边循环一边计算的机制，称为生成器：&lt;strong&gt;generator&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;方法1&lt;/strong&gt;(&lt;code&gt;()&lt;/code&gt;)：要创建一个&lt;code&gt;generator&lt;/code&gt;，把一个列表生成式的&lt;code&gt;[]&lt;/code&gt;改成&lt;code&gt;()&lt;/code&gt;，就创建了一个&lt;code&gt;generator&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; L = [x * x for x in range(10)]          // list
&amp;gt;&amp;gt;&amp;gt; L
[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
&amp;gt;&amp;gt;&amp;gt; g = (x * x for x in range(10))          // generator
&amp;gt;&amp;gt;&amp;gt; g                                       // 元素无法直接输出
&amp;lt;generator object &amp;lt;genexpr&amp;gt; at 0x1022ef630&amp;gt;

&amp;gt;&amp;gt;&amp;gt; next(g)                                 // 使用 next() 才能依次输出元素
0
&amp;gt;&amp;gt;&amp;gt; next(g)
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不断调用&lt;code&gt;next(g)&lt;/code&gt;并不可行，正确的方法是使用&lt;code&gt;for&lt;/code&gt;循环，因为&lt;code&gt;generator&lt;/code&gt;也是可迭代对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; g = (x * x for x in range(10))
&amp;gt;&amp;gt;&amp;gt; for n in g:
...     print(n)
... 
0
1
4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;方法2&lt;/strong&gt;(&lt;code&gt;yield&lt;/code&gt;)：如果推算的算法比较复杂，用类似列表生成式的&lt;code&gt;for&lt;/code&gt;循环无法实现的时候，可以用函数来实现。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fib(max):
    n, a, b = 0, 0, 1
    while n &amp;lt; max:
        print(b)
        a, b = b, a + b
        n = n + 1
    return &#39;done&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意其中的&lt;code&gt;a, b = b, a + b&lt;/code&gt;相当于：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;t = (b, a + b) # t 是一个 tuple
a = t[0]
b = t[1]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但不必显式写出临时变量&lt;code&gt;t&lt;/code&gt;就可以赋值，另外这里&lt;code&gt;t&lt;/code&gt;只是临时的，所以应该不涉及 tuple 不能修改的问题。可以看出，&lt;code&gt;fib()&lt;/code&gt;函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似&lt;code&gt;generator&lt;/code&gt;。也就是说，上面的函数和&lt;code&gt;generator&lt;/code&gt;仅一步之遥。把&lt;code&gt;fib()&lt;/code&gt;函数变成&lt;code&gt;generator&lt;/code&gt;，只需要把&lt;code&gt;print(b)&lt;/code&gt;改为&lt;code&gt;yield b&lt;/code&gt;就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def fib(max):
    n, a, b = 0, 0, 1
    while n &amp;lt; max:
        yield b
        a, b = b, a + b
        n = n + 1
    return &#39;done&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单来讲，如果一个函数定义中包含&lt;code&gt;yield&lt;/code&gt;关键字，那么这个函数就不再是一个普通函数，而是一个&lt;code&gt;generator&lt;/code&gt;。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;警告&lt;/strong&gt;：用&lt;code&gt;for&lt;/code&gt;循环调用&lt;code&gt;generator&lt;/code&gt;时，得不到&lt;code&gt;generator&lt;/code&gt;的&lt;code&gt;return&lt;/code&gt;语句的返回值。如果想要得到返回值，必须捕获&lt;code&gt;StopIteration&lt;/code&gt;错误，返回值包含在&lt;code&gt;StopIteration&lt;/code&gt;的&lt;code&gt;value&lt;/code&gt;中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; g = fib(6)
&amp;gt;&amp;gt;&amp;gt; while True:
...     try:
...         x = next(g)
...         print(&#39;g:&#39;, x)
...     except StopIteration as e:
...         print(&#39;Generator return value:&#39;, e.value)
...         break
...
g: 1
g: 1
g: 2
g: 3
g: 5
g: 8
Generator return value: done
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;迭代器&#34;&gt;迭代器&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Iterable&lt;/strong&gt;：可以直接用&lt;code&gt;for&lt;/code&gt;循环的对象统称为可&lt;strong&gt;迭代对象&lt;/strong&gt;，&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;tuple&lt;/code&gt;、&lt;code&gt;dict&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;str&lt;/code&gt;等都可以用&lt;code&gt;for&lt;/code&gt;遍历；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Iterator&lt;/strong&gt;：可以被&lt;code&gt;next()&lt;/code&gt;函数调用并不断返回下一个值的对象称为&lt;strong&gt;迭代器&lt;/strong&gt;，方法 1 和方法 2 中用&lt;code&gt;generator&lt;/code&gt;生成的都可以用&lt;code&gt;next()&lt;/code&gt;操作；&lt;/li&gt;
&lt;li&gt;可以使用&lt;code&gt;isinstance()&lt;/code&gt;判断一个对象是否是&lt;code&gt;Iterable&lt;/code&gt;对象或者&lt;code&gt;Iterator&lt;/code&gt;对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;dict&lt;/code&gt;、&lt;code&gt;str&lt;/code&gt;虽然&lt;code&gt;Iterable&lt;/code&gt;，却不是&lt;code&gt;Iterator&lt;/code&gt;，把&lt;code&gt;list&lt;/code&gt;、&lt;code&gt;dict&lt;/code&gt;、&lt;code&gt;str&lt;/code&gt;等&lt;code&gt;Iterable&lt;/code&gt;变成&lt;code&gt;Iterator&lt;/code&gt;可以使用&lt;code&gt;iter()&lt;/code&gt;函数：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; isinstance(iter([]), Iterator)
True
&amp;gt;&amp;gt;&amp;gt; isinstance(iter(&#39;abc&#39;), Iterator)
True
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Python 的 Iterator 对象表示的是一个&lt;strong&gt;数据流&lt;/strong&gt;，Iterator 对象可以被&lt;code&gt;next()&lt;/code&gt;函数调用并不断返回下一个数据，直到没有数据时抛出&lt;code&gt;StopIteration&lt;/code&gt;错误。可以把这个数据流看做是一个&lt;code&gt;有序序列&lt;/code&gt;，但我们却不能提前知道序列的长度，只能不断通过&lt;code&gt;next()&lt;/code&gt;函数实现按需计算下一个数据，所以 Iterator 的计算是&lt;strong&gt;惰性&lt;/strong&gt;的，只有在需要返回下一个数据时它才会计算。Iterator 甚至可以表示一个&lt;code&gt;无限大&lt;/code&gt;的数据流，例如&lt;code&gt;全体自然数&lt;/code&gt;。而使用&lt;code&gt;list&lt;/code&gt;是永远不可能存储全体自然数的。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34;&gt;

&lt;hr /&gt;

&lt;ol&gt;
&lt;li id=&#34;fn:tuple-myTuple-1&#34;&gt;空&lt;code&gt;tuple&lt;/code&gt;的定义在语法上要用&lt;code&gt;myTuple(1,)&lt;/code&gt;这样的方式，否则用&lt;code&gt;myTuple(1)&lt;/code&gt;则认为是 一个元素为&lt;code&gt;1&lt;/code&gt;的一维&lt;code&gt;tuple&lt;/code&gt;，具体可参考教程说明。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:tuple-myTuple-1&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:3-ASCII&#34;&gt;这地方稍有歧义，汉字是 3 个字节，但对应于一个字符，因此这种解释只适用于 ASCII 范围内的符号。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:3-ASCII&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:tuple-list-list&#34;&gt;虽然&lt;code&gt;tuple&lt;/code&gt;指向的元素不可改变，但如果其中一个元素是可以改变的&lt;code&gt;list&lt;/code&gt;，那么可以通过改变&lt;code&gt;list&lt;/code&gt;中元素的内容来达到修改&lt;code&gt;tuple&lt;/code&gt;内容的目的，具体参考&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014316724772904521142196b74a3f8abf93d8e97c6ee6000&#34; target=&#34;_blank&#34;&gt;使用&lt;code&gt;list&lt;/code&gt;和&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt;。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:tuple-list-list&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:list-for&#34;&gt;把一个&lt;code&gt;list&lt;/code&gt;变成&lt;code&gt;索引-元素对&lt;/code&gt;，这样就可以在&lt;code&gt;for&lt;/code&gt;循环中同时迭代索引和元素本身。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:list-for&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:iterable-iterato&#34;&gt;将&lt;code&gt;iterable&lt;/code&gt;转换成&lt;code&gt;iterator&lt;/code&gt;。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:iterable-iterato&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:iterator-iterabl&#34;&gt;将一个惰性的&lt;code&gt;iterator&lt;/code&gt;转换成一个确定的&lt;code&gt;iterable&lt;/code&gt;型的&lt;code&gt;list&lt;/code&gt;。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:iterator-iterabl&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:dict-dict&#34;&gt;虽然将一个&lt;code&gt;dict&lt;/code&gt;作为参数传递给函数也是可行的，但这样做在函数内部就需要再将&lt;code&gt;dict&lt;/code&gt;一个一个单独进行额外处理，而&lt;code&gt;**&lt;/code&gt;的方法可以省略这个步骤。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:dict-dict&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:-&#34;&gt;这种做法容易引起混淆，个人&lt;del&gt;&lt;code&gt;不太推荐&lt;/code&gt;&lt;/del&gt;。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:-&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;li id=&#34;fn:return&#34;&gt;&lt;strong&gt;尾递归&lt;/strong&gt;是指，在函数返回的时候，调用自身本身，并且，&lt;code&gt;return&lt;/code&gt;语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。 &lt;a class=&#34;footnote-return&#34; href=&#34;#fnref:return&#34;&gt;↩&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>LaTeX 如何在文档的侧面插入图片实现“绕排” z</title>
      <link>/tech/2017/06/12/wrap-figure/</link>
      <pubDate>Mon, 12 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/06/12/wrap-figure/</guid>
      <description>
        

&lt;p&gt;&lt;strong&gt;参考资料&lt;/strong&gt;：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.zhihu.com/question/26837705&#34; target=&#34;_blank&#34;&gt;https://www.zhihu.com/question/26837705&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://tex.stackexchange.com/questions/56176/handling-of-wrapfig-pictures-in-latex&#34; target=&#34;_blank&#34;&gt;https://tex.stackexchange.com/questions/56176/handling-of-wrapfig-pictures-in-latex&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;买了我书的读者，请看 5.3.5 节「文字绕排」。&lt;/p&gt;

&lt;p&gt;本质上绕排功能都是通过在 TeX 中使用 &lt;code&gt;\parshape&lt;/code&gt; 命令控制段落形状，挖出一个空洞出来，然后把图表内容填进去来完成的。Knuth 排版 TAOCP 就都是手工完成这种绕排工作的。不过手工完成这种工作非常繁琐，在 LaTeX 中通常还是使用现成的宏包工具。&lt;/p&gt;

&lt;h1 id=&#34;主要宏包&#34;&gt;主要宏包&lt;/h1&gt;

&lt;p&gt;实现文字绕排工具很多，效果各有千秋。按当前版本的时间顺序排是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;picins&lt;/code&gt;：1992 年 3.0 版，早于 LaTeX2e，因许可证问题现已从 TeXLive 中删除，MiKTeX 仍可用；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;picinpar&lt;/code&gt;：1993 年 1.2a 版，早于 LaTeX2e；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;floatflt&lt;/code&gt;：1997 年 1.31 版，最早版本发布于 1994 年，LaTeX2e 代码；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wrapfig&lt;/code&gt;：2003 年 3.6 版，最早版本发布于 1991 年，现为 LaTeX2e 代码；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cutwin&lt;/code&gt;：2010 年 0.1 版，LaTeX2e 代码。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为什么会有这么多宏包？因为绕排问题复杂，要求繁多，并没有哪一个宏包能在各方面完美地解决文字绕排的问题。所以多少需要选着用。&lt;/p&gt;

&lt;p&gt;各个宏包的其本用法可以看各自的手册，但注意 &lt;code&gt;picins&lt;/code&gt; 的手册是一个文本文件，而 &lt;code&gt;picinpar&lt;/code&gt; 的手册要看德文版 pdf（看例子）配合源代码里面的注释。其中 &lt;code&gt;picins&lt;/code&gt;、&lt;code&gt;picinpar&lt;/code&gt;、&lt;code&gt;wrapfig&lt;/code&gt; 的一个集中（但有些过时）的介绍可以看《LaTeX2e 插图指南》的一节：&lt;a href=&#34;http://www.ctex.org/documents/latex/graphics/node114.html&#34; target=&#34;_blank&#34;&gt;30. 图文混排&lt;/a&gt;。&lt;/p&gt;

&lt;h1 id=&#34;功能差异&#34;&gt;功能差异&lt;/h1&gt;

&lt;p&gt;我们忽略掉在 TeX Live 下无法使用的老宏包 &lt;code&gt;picins&lt;/code&gt;，下面主要考虑一些功能上的差别：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wrapfig&lt;/code&gt; 代码较新，语法与标准的 &lt;code&gt;figure&lt;/code&gt; 环境接近，基本功能比较全面，可以指定宽度高度也可以自动计算，可以设置伸出版心。此外在页面放不下时还有浮动到下一段的功能（这块儿我的书写错了）。但位置限定较多，一般只用在段落开头，图片出现在段落（包括连续几段）的左上角或右上角。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;picinpar&lt;/code&gt; 位置灵活，水平方向和垂直方向都可以放在一段的中间。但语法比较怪异，也不能直接指定内容大小。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;floatflt&lt;/code&gt; 功能和语法都与 &lt;code&gt;wrapfig&lt;/code&gt; 接近，但可以控制的参数更少。它的特色是对列表 &lt;code&gt;\item&lt;/code&gt; 项有特殊处理，并且对奇偶页面可以有不同的位置处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cutwin&lt;/code&gt; 的特色是对位置的控制最强，不仅可以把图片放在段落的各种不对称位置，而且还支持特殊形状的挖洞，可以自己定义三角形、圆形之类的空洞来放置特殊的图片。但 &lt;code&gt;cutwin&lt;/code&gt; 语法麻烦，在其他方面的功能也较弱，比如 &lt;code&gt;cutwin&lt;/code&gt; 就没有提供 &lt;code&gt;\caption&lt;/code&gt; 功能，只提供了基本的挖洞功能。所以如果有图表标题又不想自己实现，就不要选 &lt;code&gt;cutwin&lt;/code&gt; 宏包。而 &lt;code&gt;picins&lt;/code&gt;、&lt;code&gt;picinpar&lt;/code&gt;、&lt;code&gt;floatflt&lt;/code&gt;、&lt;code&gt;wrapfig&lt;/code&gt; 都支持图表标题，并且有 &lt;code&gt;caption&lt;/code&gt; 宏包支持。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;选用小结&#34;&gt;选用小结&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;在需求简单的情况下，使用 &lt;code&gt;wrapfig&lt;/code&gt; 或 &lt;code&gt;floatflt&lt;/code&gt; 就可以满足要求，优先选择功能多的 &lt;code&gt;wrapfig&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;如果对插入图表的位置有特殊要求，用 &lt;code&gt;picinpar&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;如果对位置或形状有较高要求，用 &lt;code&gt;cutwin&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&#34;示例&#34;&gt;示例&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/LaTeX/wrap-figure.jpg&#34; alt=&#34;图文绕排示例&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;\documentclass{article}

\usepackage{graphicx}

\usepackage{wrapfig}
\usepackage{picinpar}
\usepackage{cutwin}

\begin{document}

\section{wrapfig}

\begin{wrapfigure}{l}[1cm]{0pt}
\includegraphics[width=3cm]{example-image-a}
\caption{wrapfig}
\end{wrapfigure}
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text

\section{picinpar}

\begin{figwindow}[2,c,
  {\includegraphics[width=3cm]{example-image-b}},
  picinpar]
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
\end{figwindow}

\section{cutwin}

\renewcommand{\windowpagestuff}{%
  \quad\includegraphics[width=3cm]{example-image-c}}
\begin{cutout}{2}{2.2cm}{6.2cm}{6}
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
text text text text text text text text text text text text
\end{cutout}

\end{document}
&lt;/code&gt;&lt;/pre&gt;

        
      </description>
    </item>
    
    <item>
      <title>随机数生成及其在统计模拟中的应用 z</title>
      <link>/prof/2017/05/26/random-number-generation/</link>
      <pubDate>Fri, 26 May 2017 00:00:00 +0000</pubDate>
      
      <guid>/prof/2017/05/26/random-number-generation/</guid>
      <description>
        &lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;a href=&#34;https://cosx.org/2017/05/random-number-generation/&#34; class=&#34;uri&#34;&gt;https://cosx.org/2017/05/random-number-generation/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;揭秘统计软件如 R，Octave，Matlab 等使用的随机数发生器，然后做一些统计检验，再将其应用到独立随机变量和的模拟中，最后与符号计算得到的精确结果比较。除特别说明外，文中涉及到的随机数都是指伪随机数，发生器都是指随机数发生器。&lt;/p&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; 背景&lt;/h1&gt;
&lt;p&gt;随机数的产生和检验方法是蒙特卡罗方法的重要部分，另外两个是概率分布抽样方法和降低方差提高效率方法。在 20 世纪 40 年代中期，当时为了原子弹的研制，乌拉姆（S.Ulam）、冯诺依曼（J.von Neumann） 和梅特罗波利斯（N. Metropolis） 在美国核武器研究实验室创立蒙特卡罗方法。当时出于保密的需要，与随机模拟相关的技术就代号“蒙特卡罗”。早期取得的成果有产生随机数的平方取中方法，取舍算法和逆变换法等。这两个算法的内容&lt;a href=&#34;http://cos.name/2015/06/generating-normal-distr-variates/&#34;&gt;见统计之都王夜笙的文章&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;2&lt;/span&gt; 随机数生成&lt;/h1&gt;
&lt;p&gt;讲随机数发生器，不得不提及一个名为 Mersenne Twister（简称 MT）的发生器，它的周期长达&lt;code&gt;$2^{19937}-1$&lt;/code&gt;， 现在是 R 、Octave 和 Matlab 等软件（较新版本）的默认随机数发生器&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Matlab 通过内置的 &lt;code&gt;rng&lt;/code&gt; 函数指定不同的发生器，其中包括 1995 年 Matlab 采用 George Marsaglia 在 1991 年提出的借位减（subtract with borrow，简称 SWB）发生器。在 Matlab 中，设置如下命令可指定发生器及其状态，其中 &lt;code&gt;1234&lt;/code&gt; 是随机数种子，指定发生器的状态，目的是重复实验结果，v5uniform 是发生器的名字。&lt;/p&gt;
&lt;pre class=&#34;matlab&#34;&gt;&lt;code&gt;rng(1234, &amp;#39;v5uniform&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Octave 通过内置的 &lt;code&gt;rand&lt;/code&gt; 函数指定发生器的不同状态，为获取相同的两组随机数，&lt;code&gt;state&lt;/code&gt; 参数的设置一样，如 &lt;code&gt;1234&lt;/code&gt;（你也可以设置为别的值）。Octave 已经放弃了老版本内置的发生器，找不到命令去指定早期的发生器，这个和 Matlab 不一样。&lt;/p&gt;
&lt;pre class=&#34;octave&#34;&gt;&lt;code&gt;rand (&amp;#39;state&amp;#39;,1234)
rand(1,5)

   0.9664535   0.4407326   0.0074915   0.9109760   0.9392690

rand (&amp;#39;state&amp;#39;,1234)
rand(1,5)

   0.9664535   0.4407326   0.0074915   0.9109760   0.9392690&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Python 的 &lt;code&gt;numpy&lt;/code&gt; 模块也采用 MT 发生器，类似地，通过如下方式获得相同的两组随机数&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import numpy as np
a = np.random.RandomState(1234)
a.rand(5)
array([ 0.19151945,  0.62210877,  0.43772774,  0.78535858,  0.77997581])

a = np.random.RandomState(1234)
a.rand(5)
array([ 0.19151945,  0.62210877,  0.43772774,  0.78535858,  0.77997581])&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;R 的默认发生器也是 MT 发生器，除了设置随机数种子的 seed 参数，还可以通过 &lt;code&gt;kind&lt;/code&gt; 参数指定其他发生器，&lt;code&gt;normal.kind&lt;/code&gt; 参数指定产生正态分布随机数的发生器，下面也使用类似的方式产生两组完全一样的随机数。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(seed, kind = NULL, normal.kind = NULL)
set.seed(1234,kind = &amp;quot;Mersenne-Twister&amp;quot;, normal.kind =  &amp;quot;Inversion&amp;quot;) # 默认参数设置
runif(5)
[1] 0.1137034 0.6222994 0.6092747 0.6233794 0.8609154

set.seed(1234,kind = &amp;quot;Mersenne-Twister&amp;quot;, normal.kind =  &amp;quot;Inversion&amp;quot;) # 默认参数设置
runif(5)
[1] 0.1137034 0.6222994 0.6092747 0.6233794 0.8609154&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;SWB 发生器中“借位相减”步骤是指序列的第 &lt;span class=&#34;math inline&#34;&gt;\(i\)&lt;/span&gt; 个随机数&lt;code&gt;$z_{i}$&lt;/code&gt;要依据如下递推关系产生，&lt;code&gt;$$z_{i}=z_{i+20}-z_{i+5}-b$$&lt;/code&gt; 下标&lt;code&gt;$i,i+20,i+5$&lt;/code&gt;都是对 32 取模的结果，&lt;code&gt;$z_{i+20}$&lt;/code&gt;与&lt;code&gt;$z_{i+5}$&lt;/code&gt;做减法运算，&lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 是借位，其取值与前一步有关，当&lt;code&gt;$z_i$&lt;/code&gt;是正值时，下一步将 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 置为 0，如果计算的&lt;code&gt;$z_i$&lt;/code&gt;是负值，在保存&lt;code&gt;$z_i$&lt;/code&gt;之前，将其值加 1，并在下一步，将 &lt;span class=&#34;math inline&#34;&gt;\(b\)&lt;/span&gt; 的值设为&lt;code&gt;$2^{-53}$&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面关于随机数生成的效率和后面的统计检验，都以生成&lt;code&gt;$2^{24}$&lt;/code&gt;个为基准，是 1600 多万个，取这么多，一方面为了比较编程语言实现的发生器产生随机数的效率，另一方面是后面的游程检验需要比较大的样本量。&lt;/p&gt;
&lt;p&gt;Matlab 内置的发生器及大部分的函数，底层实现都是 C 或者 Fortran，MathWorks 创始人 &lt;a href=&#34;https://www.wikiwand.com/en/Cleve_Moler&#34;&gt;Cleve B. Moler&lt;/a&gt; 是数值分析领域著名的 LINPACK 和 EISPACK 包的作者之一，他当年做了很多优化和封装，进而推出 Matlab，只要是调用内置函数，效率不会比 C 差，自己写的含有循环、判断等语句的代码，性能就因人而异了，对大多数人来说，性能要比 C 低。这里比较 Matlab 内置SWB发生器（就当作是 C 语言实现的好了）和用 Matlab 重写的 SWB 发生器的效率，代码如下：&lt;/p&gt;
&lt;pre class=&#34;matlab&#34;&gt;&lt;code&gt;% matlab code
tic % 大约几秒
rng(1234, &amp;#39;v5uniform&amp;#39;) % 调用SWB发生器
x = rand(1,2^24);
toc&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;octave&#34;&gt;&lt;code&gt;% octave code
id = tic % 时间耗费大约一小时
randtx(&amp;#39;state&amp;#39;,0)
x = randtx(1,2^24);
toc (id)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://www.mathworks.com/moler/chapters.html&#34;&gt;randtx&lt;/a&gt;不是 Matlab 和 Octave 内置的函数，而是 Cleve B. Moler 基于 Matlab 实现的 SWB 发生器，也是 100 多行包含嵌套循环等语句的 Matlab 代码打包的函数，上面的代码运行时间差异之大也就不难理解了，为了能在 Octave 上跑，我做了少量修改，Octave 软件版本为 4.2.1，安装 Octave 时，Blas 选择 OpenBlas，为了后续检验，在获得随机数后，将其保存到磁盘文件 &lt;code&gt;random_number.mat&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;octave&#34;&gt;&lt;code&gt;save -mat random_number.mat x &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;R，Octave，Matlab 和 Python 内置的发生器都是 MT 发生器，与之实现有关的数学库，也是 Blas，虽然有开源和进一步优化的商业版本之分，但是矩阵乘法，向量乘法之类运算的效率也就半斤八两，Julia 语言官网给出了一个&lt;a href=&#34;https://julialang.org/&#34;&gt;标准测试&lt;/a&gt;&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;img src=&#34;/images/Stat/random-number-generation/1.png&#34; alt=&#34;不同语言性能&#34; /&gt;
&lt;p style=&#34;text-align: center;&#34;&gt;
不同语言的性能表现（C 语言在算法中的表现为基准，时间记为 1.0）
&lt;/p&gt;
&lt;p&gt;这里再给出用C语言实现的 &lt;a href=&#34;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt64.html&#34;&gt;MT 发生器&lt;/a&gt;，产生同样多的随机数，只需要 10 秒左右，其中包含编译和写随机数到文件的时间，实际产生随机数的时间应该远小于这个时间。（程序运行环境环境 Dev-C++ 5.11，用 64 位的 GCC 编译）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;3&lt;/span&gt; 统计检验&lt;/h1&gt;
&lt;p&gt;随机数的检验是有一套标准的，如 George Marsaglia 开发的 DieHard 检验程序，检验的内容很丰富。这篇文章只能算初窥门径，R 内产生真随机数的包是 &lt;a href=&#34;http://dirk.eddelbuettel.com/&#34;&gt;Dirk Eddelbuettel&lt;/a&gt; 开发的 &lt;a href=&#34;https://cran.r-project.org/web/packages/random/&#34;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;包，它是连接产生&lt;a href=&#34;https://www.random.org/&#34;&gt;真随机数网站&lt;/a&gt;的接口。&lt;/p&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.1&lt;/span&gt; 相关性检验&lt;/h2&gt;
&lt;p&gt;先来一个简单的，就用 R 产生的两个独立同均匀分布样本，调用 &lt;code&gt;cor.test&lt;/code&gt; 做相关性检验，看看这两组数是不是足够独立同分布，通过眼球验证，随着样本量增大，相关性趋于 0，相关性弱到可以视为独立。如下图所示&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggplot2)
library(viridisLite)
library(viridis)
set.seed(1234)
corr &amp;lt;- rep(0, 1000) 
for(i in seq(from = 1000, to = 1000000, by = 1000)) {  
    corr[i/1000] &amp;lt;-  cor.test(runif(i, min = 0, max = 1),                            
        runif(i, min = 0, max = 1))$estimate} 
ggplot(data.frame(x = seq(1000), y = corr), aes(x = x, y = y)) +   
    geom_hex(show.legend = FALSE) + 
    scale_fill_viridis(direction = -1) + xlab(&amp;quot;Sample size *10^3&amp;quot;) + ylab(&amp;quot;Correlation&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Stat/random-number-generation/2.png&#34; alt=&#34;image&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.2&lt;/span&gt; 分布检验&lt;/h2&gt;
&lt;p&gt;检验产生的随机数是否服从指定的分布：原假设是样本来自指定的分布，计算的 P 值比较大，就不能拒绝原假设。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ks.test(runif(1000), &amp;quot;punif&amp;quot;) # 分布检验
##
## One-sample Kolmogorov-Smirnov test
##
## data: runif(1000)
## D = 0.022302, p-value = 0.7025
## alternative hypothesis: two-sided&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;检验两样本是否来自同一分布：原假设是两样本来自同一分布，计算的P值比较小，就表示两样本不是来自同一分布。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ks.test(runif(1000), runif(1000)) # 同分布检验
##
## Two-sample Kolmogorov-Smirnov test
##
## data: runif(1000) and runif(1000)
## D = 0.04, p-value = 0.4005
## alternative hypothesis: two-sided&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从结果来看，&lt;em&gt;R&lt;/em&gt;内置的随机数发生器通过了检验（嘿嘿，这是肯定的！！）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;3.3&lt;/span&gt; 游程检验&lt;/h2&gt;
&lt;p&gt;游程检验对随机数序列的随机性检验，不对序列做任何分布假设，不同于上面的相关性检验和省略没讲的特征统计量（如均值和方差）的检验。先对随机性略作解释，简单起见，我们考虑 0-1 序列，抛掷均匀的硬币 1000 次，正面向上记为 1，反面向上记为 0，这是一个离散的均匀分布，每一次抛掷硬币都无法准确地判断出现的是正面还是反面，若记录的序列中 0 和 1 相对集中的出现，不是随机，0 和 1 交替出现，呈现周期性也不是随机，除了这两种情况基本就是随机了。&lt;/p&gt;
&lt;p&gt;游程检验的原假设是序列满足随机性，序列一旦生成，就是有序的，因为游程检验需要固定位置，再数上升（下降）的游程数，当计算的 P 值比较大时，不能拒绝原假设，即不能否认这个序列是随机的。对上述 0-1 序列进行模拟，然后检验，如下所示&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tseries)
x &amp;lt;- sample(c(0, 1), 1000, replace = TRUE, prob = c(1/2, 1/2))
runs.test(factor(x))
##
## Runs Test
##
## data: factor(x)
## Standard Normal = 0.45116, p-value = 0.6519
## alternative hypothesis: two.sided&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在用游程检验比较 SWB 发生器（Octave/Matlab 版）、MT 发生器（R 语言版）和 MT 发生器（C 语言版）。对于一般的实数序列，得先指定一个阈值，记为 delta，然后比较序列中的值和 delta 的大小关系，这里类似数上升或下降的游程长度（runs length），基于这样一个事实：如果序列表现随机，则序列中两个小于 delta 的值，间隔越远出现的次数越少。可以这样理解，还是以上面抛硬币的例子来说，出现了很多次正面，那么下一次抛掷倾向于出现反面，这是一条人人可接受的经验。&lt;/p&gt;
&lt;p&gt;为了把这条经验可视化出来，对序列做如下操作：先给定阈值 delta 为 0.01（也可以取别的值），取出序列中的值小于 delta 的位置，位置序列前面添加 0，再差分，然后每个值减 1，得到新序列，新序列中的值为 0，表明原序列连续两个值小于 delta，新序列中的值为1，表明间隔 1 个数小于 delta，新序列中的值为 2，表明间隔 2 个数小于 delta，依次类推…..统计所有的情况，用直方图显示，这就获得游程长度与间隔的关系图（间隔数取到 100 足可示意）。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(gridExtra)
library(R.matlab)
# 游程频数直方图
run_test_fun &amp;lt;- function(x, string, delta) {
  n &amp;lt;- length(x)
  len &amp;lt;- diff(c(0, which(x &amp;lt; delta), n + 1)) - 1 
  ggplot(data.frame(x = len[len &amp;lt; 101]), aes(x, fill = ..count..)) + 
    scale_fill_viridis(direction = -1) + 
    geom_histogram(binwidth = 1, show.legend = FALSE) + 
    xlab(string) + ylab(&amp;quot;&amp;quot;) 
}
set.seed(1234) # R默认采用Mersenne Twister发生器
r_data &amp;lt;- runif(2^24, 0, 1); # R内生成均匀分布随机数
matlabv5_data &amp;lt;- readMat(&amp;quot;random_number.mat&amp;quot;) # 读取Octave生成的均匀分布随机数
temp &amp;lt;- read.table(file = &amp;quot;random_number.txt&amp;quot;) # 读取C语言生成的均匀分布随机数 
c_data &amp;lt;- c(as.matrix(t(temp)))
p1 &amp;lt;- run_test_fun(x = r_data, string = &amp;quot;R&amp;quot;, delta = 0.01)
p2 &amp;lt;- run_test_fun(x = matlabv5_data$x, string = &amp;quot;Matlab v5&amp;quot;, delta = 0.01)
p3 &amp;lt;- run_test_fun(x = c_data, string = &amp;quot;C&amp;quot;, delta = 0.01)
grid.arrange(p1, p2, p3, ncol=3)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Stat/random-number-generation/3.png&#34; alt=&#34;image&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;从图中可以看出 MT 发生器通过了检验，SWT 发生器没有通过，在间隔数为 27 的位置，有一条沟，按规律游程长度不应该减少这么多，这是因为 SWB 发生器“借位减”步骤，取模 32 的运算和 5 一起消耗了间隔为 27 的数量（读者可以按借位减的递推关系思考是如何消耗的），导致不符合随机性的要求，该算法细节参见 &lt;a href=&#34;https://www.wikiwand.com/en/Cleve_Moler&#34;&gt;Cleve B. Moler&lt;/a&gt;的书《Numerical Computing with MATLAB》&lt;a href=&#34;https://www.mathworks.com/moler/chapters.html&#34;&gt;第 9 章第 267 页&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;4&lt;/span&gt; 应用&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.1&lt;/span&gt; 两个均匀分布的统计模拟&lt;/h2&gt;
&lt;p&gt;随机变量 &lt;code&gt;$X_{1},X_{2}\stackrel{iid}{\sim}$&lt;/code&gt;某分布（比如二项分布，泊松分布，正态分布，指数分布，卡方分布，伽马分布），则&lt;code&gt;$X_{1}+X_{2}$&lt;/code&gt;也服从该分布。常见的均匀分布是否具有这样的可加性？具体地说，就是&lt;code&gt;$X_{1},X_{2}\stackrel{iid}{\sim}U(0,1)$&lt;/code&gt; ，&lt;code&gt;$X_{1}+X_{2}$&lt;/code&gt; 是否服从&lt;code&gt;$U(0,2)$&lt;/code&gt; ？ 如果有一台电脑在旁边，我首先想到的就是敲三五行代码，画个散点图、直方图，看图说话。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1234) 
x &amp;lt;- runif(10000, min = 0, max = 1) 
y &amp;lt;- runif(10000, min = 0, max = 1) 
z &amp;lt;- x + y
plot(z) # 散点图
hist(z) # 直方图&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为美观起见，从 &lt;a href=&#34;https://cran.r-project.org/web/packages/viridis/index.html&#34;&gt;viridis 包&lt;/a&gt;调用 viridis 调色板，颜色越深的地方，相应的数值越大，不管是此处 &lt;code&gt;geom_hex&lt;/code&gt; 绘制的六角形热图，还是 &lt;code&gt;geom_histogram&lt;/code&gt; 绘制的直方图，都遵循这个规律。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ggplot(data.frame(x = seq(10000), y = z), aes(x = x, y = y)) +   
    geom_hex(show.legend = FALSE) + 
    scale_fill_viridis(direction = -1) + xlab(&amp;quot;&amp;quot;) + ylab(&amp;quot;&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Stat/random-number-generation/4.png&#34; alt=&#34;image&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;显然这不是均匀分布，在 &lt;code&gt;$z=1$&lt;/code&gt; 处，散点比较集中，看起来有点像正态分布。如果往中心极限定理上靠，将作如下标准化&lt;code&gt;$$Y_{2}^{\star}=\frac{X_1 + X_2 - 2*\frac{1}{2}}{\sqrt{\frac{1}{12}}*\sqrt{2}}=\sqrt{6}(X_1 + X_2 -1)$$&lt;/code&gt; 则&lt;code&gt;$Y_{2}^{\star}$&lt;/code&gt;的期望为 0，方差为 1。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p4 &amp;lt;- ggplot(data.frame(x = z), aes(x, fill = ..count..)) +     
    scale_fill_viridis(direction = -1) +     
    geom_histogram(bins=20, show.legend = FALSE) + xlab(&amp;quot;&amp;quot;) + ylab(&amp;quot;&amp;quot;)  
p5 &amp;lt;- ggplot(data.frame(x = sqrt(6)*(z-1)), aes(x, fill = ..count..)) +     
    scale_fill_viridis(direction = -1) +     
    geom_histogram(bins = 20, show.legend = FALSE) + xlab(&amp;quot;&amp;quot;) + ylab(&amp;quot;&amp;quot;)  
grid.arrange(p4, p5, ncol=2)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Stat/random-number-generation/5.png&#34; alt=&#34;image&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;只是变换后的图像和之前基本一致，那么现在看来眼球检验不好使了，那就上&lt;code&gt;$P$&lt;/code&gt;值呗！&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ks.test(sqrt(6)*(z-1), &amp;quot;pnorm&amp;quot;) # 分布检验
##
## One-sample Kolmogorov-Smirnov test
##
## data: sqrt(6) * (z - 1)
## D = 0.025778, p-value = 3.381e-06
## alternative hypothesis: two-sided&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也不是正态分布，既然如此，那就在两个随机变量的情况下，把精确分布推导出来。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;4.2&lt;/span&gt; 精确分布的推导及计算&lt;/h2&gt;
&lt;p&gt;课本如《概率论与数理统计教程》 采用卷积的方法求分布函数，这种方法实行起来比较繁琐，也不利于后续编程，下面考虑用特征函数的方法求。我们知道标准均匀分布的特征函数&lt;code&gt;$$\varphi(t)=\frac{e^{it}-1}{it}$$&lt;/code&gt;考虑&lt;code&gt;$X_1$&lt;/code&gt;和&lt;code&gt;$X_2$&lt;/code&gt;相互独立，它们的和用&lt;code&gt;$S_2$&lt;/code&gt;表示，则随机变量&lt;code&gt;$S_2$&lt;/code&gt;的特征函数为 &lt;code&gt;$$\varphi_2(t)=\varphi(t)*\varphi(t)=(\frac{e^{it}-1}{it})^2=\frac{2(1-\cos(t))e^{it}}{t^2}$$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;只要满足条件&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$$\int_{-\infty}^{+\infty}\vert \varphi_2(t) \vert \mathrm{d} t &amp;lt; \infty$$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$S_2$&lt;/code&gt;的密度函数就可以表示为&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$$p_2(x)=\frac{1}{2 \pi}\int_{-\infty}^{+\infty}\mathrm{e}^{-itx}\varphi_2(t)\mathrm{d}t$$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;经计算 &lt;code&gt;$$\int_{-\infty}^{+\infty}\vert \varphi_2(t) \vert \mathrm{d} t=4\int_{0}^{+\infty}\frac{1-\cos(t)}{t^2}\mathrm{d}t=4\int_{0}^{+\infty}\big(\frac{\sin(x)}{x}\big)^2\mathrm{d}x=2\pi$$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;那么 &lt;code&gt;$$p_2(x)=\frac{1}{2 \pi}\int_{-\infty}^{+\infty}\mathrm{e}^{-itx}\varphi_2(t)\mathrm{d}t=\frac{2}{\pi}\int_{0}^{+\infty}\frac{(1-\cos(t))\cos(t(1-x))}{t^2}\mathrm{d}t=\frac{2}{\pi}\int_{0}^{+\infty}\cos\big(2(1-x)t\big)\big(\frac{\sin(t)}{t}\big)^2\mathrm{d}t$$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一般地，&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 个独立随机变量的和&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$$\varphi_n(t)=\big(\frac{e^{it}-1}{it}\big)^n=\big(\frac{\sin(t/2)\mathrm{e}^{\frac{it}{2}}}{t/2}\big)^n$$&lt;/code&gt; 那么，同理 &lt;code&gt;$$p_n(x)=\frac{2}{\pi}\int_{0}^{+\infty}\cos\big(2(n/2-x)t\big)(\frac{\sin(t)}{t})^n\mathrm{d}t$$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要说数值计算一个&lt;code&gt;$p(x)$&lt;/code&gt;近似值，是一点问题没有！且看&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;integrate(function(t,x,n) 2/pi*cos((n-2*x)*t)*(sin(t)/t)^n ,x = 1,n = 2,
            lower = 0,upper = Inf,subdivisions = 1000) 
## 0.9999846 with absolute error &amp;lt; 6.6e-05          &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那如果要把上面的积分积出来，获得一个精确的表达式，在&lt;code&gt;$n=2$&lt;/code&gt;的时候还可以手动计算，主要使用分部积分，余弦积化和差公式和一个狄利克雷积分公式&lt;code&gt;$\int_{0}^{+\infty}\frac{\sin(ax)}{x}\mathrm{d}x=\frac{\pi}{2}\mathrm{sgn}(a)$&lt;/code&gt;，过程略，最后算得&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$$p_2(x)=\frac{1}{2}\big((2-x)\mathrm{sgn}(2-x)-x\mathrm{sgn}(-x)\big)-(1-x)\mathrm{sgn}(1-x)=\frac{1}{2}(\left | x \right |+\left | x-2 \right |)-\left | x-1 \right |,0&amp;lt;x&amp;lt;2$$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$p_2(x)$&lt;/code&gt;的密度函数图象如下：&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fun_p2_1 &amp;lt;- function(x) { 1 / 2 * (abs(x - 2) - 2 * abs(x - 1) + abs(x)) }
fun_p2_2 &amp;lt;- function(x) { 
    x &amp;lt;- as.matrix(x)
    tempfun &amp;lt;- function(x) {
        integrate(function(t, x, n) 2 / pi * cos((n - 2 * x) * t) * (sin(t) / t) ^ n,
            x = x, n = 2,lower = 0, upper = Inf, subdivisions = 1000)$value
    }
   return( sapply(x,tempfun) )
}
ggplot(data.frame(x = c(0, 2)), aes(x = x)) +
    stat_function(fun = fun_p2_2, geom = &amp;quot;point&amp;quot;, colour = &amp;quot;#2A768EFF&amp;quot;) +
    stat_function(fun = fun_p2_1, geom = &amp;quot;line&amp;quot;, colour = &amp;quot;#78D152FF&amp;quot;) &lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Stat/random-number-generation/6.png&#34; alt=&#34;image&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;从图中可以看出，两种形式的密度函数在数值计算的结果上很一致，当 &lt;code&gt;$n=100,1000$&lt;/code&gt; 时，含参量积分的表示形式就很方便啦！任意给定一个 &lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt;，符号计算上面的含参量积分，这个时候还是用软件计算比较合适，R 的符号计算仅限于求导，积分运算需要借助 &lt;code&gt;Ryacas&lt;/code&gt;，&lt;code&gt;rSymPy&lt;/code&gt;，可惜的是，这些包更新缓慢，即使 &lt;code&gt;$\int_{0}^{+\infty}\frac{\sin(at)}{t}\mathrm{d}t$&lt;/code&gt; 也算不出来，果断直接使用 Python 的 &lt;code&gt;sympy&lt;/code&gt; 模块&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;from sympy import * 
a=symbols(&amp;#39;a&amp;#39;, real = True)
t=symbols(&amp;#39;t&amp;#39;, real = True, positive = True)
print(integrate(sin(a*t)/t, (t, 0, oo)))

## Piecewise((pi/2, Eq(Abs(periodic_argument(polar_lift(a)**2, oo)), 0)), (Integral(sin(a*t)/t, (t, 0, oo)), True))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;。。。初次见到这样的结果，是不是一脸mb，翻译一下，就是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$$ \begin{equation*} \begin{cases}  \frac{\pi}{2} &amp;amp; \text{for}\: \left|{\operatorname{periodic_{argument}}{\left (\operatorname{polar\_lift}^{2}{\left (a \right )},\infty \right )}}\right| = 0 \\ \int\limits_{0}^{\infty} \frac{1}{t} \sin{\left (a t \right )}\, dt &amp;amp; \text{otherwise} \end{cases} \end{equation*} $$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;稍为好点，但是还是有一大块看不懂，那个绝对值里是什么&lt;a href=&#34;#fn3&#34; class=&#34;footnoteRef&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;？还是不要纠结了，路远坑多，慢走不送啊！话说要是计算&lt;code&gt;$p_2(x)$&lt;/code&gt;密度函数里的积分，&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;from sympy import * 
x=symbols(&amp;#39;x&amp;#39;, real=True)
t=symbols(&amp;#39;t&amp;#39;, real=True,positive=True)
print(integrate(2/pi*cos(2*t*(1-x))*(sin(t)/t)**2,(t,0,oo)))

## Piecewise((Piecewise((2*x, (2*x - 2)**2/4 &amp;lt; 1), (0, 4/(2*x - 2)**2 &amp;lt; 1), (meijerg(((1/2,), (1, 1, 3/2)), ((1/2, 1, 0), (1/2,)), polar_lift(-2*x + 2)**2/4), True))/2, Eq(Abs(periodic_argument(polar_lift(-2*x + 2)**2, oo)), 0)), (Integral(2*sin(t)**2*cos(2*t*(-x + 1))/(pi*t**2), (t, 0, oo)), True))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那就更长了。。。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$$ \begin{equation*} \begin{cases}  \frac{1}{2} \begin{cases}  2 x &amp;amp; \text{for}\: \frac{1}{4} \left(2 x - 2\right)^{2} &amp;lt; 1 \\ 0 &amp;amp; \text{for}\: \frac{4}{\left(2 x - 2\right)^{2}} &amp;lt; 1 \\ {G_{4, 4}^{3, 1}\left(\begin{matrix} \frac{1}{2} &amp;amp; 1, 1, \frac{3}{2} \\\frac{1}{2}, 1, 0 &amp;amp; \frac{1}{2} \end{matrix} \middle| {\frac{1}{4} \operatorname{polar\_lift}^{2}{\left (- 2 x + 2 \right )}} \right)} &amp;amp; \text{otherwise} \end{cases} &amp;amp; \text{for}\: \left|{\operatorname{periodic_{argument}}{\left (\operatorname{polar\_lift}^{2}{\left (- 2 x + 2 \right )},\infty \right )}}\right| = 0 \\ \int\limits_{0}^{\infty} \frac{2}{\pi t^{2}} \sin^{2}{\left (t \right )} \cos{\left (2 t \left(- x + 1\right) \right )}\, dt &amp;amp; \text{otherwise}  \end{cases} \end{equation*} $$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sympy&lt;/code&gt; 模块还是比较强的，化简可能比较弱，感觉是我的条件声明没有充分利用，要看懂，得知道一些复变函数的知识，这个时候，可以试试 Maple 或者 Mathematica，面对高昂的费用，我们可以使用在线的免费计算 WolframAlpha（&lt;a href=&#34;http://www.wolframalpha.com/&#34; class=&#34;uri&#34;&gt;http://www.wolframalpha.com/&lt;/a&gt;），输入&lt;/p&gt;
&lt;pre class=&#34;mathematica&#34;&gt;&lt;code&gt;integrate 2/pi*cos(2*t*(1-x))*(sin(t)/t)^2 ,t ,0,oo&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即可得&lt;code&gt;$p_2(x)=\frac{1}{2}(\left | x-2 \right |-2\left | x-1 \right |+\left | x \right |)$&lt;/code&gt;，&lt;span class=&#34;math inline&#34;&gt;\(n\)&lt;/span&gt; 取任意值都是可以算的，由于式子比较复杂，就不展示了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;5&lt;/span&gt; 小结&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;作者的一些经验感悟:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;因为看论文的原因（感觉 MCMC 好像哪都有），接着从随机数生成开始自学 MCMC，一次偶然的机会，去年在北京计算科学研究中心听清华喻文健教授的报告，提到均匀分布的随机数检验，中间也出现了这个图，现在已经记不得是喻教授因为时间原因，没细讲背后的原因，还是自己没听懂，总之只觉得挺有意思的（涉及统计中的游程检验，周围基本都是工科学生，我想我听的更明白些），就记下来，在听报告之前，囫囵地看了康崇禄写的《蒙特卡罗方法理论和应用》的前两章（前两章故事比较多因此看完了），这本书没讲那个例子，却把背后的原因讲明白了（后来细看才知道的）。错位相减算法曾出现在 Matlab，自然就去读 Cleve B. Moler 写的《Numerical Computing with MATLAB》(Revised in 2013)，这本书在文中有出现，也介绍了 Matlab 这么多年内置的随机数发生器的变化史。其实还是推荐看康崇禄那本，不仅因为故事多，而且内容全面和透彻，可以挑自己需要和感兴趣的部分读，也不拘泥于 Matlab。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;关于应用部分的举例，源于面试，陷于教材，钟于符号计算。这部分涉及一本广为人知的教材《概率论与数理统计教程》（第二版）茆诗松、程依明和濮晓龙著，这本书给了用卷积求独立随机变量和的例子，后面讲特征函数，说它在求独立随机变量和有优势，但是没有举例，所以正好是补充，而且意外地简洁和统一。符号计算获得精确结果是为了和数值计算的结果比较，之前在统计之都的投名状就是符号计算与 R 语言，但是没有提及 Python 的 &lt;code&gt;sympy&lt;/code&gt;，这下也正好合体了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;现在，R、Octave 和 Matlab 这些软件没有单纯用借位相减算法来产生随机数，1995 年后，Matlab 使用延迟斐波那契和移位寄存器的组合发生器，直到 2007 年，Matlab 推出 7.4 版本的时候才采用 MT 发生器。&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;在官网的 High-Performance JIT Compiler 部分&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;Python 的符号计算模块 &lt;code&gt;sympy&lt;/code&gt; 功能比较全，但是化简比较弱，导致结果理解起来不是很方便，比如式子的第一行，看似当&lt;code&gt;$0&amp;lt;x&amp;lt;2$&lt;/code&gt;时，&lt;code&gt;$p_{2}(x)=x$&lt;/code&gt;是错的，正确的范围应该是&lt;code&gt;$0&amp;lt;x&amp;lt;1$&lt;/code&gt;，其实 &lt;code&gt;for&lt;/code&gt; 后面的函数 &lt;code&gt;polar_lift()&lt;/code&gt; 要求参数大于 &lt;span class=&#34;math inline&#34;&gt;\(0\)&lt;/span&gt;，这样就没问题了，建议多撸一撸&lt;a href=&#34;http://docs.sympy.org/latest/index.html?v=20170321095755&#34;&gt;&lt;code&gt;sympy&lt;/code&gt; 官方文档&lt;/a&gt;。&lt;a href=&#34;#fnref3&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>使 LaTeX 文稿中的 URL 正确换行z</title>
      <link>/tech/2017/05/17/latex-url-linkbreak/</link>
      <pubDate>Wed, 17 May 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/05/17/latex-url-linkbreak/</guid>
      <description>
        &lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;a href=&#34;https://liam0205.me/2017/05/17/help-the-url-command-from-hyperref-to-break-at-line-wrapping-point/&#34; target=&#34;_blank&#34;&gt;https://liam0205.me/2017/05/17/help-the-url-command-from-hyperref-to-break-at-line-wrapping-point/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;大部分稍有经验的 LaTeX 用户，都知道使用&lt;code&gt;\url&lt;/code&gt;命令在 LaTeX 文稿中插入 URL。更资深一些的用户，会使用&lt;code&gt;hyperref&lt;/code&gt;宏包，而不是过时的&lt;code&gt;url&lt;/code&gt;宏包来处理。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;然而，不论是否资深，大多数用户应该都有遇到过 LaTeX 无法正确对 URL 进行折行的问题。此篇介绍一下如何处理。&lt;/p&gt;

&lt;p&gt;TeX 对于断行和分页，是有专门的算法处理的。通常而言，如果一个单词（一整个&lt;code&gt;\url&lt;/code&gt;可以看做是一个单词），TeX 不知道从何处进行分词，那么 TeX 就不会在这个单词上断行。对于很长的单词，比如一个&lt;code&gt;\url&lt;/code&gt;，如果 TeX 不能在此处断行，而它又处于某一行的末尾，就很容易出现&lt;code&gt;overful box&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;因此，本质上，这个问题需要让&lt;code&gt;\url&lt;/code&gt;命令，知道我们允许在何处断行。&lt;/p&gt;

&lt;p&gt;hyperref 宏包提供了两个宏，&lt;code&gt;\UrlBreaks&lt;/code&gt;以及&lt;code&gt;\UrlBigBreaks&lt;/code&gt;，用于告知 TeX，用户允许在何处截断 URL 以便换行。二者有一些细微的差别，但此处按下不表——大多数读者只需要使用&lt;code&gt;\UrlBreaks&lt;/code&gt;即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;\documentclass{article}
\usepackage{hyperref}
\makeatletter
\def\UrlAlphabet{%
      \do\a\do\b\do\c\do\d\do\e\do\f\do\g\do\h\do\i\do\j%
      \do\k\do\l\do\m\do\n\do\o\do\p\do\q\do\r\do\s\do\t%
      \do\u\do\v\do\w\do\x\do\y\do\z\do\A\do\B\do\C\do\D%
      \do\E\do\F\do\G\do\H\do\I\do\J\do\K\do\L\do\M\do\N%
      \do\O\do\P\do\Q\do\R\do\S\do\T\do\U\do\V\do\W\do\X%
      \do\Y\do\Z}
\def\UrlDigits{\do\1\do\2\do\3\do\4\do\5\do\6\do\7\do\8\do\9\do\0}
\g@addto@macro{\UrlBreaks}{\UrlOrds}
\g@addto@macro{\UrlBreaks}{\UrlAlphabet}
\g@addto@macro{\UrlBreaks}{\UrlDigits}
\makeatother
\begin{document}
\url{http://foo.bar.com/documentclassarticleusepackagehyperrefbegindocumenturlenddocument}
\end{document}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这里，&lt;code&gt;\UrlOrds&lt;/code&gt;里记录了一些特殊符号（例如&lt;code&gt;-&lt;/code&gt;和&lt;code&gt;_&lt;/code&gt;），而&lt;code&gt;\UrlAlphabet&lt;/code&gt;记录了&lt;code&gt;26&lt;/code&gt;个英文字母的大小写，&lt;code&gt;\UrlDigits&lt;/code&gt;则记录了 10 个阿拉伯数字。&lt;/p&gt;

&lt;p&gt;而后，我们使用 LaTeX 内核提供的&lt;code&gt;\g@addto@marco&lt;/code&gt;，依次将上述三个宏的内容，续接在&lt;code&gt;\UrlBreaks&lt;/code&gt;之后。这就是说，我们允许在上述所有字符处断行。&lt;/p&gt;

&lt;p&gt;如此，编译出的结果也是符合预期的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/LaTeX/url-linebreak.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>Bandit 算法与推荐系统 z</title>
      <link>/data/2017/05/04/bandit-and-recommender-systems/</link>
      <pubDate>Thu, 04 May 2017 00:00:00 +0000</pubDate>
      
      <guid>/data/2017/05/04/bandit-and-recommender-systems/</guid>
      <description>
        &lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#intro&#34;&gt;0.导语&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bandit-1&#34;&gt;1.什么是bandit算法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#for-choose&#34;&gt;1.1 为选择而生&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bandit-1-2&#34;&gt;1.2 bandit算法与推荐系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bandit&#34;&gt;1.3 怎么选择bandit算法？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bandit-1-4&#34;&gt;1.4 常用bandit算法&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#thompson-sampling&#34;&gt;Thompson sampling算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ucb&#34;&gt;UCB算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#epsilon-greedy&#34;&gt;Epsilon-Greedy算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bandit-1-4-4&#34;&gt;朴素bandit算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bandit-2&#34;&gt;2. bandit算法与线性回归&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ucb-2-1&#34;&gt;2.1 UCB算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ucb-2-2&#34;&gt;2.2 UCB算法加入特征信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#linucb&#34;&gt;2.3 详解LinUCB的实现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#construction-features&#34;&gt;2.4 怎么构建特征&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#org-users&#34;&gt;原始用户特征&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#org-papers&#34;&gt;原始文章特征&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bandit-3&#34;&gt;3. bandit算法与协同过滤&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#philo&#34;&gt;3.1 协同过滤背后的哲学&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bandit3-2&#34;&gt;3.2 bandit结合协同过滤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cofiba&#34;&gt;3.3 COFIBA算法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusion&#34;&gt;4. 总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bib&#34;&gt;参考文献&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;a href=&#34;https://cosx.org/2017/05/bandit-and-recommender-systems/&#34; class=&#34;uri&#34;&gt;https://cosx.org/2017/05/bandit-and-recommender-systems/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;注：本文首发于《程序员》杂志&lt;/p&gt;
&lt;div id=&#34;intro&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;0.导语&lt;/h1&gt;
&lt;p&gt;推荐系统里面有两个经典问题：EE问题和冷启动问题。前者涉及到平衡准确和多样，后者涉及到产品算法运营等一系列东西。bandit算法是一种简单的在线学习算法，常常用于尝试解决这两个问题，本文为你介绍基础的bandit算法及一系列升级版，以及对推荐系统这两个经典问题的思考。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bandit-1&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;1.什么是bandit算法&lt;/h1&gt;
&lt;div id=&#34;for-choose&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.1 为选择而生&lt;/h2&gt;
&lt;p&gt;我们会遇到很多选择的场景。上哪个大学，学什么专业，去哪家公司，中午吃什么，等等。这些事情，都让选择困难症的我们头很大。那么，有算法能够很好地对付这些问题吗？&lt;/p&gt;
&lt;p&gt;当然有！那就是bandit算法！&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Data/algorithm/bandit-and-recommender-systems/image.png&#34; alt=&#34;MAB问题&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;MAB问题&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;bandit算法来源于历史悠久的赌博学，它要解决的问题是这样的&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;一个赌徒，要去摇老虎机，走进赌场一看，一排老虎机，外表一模一样，但是每个老虎机吐钱的概率可不一样，他不知道每个老虎机吐钱的概率分布是什么，那么每次该选择哪个老虎机可以做到最大化收益呢？这就是多臂赌博机问题(Multi-armed bandit problem, K-armed bandit problem, MAB)。&lt;/p&gt;
&lt;p&gt;怎么解决这个问题呢？最好的办法是去试一试，不是盲目地试，而是有策略地快速试一试，这些策略就是bandit算法。&lt;/p&gt;
&lt;p&gt;这个多臂问题，推荐系统里面很多问题都与他类似：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;假设一个用户对不同类别的内容感兴趣程度不同，那么我们的推荐系统初次见到这个用户时，怎么快速地知道他对每类内容的感兴趣程度？这就是推荐系统的冷启动。&lt;/li&gt;
&lt;li&gt;假设我们有若干广告库存，怎么知道该给每个用户展示哪个广告，从而获得最大的点击收益？是每次都挑效果最好那个么？那么新广告如何才有出头之日？&lt;/li&gt;
&lt;li&gt;我们的算法工程师又想出了新的模型，有没有比A/B test更快的方法知道它和旧模型相比谁更靠谱？&lt;/li&gt;
&lt;li&gt;如果只是推荐已知的用户感兴趣的物品，如何才能科学地冒险给他推荐一些新鲜的物品？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些问题本质上全都是关乎如何选择。只要是关于选择，都可以简化成一个多臂赌博机问题，毕竟小赌怡情嘛，人生何处不赌博。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bandit-1-2&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.2 bandit算法与推荐系统&lt;/h2&gt;
&lt;p&gt;在推荐系统领域里，有两个比较经典的问题常被人提起，一个是EE问题，另一个是用户冷启动问题。&lt;/p&gt;
&lt;p&gt;什么是EE问题？又叫exploit－explore问题。exploit就是：对用户比较确定的兴趣，当然要利用开采迎合，好比说已经挣到的钱，当然要花；explore就是：光对着用户已知的兴趣使用，用户很快会腻，所以要不断探索用户新的兴趣才行，这就好比虽然有一点钱可以花了，但是还得继续搬砖挣钱，不然花完了就得喝西北风。&lt;/p&gt;
&lt;p&gt;用户冷启动问题，也就是面对新用户时，如何能够通过若干次实验，猜出用户的大致兴趣。&lt;/p&gt;
&lt;p&gt;我想，屏幕前的你已经想到了，推荐系统冷启动可以用bandit算法来解决一部分。&lt;/p&gt;
&lt;p&gt;这两个问题本质上都是如何选择用户感兴趣的主题进行推荐，比较符合bandit算法背后的MAB问题。&lt;/p&gt;
&lt;p&gt;比如，用bandit算法解决冷启动的大致思路如下：&lt;/p&gt;
&lt;p&gt;用分类或者Topic来表示每个用户兴趣，也就是MAB问题中的臂（Arm），我们可以通过几次试验，来刻画出新用户心目中对每个topic的感兴趣概率。&lt;/p&gt;
&lt;p&gt;这里，如果用户对某个topic感兴趣（提供了显式反馈或隐式反馈），就表示我们得到了收益，如果推给了它不感兴趣的topic，推荐系统就表示很遗憾(regret)了。&lt;/p&gt;
&lt;p&gt;如此经历“选择-观察-更新-选择”的循环，理论上是越来越逼近用户真正感兴趣的topic的。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bandit&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.3 怎么选择bandit算法？&lt;/h2&gt;
&lt;p&gt;现在来介绍一下bandit算法怎么解决这类问题的。bandit算法需要量化一个核心问题：错误的选择到底有多大的遗憾？能不能遗憾少一些？&lt;/p&gt;
&lt;p&gt;王家卫在《一代宗师》里寄出一句台词：&lt;/p&gt;
&lt;p&gt;人生要是无憾，那多无趣？&lt;/p&gt;
&lt;p&gt;而我说：算法要是无憾，那应该是过拟合了。&lt;/p&gt;
&lt;p&gt;所以说：怎么衡量不同bandit算法在解决多臂问题上的效果？首先介绍一个概念，叫做累积遗憾(regret)&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\begin{align*} R_T &amp;amp; = \sum_{i=1}^T(w_{opt}-w_{B(i)}) \\ &amp;amp;= T_{w^*}-\sum_{i=1}^Tw_{B(i)}  \end{align*}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个公式就是计算bandit算法的累积遗憾，解释一下：&lt;/p&gt;
&lt;p&gt;首先，这里我们讨论的每个臂的收益非0即1，也就是伯努利收益。&lt;/p&gt;
&lt;p&gt;然后，每次选择后，计算和最佳的选择差了多少，然后把差距累加起来就是总的遗憾。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$w_{B(i)}$&lt;/code&gt;是第i次试验时被选中臂的期望收益，&lt;code&gt;$w^*$&lt;/code&gt;是所有臂中的最佳那个，如果上帝提前告诉你，我们当然每次试验都选它，问题是上帝不告诉你，所以就有了bandit算法，我们就有了这篇文章。&lt;/p&gt;
&lt;p&gt;这个公式可以用来对比不同bandit算法的效果：对同样的多臂问题，用不同的bandit算法试验相同次数，看看谁的regret增长得慢。&lt;/p&gt;
&lt;p&gt;那么到底不同的bandit算法有哪些呢？&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bandit-1-4&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;1.4 常用bandit算法&lt;/h2&gt;
&lt;div id=&#34;thompson-sampling&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Thompson sampling算法&lt;/h3&gt;
&lt;p&gt;thompson sampling算法简单实用，因为它只有一行代码就可以实现&lt;a href=&#34;#fn3&#34; class=&#34;footnoteRef&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;。简单介绍一下它的原理，要点如下：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;假设每个臂是否产生收益，其背后有一个概率分布，产生收益的概率为p。&lt;/li&gt;
&lt;li&gt;我们不断地试验，去估计出一个置信度较高的“概率p的概率分布”就能近似解决这个问题了。&lt;/li&gt;
&lt;li&gt;怎么能估计“概率p的概率分布”呢？ 答案是假设概率p的概率分布符合beta(wins, lose)分布，它有两个参数: wins, lose。&lt;/li&gt;
&lt;li&gt;每个臂都维护一个beta分布的参数。每次试验后，选中一个臂，摇一下，有收益则该臂的wins增加1，否则该臂的lose增加1。&lt;/li&gt;
&lt;li&gt;每次选择臂的方式是：用每个臂现有的beta分布产生一个随机数b，选择所有臂产生的随机数中最大的那个臂去摇。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上就是Thompson采样，用python实现就一行：&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import  numpy as np
import  pymc
#wins 和 trials 是一个N维向量，N是赌博机的臂的个数，每个元素记录了
choice = np.argmax(pymc.rbeta(1 + wins, 1 + trials - wins)) 
wins[choice] += 1
trials += 1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;ucb&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;UCB算法&lt;/h3&gt;
&lt;p&gt;UCB算法全称是Upper Confidence Bound(置信区间上界)，它的算法步骤如下&lt;a href=&#34;#fn4&#34; class=&#34;footnoteRef&#34; id=&#34;fnref4&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;初始化：先对每一个臂都试一遍&lt;/li&gt;
&lt;li&gt;按照如下公式计算每个臂的分数，然后选择分数最大的臂作为选择： &lt;code&gt;$$\bar{x}_j(t)+\sqrt{\frac{2\ln{t}}{T_{j,t}}}$$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;观察选择结果，更新t和&lt;code&gt;$T_{jt}$&lt;/code&gt;。其中加号前面是这个臂到目前的收益均值，后面的叫做bonus，本质上是均值的标准差，t是目前的试验次数，&lt;code&gt;$T_{jt}$&lt;/code&gt;是这个臂被试次数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个公式反映一个特点：均值越大，标准差越小，被选中的概率会越来越大，同时哪些被选次数较少的臂也会得到试验机会。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;epsilon-greedy&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Epsilon-Greedy算法&lt;/h3&gt;
&lt;p&gt;这是一个朴素的bandit算法，有点类似模拟退火的思想：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;选一个(0,1)之间较小的数作为epsilon&lt;/li&gt;
&lt;li&gt;每次以概率epsilon做一件事：所有臂中随机选一个&lt;/li&gt;
&lt;li&gt;每次以概率1-epsilon 选择截止到当前，平均收益最大的那个臂。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;是不是简单粗暴？epsilon的值可以控制对Exploit和Explore的偏好程度。越接近0，越保守，只想花钱不想挣钱。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bandit-1-4-4&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;朴素bandit算法&lt;/h3&gt;
&lt;p&gt;最朴素的bandit算法就是：先随机试若干次，计算每个臂的平均收益，一直选均值最大那个臂。这个算法是人类在实际中最常采用的，不可否认，它还是比随机乱猜要好。&lt;/p&gt;
&lt;p&gt;以上五个算法，我们用10000次模拟试验的方式对比了其效果如图，实验代码来源&lt;a href=&#34;#fn5&#34; class=&#34;footnoteRef&#34; id=&#34;fnref5&#34;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Data/algorithm/bandit-and-recommender-systems/simulation.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;算法效果对比一目了然：UCB算法和Thompson采样算法显著优秀一些。&lt;/p&gt;
&lt;p&gt;至于你实际上要选哪一种bandit算法，你可以选一种bandit算法来选bandit算法。。。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;bandit-2&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;2. bandit算法与线性回归&lt;/h1&gt;
&lt;div id=&#34;ucb-2-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.1 UCB算法&lt;/h2&gt;
&lt;p&gt;UCB算法在做EE(Exploit-Explore)的时候表现不错，但它是上下文无关(context free)的bandit算法，它只管埋头干活，根本不观察一下面对的都是些什么特点的arm，下次遇到相似特点但不一样的arm也帮不上什么忙。&lt;/p&gt;
&lt;p&gt;UCB解决Multi-armed bandit问题的思路是：用置信区间。置信区间可以简单地理解为不确定性的程度，区间越宽，越不确定，反之亦反之。&lt;/p&gt;
&lt;p&gt;每个item的回报均值都有个置信区间，随着试验次数增加，置信区间会变窄（逐渐确定了到底回报丰厚还是可怜）。 每次选择前，都根据已经试验的结果重新估计每个item的均值及置信区间。 选择置信区间上限最大的那个item。&lt;/p&gt;
&lt;p&gt;“选择置信区间上界最大的那个item”这句话反映了几个意思：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;如果item置信区间很宽（被选次数很少，还不确定），那么它会倾向于被多次选择，这个是算法冒风险的部分；&lt;/li&gt;
&lt;li&gt;如果item置信区间很窄（备选次数很多，比较确定其好坏了），那么均值大的倾向于被多次选择，这个是算法保守稳妥的部分；&lt;/li&gt;
&lt;li&gt;UCB是一种乐观的算法，选择置信区间上界排序，如果时悲观保守的做法，是选择置信区间下界排序。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;ucb-2-2&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.2 UCB算法加入特征信息&lt;/h2&gt;
&lt;p&gt;Yahoo!的科学家们在2010年发表了一篇论文&lt;a href=&#34;#fn6&#34; class=&#34;footnoteRef&#34; id=&#34;fnref6&#34;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;，给UCB引入了特征信息，同时还把改造后的UCB算法用在了Yahoo!的新闻推荐中，算法名叫LinUCB。&lt;/p&gt;
&lt;p&gt;刘鹏博士在《计算广告》一书中也有介绍LinUCB在计算广告中的应用&lt;a href=&#34;#fn7&#34; class=&#34;footnoteRef&#34; id=&#34;fnref7&#34;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Data/algorithm/bandit-and-recommender-systems/image_0000.png&#34; alt=&#34;应用LinUCB算法的Yahoo!首页&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;应用LinUCB算法的Yahoo!首页&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;单纯的老虎机回报情况就是老虎机自己内部决定的，而在广告推荐领域，一个选择的回报，是由User和Item一起决定的，如果我们能用feature来刻画User和Item这一对CP，在每次选择item之前，通过feature预估每一个arm（item）的期望回报及置信区间，选择的收益就可以通过feature泛化到不同的item上。&lt;/p&gt;
&lt;p&gt;为UCB算法插上了特征的翅膀，这就是LinUCB最大的特色。&lt;/p&gt;
&lt;p&gt;LinUCB算法做了一个假设：一个Item被选择后推送给一个User，其回报和相关Feature成线性关系，这里的“相关feature”就是context，也是实际项目中发挥空间最大的部分。&lt;/p&gt;
&lt;p&gt;于是试验过程就变成：用User和Item的特征预估回报及其置信区间，选择置信区间上界最大的item推荐，观察回报后更新线性关系的参数，以此达到试验学习的目的。 LinUCB基本算法描述如下：&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Data/algorithm/bandit-and-recommender-systems/image_0001.png&#34; alt=&#34;LinUCB算法描述&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;LinUCB算法描述&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;对照每一行解释一下(编号从1开始)：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;设定一个参数&lt;code&gt;$\alpha$&lt;/code&gt;，这个参数决定了我们Explore的程度&lt;/li&gt;
&lt;li&gt;开始试验迭代&lt;/li&gt;
&lt;li&gt;获取每一个arm的特征向量&lt;code&gt;$x_{a,t}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;开始计算每一个arm的预估回报及其置信区间&lt;/li&gt;
&lt;li&gt;如果arm还从没有被试验过，那么：&lt;/li&gt;
&lt;li&gt;用单位矩阵初始化&lt;code&gt;$A_a$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用0向量初始化&lt;code&gt;$b_a$&lt;/code&gt;，&lt;/li&gt;
&lt;li&gt;处理完没被试验过的arm&lt;/li&gt;
&lt;li&gt;计算线性参数&lt;code&gt;$\theta$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用&lt;code&gt;$\theta$&lt;/code&gt;和特征向量&lt;code&gt;$x_{a,t}$&lt;/code&gt;计算预估回报, 同时加上置信区间宽度&lt;/li&gt;
&lt;li&gt;处理完每一个arm&lt;/li&gt;
&lt;li&gt;选择第10步中最大值对应的arm，观察真实的回报&lt;code&gt;$r_t$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;更新&lt;code&gt;$A_{at}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;更新&lt;code&gt;$b_{at}$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;算法结束&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;注意到上面的第4步，给特征矩阵加了一个单位矩阵，这就是岭回归（ridge regression），岭回归主要用于当样本数小于特征数时，对回归参数进行修正&lt;a href=&#34;#fn8&#34; class=&#34;footnoteRef&#34; id=&#34;fnref8&#34;&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt;。 对于加了特征的bandit问题，正符合这个特点：试验次数（样本）少于特征数。&lt;/p&gt;
&lt;p&gt;每一次观察真实回报之后，要更新的不止是岭回归参数，还有每个arm的回报向量&lt;code&gt;$b_a$&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;linucb&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.3 详解LinUCB的实现&lt;/h2&gt;
&lt;p&gt;根据论文给出的算法描述，其实很好写出LinUCB的代码&lt;a href=&#34;#fn9&#34; class=&#34;footnoteRef&#34; id=&#34;fnref9&#34;&gt;&lt;sup&gt;9&lt;/sup&gt;&lt;/a&gt;，麻烦的只是构建特征。&lt;/p&gt;
&lt;p&gt;代码如下，一些必要的注释说明已经写在代码中。&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;class LinUCB:
    def __init__(self):
        self.alpha = 0.25 
        self.r1 = 1 # if worse -&amp;gt; 0.7, 0.8
        self.r0 = 0 # if worse, -19, -21
        # dimension of user features = d
        self.d = 6
        # Aa : collection of matrix to compute disjoint part for each article a, d*d
        self.Aa = {}
        # AaI : store the inverse of all Aa matrix
        self.AaI = {}
        # ba : collection of vectors to compute disjoin part, d*1
        self.ba = {}
        
        self.a_max = 0
        
        self.theta = {}
        
        self.x = None
        self.xT = None
        # linUCB

    def set_articles(self, art):
        # init collection of matrix/vector Aa, Ba, ba
        for key in art:
            self.Aa[key] = np.identity(self.d)
            self.ba[key] = np.zeros((self.d, 1))
            self.AaI[key] = np.identity(self.d)
            self.theta[key] = np.zeros((self.d, 1))
            
    &amp;quot;&amp;quot;&amp;quot;
    这里更新参数时没有传入更新哪个arm，因为在上一次recommend的时候缓存了被选的那个arm，所以此处不用传入
    
    另外，update操作不用阻塞recommend，可以异步执行
    &amp;quot;&amp;quot;&amp;quot;        
    def update(self, reward):
        if reward == -1:
            pass
        elif reward == 1 or reward == 0:
            if reward == 1:
                r = self.r1
            else:
                r = self.r0
            self.Aa[self.a_max] += np.dot(self.x, self.xT)
            self.ba[self.a_max] += r * self.x
            self.AaI[self.a_max] = linalg.solve(self.Aa[self.a_max], np.identity(self.d))
            self.theta[self.a_max] = np.dot(self.AaI[self.a_max], self.ba[self.a_max])
        else:
        # error
            pass
    
    &amp;quot;&amp;quot;&amp;quot;
    预估每个arm的回报期望及置信区间
    &amp;quot;&amp;quot;&amp;quot;
    def recommend(self, timestamp, user_features, articles):
        xaT = np.array([user_features])
        xa = np.transpose(xaT)
        art_max = -1
        old_pa = 0
        
        # 获取在update阶段已经更新过的AaI(求逆结果)
        AaI_tmp = np.array([self.AaI[article] for article in articles])
        theta_tmp = np.array([self.theta[article] for article in articles])
        art_max = articles[np.argmax(np.dot(xaT, theta_tmp) + self.alpha * np.sqrt(np.dot(np.dot(xaT, AaI_tmp), xa)))]

        # 缓存选择结果，用于update
        self.x = xa
        self.xT = xaT
        # article index with largest UCB
        self.a_max = art_max
        
        return self.a_max  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;construction-features&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2.4 怎么构建特征&lt;/h2&gt;
&lt;p&gt;LinUCB算法有一个很重要的步骤，就是给User和Item构建特征，也就是刻画context。在原始论文里，Item是文章，其中专门介绍了它们怎么构建特征的，也甚是精妙。容我慢慢表来。&lt;/p&gt;
&lt;div id=&#34;org-users&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;原始用户特征&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;人口统计学：性别特征（2类），年龄特征（离散成10个区间）&lt;/li&gt;
&lt;li&gt;地域信息：遍布全球的大都市，美国各个州&lt;/li&gt;
&lt;li&gt;行为类别：代表用户历史行为的1000个类别取值&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div id=&#34;org-papers&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;原始文章特征&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;URL类别：根据文章来源分成了几十个类别&lt;/li&gt;
&lt;li&gt;编辑打标签：编辑人工给内容从几十个话题标签中挑选出来的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原始特征向量都要归一化成单位向量。 还要对原始特征降维，以及模型要能刻画一些非线性的关系。 用Logistic Regression去拟合用户对文章的点击历史，其中的线性回归部分为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$$\phi_u^\mathrm{T}W\phi_a$$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;拟合得到参数矩阵W，可以将原始用户特征（1000多维）投射到文章的原始特征空间（80多维），投射计算方式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$$\psi_u\stackrel{def}{=}\phi_u^\mathrm{T}W$$&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这是第一次降维，把原始1000多维降到80多维。&lt;/p&gt;
&lt;p&gt;然后，用投射后的80多维特征对用户聚类，得到5个类簇，文章页同样聚类成5个簇，再加上常数1，用户和文章各自被表示成6维向量。&lt;/p&gt;
&lt;p&gt;Yahoo!的科学家们之所以选定为6维，因为数据表明它的效果最好&lt;a href=&#34;#fn10&#34; class=&#34;footnoteRef&#34; id=&#34;fnref10&#34;&gt;&lt;sup&gt;10&lt;/sup&gt;&lt;/a&gt;，并且这大大降低了计算复杂度和存储空间。&lt;/p&gt;
&lt;p&gt;我们实际上可以考虑三类特征：U（用户），A（广告或文章），C（所在页面的一些信息）。&lt;/p&gt;
&lt;p&gt;前面说了，特征构建很有发挥空间，算法工程师们尽情去挥洒汗水吧。&lt;/p&gt;
&lt;p&gt;总结一下LinUCB算法，有以下优点：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;由于加入了特征，所以收敛比UCB更快（论文有证明）；&lt;/li&gt;
&lt;li&gt;特征构建是效果的关键，也是工程上最麻烦和值的发挥的地方；&lt;/li&gt;
&lt;li&gt;由于参与计算的是特征，所以可以处理动态的推荐候选池，编辑可以增删文章；&lt;/li&gt;
&lt;li&gt;特征降维很有必要，关系到计算效率。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;bandit-3&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;3. bandit算法与协同过滤&lt;/h1&gt;
&lt;div id=&#34;philo&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.1 协同过滤背后的哲学&lt;/h2&gt;
&lt;p&gt;推荐系统里面，传统经典的算法肯定离不开协同过滤。协同过滤背后的思想简单深刻，在万物互联的今天，协同过滤的威力更加强大。协同过滤看上去是一种算法，不如说是一种方法论，不是机器在给你推荐，而是“集体智慧”在给你推荐。&lt;/p&gt;
&lt;p&gt;它的基本假设就是“物以类聚，人以群分”，你的圈子决定了你能见到的物品。这个假设很靠谱，却隐藏了一些重要的问题：作为用户的我们还可能看到新的东西吗？还可能有惊喜吗？还可能有圈子之间的更迭流动吗？这些问题的背后其实就是在前面提到过的EE问题（Exploit &amp;amp; Explore）。我们关注推荐的准确率，但是我们也应该关注推荐系统的演进发展，因为“推荐系统不止眼前的Exploit，还有远方的Explore”。&lt;/p&gt;
&lt;p&gt;做Explore的方法有很多，bandit算法是其中的一种流派。前面也介绍过几种bandit算法，基本上就是估计置信区间的做法，然后按照置信区间的上界来进行推荐，以UCB,LinUCB为代表。&lt;/p&gt;
&lt;p&gt;作为要寻找诗和远方的bandit浪漫派算法，能不能和协同过滤这种正统算法结合起来呢？事实上已经有人这么尝试过了，叫做COFIBA算法，具体在题目为Collaborative Filtering Bandits&lt;a href=&#34;#fn11&#34; class=&#34;footnoteRef&#34; id=&#34;fnref11&#34;&gt;&lt;sup&gt;11&lt;/sup&gt;&lt;/a&gt;和Online Clustering of Bandits&lt;a href=&#34;#fn12&#34; class=&#34;footnoteRef&#34; id=&#34;fnref12&#34;&gt;&lt;sup&gt;12&lt;/sup&gt;&lt;/a&gt;）的两篇文章中有详细的描述，它就是bandit和协同过滤的结合算法，两篇文章的区别是后者只对用户聚类（即只考虑了User-based的协同过滤），而前者采用了协同聚类（co-clustering，可以理解为item-based和user-based两种协同方式在同时进行），后者是前者的一个特殊情况。下面详细介绍一下这种结合算法。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;bandit3-2&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.2 bandit结合协同过滤&lt;/h2&gt;
&lt;p&gt;很多推荐场景中都有这两个规律：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;相似的用户对同一个物品的反馈可能是一样的。也就是对一个聚类用户群体推荐同一个item，他们可能都喜欢，也可能都不喜欢，同样地，同一个用户会对相似的物品反馈相同。这是属于协同过滤可以解决的问题；&lt;/li&gt;
&lt;li&gt;在使用推荐系统过程中，用户的决策是动态进行的，尤其是新用户。这就导致无法提前为用户准备好推荐候选，只能“走一步看一步”，是一个动态的推荐过程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每一个推荐候选item，都可以根据用户对其偏好不同（payoff不同）将用户聚类成不同的群体，一个群体来集体预测这个item的可能的收益，这就有了协同的效果，然后再实时观察真实反馈回来更新用户的个人参数，这就有了bandit的思想在里面。&lt;/p&gt;
&lt;p&gt;举个例子，如果你父母给你安排了很多相亲对象，要不要见面去相一下？那需要提前看看每一个相亲对象的资料，每次大家都分成好几派，有说好的，有说再看看的，也有说不行的；你自己也会是其中一派的一员，每次都是你所属的那一派给你集体打分，因为他们是和你“三观一致的人”，“诚不欺我”；这样从一堆资料中挑出分数最高的那个人，你出去见TA，回来后把实际感觉说给大家听，同时自己心里的标准也有些调整，重新给剩下的其它对象打分，打完分再去见，周而复始……&lt;/p&gt;
&lt;p&gt;以上就是协同过滤和bandit结合的思想。&lt;/p&gt;
&lt;p&gt;另外，如果要推荐的候选item较多，还需要对item进行聚类，这样就不用按照每一个item对user聚类，而是按照每一个item的类簇对user聚类，如此以来，item的类簇数相对于item数要大大减少。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;cofiba&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;3.3 COFIBA算法&lt;/h2&gt;
&lt;p&gt;基于这些思想，有人提出了算法COFIBA（读作coffee bar）&lt;a href=&#34;#fn13&#34; class=&#34;footnoteRef&#34; id=&#34;fnref13&#34;&gt;&lt;sup&gt;13&lt;/sup&gt;&lt;/a&gt;，简要描述如下：&lt;/p&gt;
&lt;p&gt;在时刻t，用户来访问推荐系统，推荐系统需要从已有的候选池子中挑一个最佳的物品推荐给他，然后观察他的反馈，用观察到的反馈来更新挑选策略。 这里的每个物品都有一个特征向量，所以这里的bandit算法是context相关的。 这里依然是用岭回归去拟合用户的权重向量，用于预测用户对每个物品的可能反馈（payoff），这一点和linUCB算法是一样的。&lt;/p&gt;
&lt;p&gt;对比LinUCB算法，COFIBA算法的不同有两个：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;基于用户聚类挑选最佳的item（相似用户集体决策的bandit）&lt;/li&gt;
&lt;li&gt;基于用户的反馈情况调整user和item的聚类（协同过滤部分）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;整体算法过程如下：&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Data/algorithm/bandit-and-recommender-systems/image_0002.png&#34; alt=&#34;COFIBA算法描述&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;COFIBA算法描述&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;核心步骤是，针对某个用户i，在每一轮试验时做以下事情：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;首先计算该用户的bandit参数W（和LinUCB相同），但是这个参数并不直接参与到bandit的选择决策中（和LinUCB不同），而是用来更新用户聚类的；&lt;/li&gt;
&lt;li&gt;遍历候选item，每一个item表示成一个context向量了。&lt;/li&gt;
&lt;li&gt;每一个item都对应一套用户聚类结果，所以遍历到每一个item时判断当前用户在当前item下属于哪个类簇，然后把对应类簇中每个用户的M矩阵(对应LinUCB里面的A矩阵)，b向量（payoff向量，对应linUCB里面的b向量）聚合起来，从而针对这个类簇求解一个岭回归参数（类似LinUCB里面单独针对每个用户所做），同时计算其payoff预测值和置信上边界&lt;/li&gt;
&lt;li&gt;每个item都得到一个payoff预测值及置信区间上界，挑出那个上边界最大的item推出去（和LinUCB相同）&lt;/li&gt;
&lt;li&gt;观察用户的真实反馈，然后更新用户自己的M矩阵和b向量（更新个人的，对应类簇里其他的不更新）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上是COFIBA算法的一次决策过程。在收到用户真实反馈之后，还有两个计算过程：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;更新user聚类&lt;/li&gt;
&lt;li&gt;更新item聚类&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如何更新user和item的聚类呢？示意图为：&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Data/algorithm/bandit-and-recommender-systems/image_0003.png&#34; alt=&#34;User和Item聚类更新描述&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;User和Item聚类更新描述&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;解释一下这个图。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(a.) 这里有6个user，8个item，初始化时，user和item的类簇个数都是1&lt;/li&gt;
&lt;li&gt;(b1.) 在某一轮试验时，推荐系统面对的用户是4。推荐过程就是遍历1~8每个item，然后看看对应每个item时，user4在哪个类簇中，把对应类簇中的用户聚合起来为这个item预测payoff和CB。这里假设最终item5胜出，被推荐出去了。&lt;/li&gt;
&lt;li&gt;(b2.) 在时刻t，item有3个类簇，需要更新的用户聚类是item5对应的user4所在类簇。更新方式：看看该类簇里面除了user4之外的用户，对item5的payoff是不是和user4相近，如果是，则保持原来的连接边，否则删除原来的连接边。删除边之后重新构建聚类结果。这里假设重新构建后原来user4所在的类簇分裂成了两个类簇：{4,5}和{6}&lt;/li&gt;
&lt;li&gt;(c.) 更新完用户类簇后，item5对应的类簇也要更新。更新方式是：对于每一个和item5(被推荐出的那个item)还存在连接边的item j，都去构造一个user的近邻集合N，这个集合的用户对item j有相近的payoff，然后看看N是不是和刚刚更新后的user4所在的类簇相同，是的话，保留item5和item j之间的连接边，否则删除。这里假设item 3和item 5之间的连接边被删除。item3独立后给他初始化了一个聚类结果：所有用户还是一个类簇。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说就是这样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;User-based协同过滤来选择要推荐的item，选择时用了LinUCB的思想&lt;/li&gt;
&lt;li&gt;根据用户的反馈，调整User-based和Item-based的聚类结果&lt;/li&gt;
&lt;li&gt;Item-based的聚类变化又改变了User的聚类&lt;/li&gt;
&lt;li&gt;不断根据用户实时动态的反馈来划分User-Item矩阵&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;conclusion&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;4. 总结&lt;/h1&gt;
&lt;p&gt;Exploit-Explore这一对矛盾一直客观存在，bandit算法是公认的一种比较好的解决EE问题的方案。除了bandit算法之外，还有一些其他的explore的办法，比如：在推荐时，随机地去掉一些用户历史行为（特征）。&lt;/p&gt;
&lt;p&gt;解决Explore，势必就是要冒险，势必要走向未知，而这显然就是会伤害用户体验的：明知道用户肯定喜欢A，你还偏偏以某个小概率给推荐非A。&lt;/p&gt;
&lt;p&gt;实际上，很少有公司会采用这些理性的办法做Explore，反而更愿意用一些盲目主观的方式。究其原因，可能是因为：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;互联网产品生命周期短，而Explore又是为了提升长期利益的，所以没有动力做；&lt;/li&gt;
&lt;li&gt;用户使用互联网产品时间越来越碎片化，Explore的时间长，难以体现出Explore 的价值；&lt;/li&gt;
&lt;li&gt;同质化互联网产品多，用户选择多，稍有不慎，用户用脚投票，分分钟弃你于不顾。&lt;/li&gt;
&lt;li&gt;已经成规模的平台，红利杠杠的，其实是没有动力做Explore的；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于这些，我们如果想在自己的推荐系统中引入Explore机制，需要注意以下几点：&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;用于Explore的item要保证其本身质量，纵使用户不感兴趣，也不至于引起其反感；&lt;/li&gt;
&lt;li&gt;Explore本身的产品需要精心设计，让用户有耐心陪你玩儿；&lt;/li&gt;
&lt;li&gt;深度思考，这样才不会做出脑残的产品，产品不会早早夭折，才有可能让Explore机制有用武之地。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;bib&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;参考文献&lt;/h1&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Multi-armed_bandit&#34; class=&#34;uri&#34;&gt;https://en.wikipedia.org/wiki/Multi-armed_bandit&lt;/a&gt;&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;&lt;a href=&#34;http://nbviewer.jupyter.org/github/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/blob/master/Chapter6_Priorities/Chapter6.ipynb#&#34; class=&#34;uri&#34;&gt;http://nbviewer.jupyter.org/github/CamDavidsonPilon/Probabilistic-Programming-and-Bayesian-Methods-for-Hackers/blob/master/Chapter6_Priorities/Chapter6.ipynb#&lt;/a&gt;&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Thompson_sampling&#34; class=&#34;uri&#34;&gt;https://en.wikipedia.org/wiki/Thompson_sampling&lt;/a&gt;&lt;a href=&#34;#fnref3&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34;&gt;&lt;p&gt;&lt;a href=&#34;http://hunch.net/~coms-4771/lecture20.pdf&#34; class=&#34;uri&#34;&gt;http://hunch.net/~coms-4771/lecture20.pdf&lt;/a&gt;&lt;a href=&#34;#fnref4&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn5&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://gist.github.com/anonymous/211b599b7bef958e50af&#34; class=&#34;uri&#34;&gt;https://gist.github.com/anonymous/211b599b7bef958e50af&lt;/a&gt;&lt;a href=&#34;#fnref5&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn6&#34;&gt;&lt;p&gt;&lt;a href=&#34;http://www.research.rutgers.edu/~lihong/pub/Li10Contextual.pdf&#34; class=&#34;uri&#34;&gt;http://www.research.rutgers.edu/~lihong/pub/Li10Contextual.pdf&lt;/a&gt;&lt;a href=&#34;#fnref6&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn7&#34;&gt;&lt;p&gt;《计算广告：互联网商业变现的市场与技术》p253, 刘鹏，王超著&lt;a href=&#34;#fnref7&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn8&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Tikhonov_regularization&#34; class=&#34;uri&#34;&gt;https://en.wikipedia.org/wiki/Tikhonov_regularization&lt;/a&gt;&lt;a href=&#34;#fnref8&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn9&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/Fengrui/HybridLinUCB-python/blob/master/policy_hybrid.py&#34; class=&#34;uri&#34;&gt;https://github.com/Fengrui/HybridLinUCB-python/blob/master/policy_hybrid.py&lt;/a&gt;&lt;a href=&#34;#fnref9&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn10&#34;&gt;&lt;p&gt;&lt;a href=&#34;http://www.gatsby.ucl.ac.uk/~chuwei/paper/isp781-chu.pdf&#34; class=&#34;uri&#34;&gt;http://www.gatsby.ucl.ac.uk/~chuwei/paper/isp781-chu.pdf&lt;/a&gt;&lt;a href=&#34;#fnref10&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn11&#34;&gt;&lt;p&gt;&lt;a href=&#34;http://arxiv.org/abs/1401.8257&#34; class=&#34;uri&#34;&gt;http://arxiv.org/abs/1401.8257&lt;/a&gt;&lt;a href=&#34;#fnref11&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn12&#34;&gt;&lt;p&gt;&lt;a href=&#34;http://arxiv.org/abs/1502.03473&#34; class=&#34;uri&#34;&gt;http://arxiv.org/abs/1502.03473&lt;/a&gt;&lt;a href=&#34;#fnref12&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn13&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://github.com/qw2ky/CoLinUCB_Revised/blob/master/COFIBA.py&#34; class=&#34;uri&#34;&gt;https://github.com/qw2ky/CoLinUCB_Revised/blob/master/COFIBA.py&lt;/a&gt;&lt;a href=&#34;#fnref13&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>自定义命令：在 LaTeX 中使用微分算子的正确姿势 z</title>
      <link>/tech/2017/05/01/the-correct-way-to-use-differential-operator/</link>
      <pubDate>Mon, 01 May 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/05/01/the-correct-way-to-use-differential-operator/</guid>
      <description>
        

&lt;p&gt;此篇讨论很小的「一点」——关于如何正确排版微分算子。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;p&gt;所谓微分算子，其英文名字叫做 differential operator，也就是 &lt;code&gt;$\mathrm{d} x$&lt;/code&gt; 中的 $\mathrm{d}$。由于微分算子，形式上就是拉丁字母 &lt;code&gt;d&lt;/code&gt;；并且中国人读起来也就是简单粗暴的「滴埃克斯」。所以，在书写 LaTeX 手稿时，很多人简单粗暴地将微分算子写作 &lt;code&gt;dx&lt;/code&gt;，例如不定积分 &lt;code&gt;\int f(x)dx&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们说，数学算式是精美而珍贵的。在排版数学算式时，你不能马虎，应该小心谨慎。这也是为什么 Knuth 在设计 TeX 时，将数学式子都包含在美元符号 &lt;code&gt;$&lt;/code&gt; 之间的原因。对待微分算子，我们也应该有这样的心态。&lt;/p&gt;

&lt;p&gt;粗话说：「如果没有标准，那所有的争执都是瞎扯淡」。正如单位制有所谓的 ISO 国际单位制一样，数学符号也有对应的 ISO 标准。数学符号的标准，首先是定义在 ISO 31-11 当中；而后这个标准被 ISO 80000-2:2009 取代。因此，此篇讨论的内容，都是基于 ISO 80000-2:2009 的。&lt;/p&gt;

&lt;p&gt;在 ISO 80000-2:2009 中，微分算子被描述为&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;直立的拉丁字母 d；&lt;/li&gt;
&lt;li&gt;一个右边没有间距的操作符。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于直立的拉丁字母 d，我们可以使用 &lt;code&gt;\mathrm{d}&lt;/code&gt; 达成效果。而若要微分算子的左边有间距，而右边没有，这个问题就值得思考了。&lt;/p&gt;

&lt;p&gt;最简单的办法，是将微分算子做如下实现&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;\newcommand*{\dif}{\,\mathrm{d}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看起来，这样是没有问题的。但是，在某些情况下，就会出现尴尬的问题。比如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;关于 $x$ 的微分 $\dif x$ 是指的思考的问题。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因为在 &lt;code&gt;\dif&lt;/code&gt; 的定义中，&lt;code&gt;\mathrm{d}&lt;/code&gt; 之前有不可省略的铅空 &lt;code&gt;\,&lt;/code&gt;。于是，这份代码中 &lt;code&gt;\dif x&lt;/code&gt; 与前后正文之间的距离就不一致了。为了解决这个问题，更有经验的人可能会选择这样定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;\newcommand*{\dif}{\mathop{\mathrm{d}}\!}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这份代码，试图利用 &lt;code&gt;\mathop&lt;/code&gt;，只在必要的时候于左边插入空白，修复了上面的问题。不过，这样一来也带来了一些副作用——在 &lt;code&gt;\mathop&lt;/code&gt; 的作用下，&lt;code&gt;\mathrm{d}&lt;/code&gt; 的基线发生了改变，不再与正常的数学变量保持在同一个基线上。这也是不好的。&lt;/p&gt;

&lt;h1 id=&#34;正确做法&#34;&gt;正确做法&lt;/h1&gt;

&lt;p&gt;最终解决问题，应该对微分算子有这样的定义&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-tex&#34;&gt;\newcommand*{\dif}{\mathop{}\!\mathrm{d}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个定义中，拉丁字母 d 本身的特点得到了保留（比如基线是正常的）。此外，在 &lt;code&gt;\mathrm{d}&lt;/code&gt; 的左边，插入了一个空白的 &lt;code&gt;\mathop{}&lt;/code&gt;；其左边的空白保留，而右边与 &lt;code&gt;\mathrm{d}&lt;/code&gt; 之间的距离，则由 &lt;code&gt;\!&lt;/code&gt; 抑制。这样就达成了我们的目标。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;参考：&lt;a href=&#34;http://www.tug.org/TUGboat/Articles/tb18-1/tb54becc.pdf#page=8&#34; target=&#34;_blank&#34;&gt;http://www.tug.org/TUGboat/Articles/tb18-1/tb54becc.pdf#page=8&lt;/a&gt;&lt;/p&gt;

        
      </description>
    </item>
    
    <item>
      <title>回归时交叉项为什么要去平均？ - 慧航 - 专栏</title>
      <link>/prof/2017/04/17/demean/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/prof/2017/04/17/demean/</guid>
      <description>
        &lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;a href=&#34;https://zhuanlan.zhihu.com/p/26257159&#34; class=&#34;uri&#34;&gt;https://zhuanlan.zhihu.com/p/26257159&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之所以写这篇文章是因为在一个微信群里面的争论。&lt;/p&gt;
&lt;p&gt;我想很多人都知道，当我们做回归的时候，如果回归方程里面包含着交叉项，那么一般我们对变量去平均。那么为什么这么做呢？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;有的人的解释是&lt;del&gt;&lt;strong&gt;消除多重共线性&lt;/strong&gt;&lt;/del&gt;。然而就像我之前写过的一个答案&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;一样，在计量经济学领域，如果我们关注的是系数，&lt;code&gt;增大样本几乎是解决多重共线性的唯一方法&lt;/code&gt;。其他的方法，要么会导致参数的不一致，要么就是自欺欺人的方法。所以期刊中的文章如果意识到了多重共线性的问题，都不会去讨论，更没有办法去解决这一问题。&lt;/p&gt;
&lt;p&gt;至于为什么要去平均，我们不妨稍微写一下&lt;strong&gt;线性投影&lt;/strong&gt;（按照伍德里奇书里面的方法）：&lt;/p&gt;
&lt;p&gt;如果不去平均，那么 OLS 是一个线性投影：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[L(y|x_1,x_2,x_1\cdot x_2)=\beta_1 x_1+\beta_2\cdot x_2 +\gamma x_1\cdot x_2\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而如果去平均（&lt;strong&gt;疑问&lt;/strong&gt;：中括号中的部分是什么？&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\begin{aligned}
L(y|\tilde{x}_1,\tilde{x}_2,\tilde{x}_1\cdot \tilde{x}_2) &amp;amp; =b_1 \tilde{x}_1+b_2\cdot \tilde{x}_2 +r\cdot \tilde{x}_1\cdot \tilde{x}_2\\
 &amp;amp; =b_1 (x_1-\bar{x}_1)+b_2\cdot  (x_2-\bar{x}_2) +r\cdot(x_1-\bar{x}_1)\cdot (x_2-\bar{x}_2)\\
 &amp;amp; =b_1x_1-b_1\bar{x}_1+b_2x_2-b_2\bar{x}_2+rx_1x_2-rx_1\bar{x}_2-rx_2\bar{x}_1+r\bar{x}_1\bar{x}_2\\
 &amp;amp; =(b_1-r\bar{x}_2)x_1+(b_2-r\bar{x}_1)x_2+rx_1x_2+[r\bar{x}_1\bar{x}_2-b_1\bar{x}_1-b_2\bar{x}_2]
\end{aligned}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以其实我们可以得到：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
\left\{
\begin{aligned}
\beta_1 &amp;amp; =b_1-r\bar{x}_2\\
\beta_2 &amp;amp; =b_2-r\bar{x}_1\\
\gamma &amp;amp; =r
\end{aligned}\right.
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以实际上，这两种方法计算的系数，可以使用上面三个方程相互计算得到。相应的，系数的标准差也可以使用上面三个方程计算出来。&lt;/p&gt;
&lt;p&gt;也就是说，如果做了去平均的回归，那么不去平均的回归结果（包括系数和方差）用上面三个方程就可以算出来了；如果做了不去平均的回归，那么去平均的回归结果（包括系数和方差）用上面三个方程也可以算出来。&lt;/p&gt;
&lt;p&gt;所以你跟我说这是解决了多重共线性？逗我呢？&lt;/p&gt;
&lt;p&gt;如果再不信，可以做个简单的小模拟：&lt;/p&gt;
&lt;pre class=&#34;stata&#34;&gt;&lt;code&gt;clear
set obs 100
gen x1=rnormal()*sqrt(2)+1 // mean 1
gen x2=2*x1+rnormal()+1  // mean 3
gen x12=x1*x2
scalar beta1=-3
scalar beta2=-1
scalar gamma=1
gen y=beta1*x1+beta2*x2+gamma*x12+rchi2(2)

// deman
egen mean_x1=mean(x1)
egen mean_x2=mean(x2)
gen demean_x1=x1-mean_x1
gen demean_x2=x2-mean_x2
gen demean_x12=demean_x1*demean_x2

// regression
reg y x1 x2 x12
reg y demean_x1 demean_x2 demean_x12&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回归结果：&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Eco/Econometrica/huihang/demean/1.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;配合着描述性统计：&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Eco/Econometrica/huihang/demean/2.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;可以轻易的验证上面的三个方程是成立的。&lt;/p&gt;
&lt;p&gt;特别是，&lt;strong&gt;注意&lt;/strong&gt;去不去平均，交叉项的系数和标准误都是&lt;code&gt;一样&lt;/code&gt;的，所以如果我们只关注交叉项，比如在 &lt;strong&gt;DID&lt;/strong&gt; 里面，去不去平均都可以。&lt;/p&gt;
&lt;p&gt;那么这个变换是不是解决了多重共线性问题呢？有的人是这么 argue 的：&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Eco/Econometrica/huihang/demean/3.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;你看，相关系数小了很多哎！难道不是解决了多重共线性？&lt;/p&gt;
&lt;p&gt;要&lt;strong&gt;注意&lt;/strong&gt;，多重共线性是要看&lt;strong&gt;偏相关系数&lt;/strong&gt;的，实际上，如果我们做这样的回归：&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/images/Eco/Econometrica/huihang/demean/4.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;你会发现，两个回归的 R-squared 基本上是一样的。&lt;/p&gt;
&lt;p&gt;这不是自欺欺人是干嘛？&lt;/p&gt;
&lt;p&gt;也有人说了，去平均之后的确更容易显著啊！难道不是因为多重共线性吗？&lt;/p&gt;
&lt;p&gt;不是的。去平均之后更容易显著是因为，去平均之后&lt;span class=&#34;math inline&#34;&gt;\(x_1\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(x_2\)&lt;/span&gt;前面的系数都不一样了，参考我上面写的三个方程的结论，相当于加上了一个系数，所以更容易显著了。当然，这也不是绝对的，比如在上面的模拟里面，我通过一个特殊的设定展示了，去平均之后也有可能更不显著了。&lt;/p&gt;
&lt;p&gt;注意我在这里仅仅是说去平均这一做法不是为了解决多重共线性问题，而没有说去平均这个做法是错的。实际上，去平均才是比较标准的做法。&lt;/p&gt;
&lt;p&gt;为什么呢？如果我们算一下偏效应：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\frac{\partial \mathrm{E}(y|\tilde{x}_1,\tilde{x}_2,\tilde{x}_1\cdot \tilde{x}_2)}{\partial x_1}
=b_1 +r\cdot\tilde{x}_2\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而其期望：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\mathrm{E}\left\{\frac{\partial \mathrm{E}(y|\tilde{x}_1,\tilde{x}_2,\tilde{x}_1\cdot \tilde{x}_2)}{\partial x_1}\right\}
=b_1\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也就是说，去平均之后的&lt;span class=&#34;math inline&#34;&gt;\(x_1\)&lt;/span&gt;的系数才是&lt;span class=&#34;math inline&#34;&gt;\(x_1\)&lt;/span&gt;对&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;的平均影响。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果我们做出了&lt;span class=&#34;math inline&#34;&gt;\(x_1\)&lt;/span&gt;的系数不显著，但是交叉项的系数是显著的，说明平均而言&lt;span class=&#34;math inline&#34;&gt;\(x_1\)&lt;/span&gt;对&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;是没有影响的，但是&lt;span class=&#34;math inline&#34;&gt;\(x_1\)&lt;/span&gt;对&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;是有影响的，其影响随着&lt;span class=&#34;math inline&#34;&gt;\(x_2\)&lt;/span&gt;的不同而变化。只是在总体上平均而言，&lt;span class=&#34;math inline&#34;&gt;\(x_1\)&lt;/span&gt;对&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;没有影响。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以&lt;strong&gt;总结&lt;/strong&gt;一下，其实去不去平均这两种做法是等价的，只不过去平均之后的系数更容易解释，所以我们一般做回归的时候会去平均处理。这个跟多重共线性没啥关系。&lt;/p&gt;
&lt;p&gt;此外多说一句，这个例子也可以回答为什么我们需要做描述性统计。我在这个回答&lt;a href=&#34;#fn3&#34; class=&#34;footnoteRef&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;里面提到过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;除以上原因外，还有个非常重要的原因，就是帮助读者和审稿人阅读回归表格。很多人做回归的时候，出于某些目的会对一些变量 scaling 等等，但是读者和审稿人往往希望知道这些变量的「经济显著性」究竟有多强。仅仅得到一个显著的结果往往是不够的，关心的变量&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;变动之后对结果&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;究竟有多大影响？因为单位的问题，有些时候往往难以比较。所以经常我们可能关心「当&lt;span class=&#34;math inline&#34;&gt;\(x\)&lt;/span&gt;变动一个标准差之后，&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;有多大的影响」，这个时候就需要使用描述性统计和回归表格结合起来一起看了。还有比如上面的&lt;code&gt;age&lt;/code&gt;同时有&lt;code&gt;age^2&lt;/code&gt;，那么当年龄增加&lt;span class=&#34;math inline&#34;&gt;\(1\)&lt;/span&gt;，平均而言会对&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;有多大影响呢？这个时候可能会需要&lt;code&gt;age&lt;/code&gt;的均值，同样需要诉诸于描述性统计。类似此类的问题，没有描述性统计的情况下，读者是没办法计算的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里给我们的一个启发就是，当我们阅读回归表格的时候，特别是遇到交叉项的时候，一定要结合着描述性统计去看。比如，有的回归结果去平均是不显著的，那么会报告不去平均的结果，这个时候如果配合着描述性统计，配合上面的三个式子，就能还原回真正的平均偏效应了。经验丰富的学者在阅读文章的时候是不会被这些小的 tricks 给迷惑的。&lt;/p&gt;
&lt;p&gt;最后硬广：欢迎来我的&lt;a href=&#34;https://wx.xiaomiquan.com/mweb/views/joingroup/join_group.html?group_id=4184844548&amp;amp;secret=j3par9d2nkzhtjjmun6icf0ikorw39xl&amp;amp;extra=4325db5fc7191b05efdfafe2aa4881029a8175111a2fb56d66c6807c353c29da&#34;&gt;小密圈&lt;/a&gt;交流：&lt;/p&gt;
&lt;hr /&gt;
&lt;blockquote class=&#34;gray&#34;&gt;
&lt;p&gt;&lt;strong&gt;李远哲&lt;/strong&gt;：学统计那一套的时候真没仔细想这个解释性问题，以为标准化变量是机器学习那一套的标准流程，为了做 gradient descent 的时候比较数值稳定才这么做的。&lt;/p&gt;
&lt;blockquote class=&#34;white&#34;&gt;
&lt;p&gt;&lt;strong&gt;慧航&lt;/strong&gt;：如果要做 shrinkage 降维之类的时候，那是一定要标准化的，关键是除以标准差而不是去平均。搞计量注重对参数的解释，所以标准化的原因是不一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&#34;gray&#34;&gt;
&lt;p&gt;&lt;strong&gt;毛士林&lt;/strong&gt;：想知道连续变量交乘的经济含义，应该怎么去解释。这种能够解释经济含义吗一般，比如&lt;span class=&#34;math inline&#34;&gt;\(x_1\)&lt;/span&gt;变动百分之多少，&lt;span class=&#34;math inline&#34;&gt;\(x_2\)&lt;/span&gt;的调节效应为多少。貌似如果&lt;span class=&#34;math inline&#34;&gt;\(x_2\)&lt;/span&gt;为 dummy 的话可以，比价容易解释？或者做分组回归，然后对系数差异进行t检验。不知道我之前的做法是否正确，也都是参考已经发表的文章的做法去做的。。&lt;/p&gt;
&lt;blockquote class=&#34;white&#34;&gt;
&lt;p&gt;&lt;strong&gt;慧航&lt;/strong&gt;：1) &lt;span class=&#34;math inline&#34;&gt;\(x_1\)&lt;/span&gt;对&lt;span class=&#34;math inline&#34;&gt;\(y\)&lt;/span&gt;的影响随着&lt;span class=&#34;math inline&#34;&gt;\(x_2\)&lt;/span&gt;的大小而不同。2) 系数的经济含义都可以用偏效应这个工具来做，伍德里奇面板数据的前两章一定要好好看。 3) 最好还是放在一个方差里面用 dummy 去检验，不要单独跑回归然后检验。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&#34;gray&#34;&gt;
&lt;p&gt;&lt;strong&gt;靠贩剑为生&lt;/strong&gt;：在还有交叉项的回归中，如果我最关注的是交叉项的系数，例如 &lt;span class=&#34;math inline&#34;&gt;\(x_1*x_2\)&lt;/span&gt;，那是否在回归的时候一定要加入单独的&lt;span class=&#34;math inline&#34;&gt;\(x_1\)&lt;/span&gt;项和&lt;span class=&#34;math inline&#34;&gt;\(x_2\)&lt;/span&gt;项呢？&lt;/p&gt;
&lt;blockquote class=&#34;white&#34;&gt;
&lt;p&gt;&lt;strong&gt;慧航&lt;/strong&gt;：一般来说是一定要的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote class=&#34;gray&#34;&gt;
&lt;p&gt;&lt;strong&gt;波波儿爸&lt;/strong&gt;：你做的偏相关模拟可能有问题。&lt;span class=&#34;math inline&#34;&gt;\(x_1\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(x_2\)&lt;/span&gt;本身&lt;code&gt;强&lt;/code&gt;相关，&lt;span class=&#34;math inline&#34;&gt;\(demeam\_x_1\)&lt;/span&gt; 和 &lt;span class=&#34;math inline&#34;&gt;\(demeam\_x_2\)&lt;/span&gt; 也强相关，所以两个回归 r-square 都高。期待你能试试用弱相关变量模拟一下？最后两个公式 &lt;span class=&#34;math inline&#34;&gt;\(r*demean\_x_2\)&lt;/span&gt; 的期望怎么等于 0 的？&lt;/p&gt;
&lt;blockquote class=&#34;white&#34;&gt;
&lt;p&gt;&lt;strong&gt;慧航&lt;/strong&gt;：(1) 对，我是为了举反例而已，故意为之；(2) 因为&lt;code&gt;demean, r_hat=r+op(1)&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;原文地址：&lt;a href=&#34;https://www.zhihu.com/question/55089869#answer-52600547&#34; class=&#34;uri&#34;&gt;https://www.zhihu.com/question/55089869#answer-52600547&lt;/a&gt;。&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;个人理解下式与上式对比时，只比较了&lt;span class=&#34;math inline&#34;&gt;\(x_1\)&lt;/span&gt;和&lt;span class=&#34;math inline&#34;&gt;\(x_2\)&lt;/span&gt;的系数，因此中括号中的部分根本没考虑。&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;原文地址：&lt;a href=&#34;https://www.zhihu.com/question/23074134#answer-49194682&#34; class=&#34;uri&#34;&gt;https://www.zhihu.com/question/23074134#answer-49194682&lt;/a&gt;。&lt;a href=&#34;#fnref3&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>用 Hexo&#43;Github 搭建博客平台</title>
      <link>/tech/2017/04/17/hexo/</link>
      <pubDate>Mon, 17 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/04/17/hexo/</guid>
      <description>
        &lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#-hexo&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1&lt;/span&gt; 为什么选择 Hexo&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.1&lt;/span&gt; 优点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;1.2&lt;/span&gt; (可能的)缺点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2&lt;/span&gt; 安装与配置&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.1&lt;/span&gt; 步骤简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.2&lt;/span&gt; 搭建本地博客&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.2.1&lt;/span&gt; 软件安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.2.2&lt;/span&gt; 博客平台搭建&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-next-&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.3&lt;/span&gt; 安装 NexT 主题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-site-_config.yml&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.4&lt;/span&gt; 修改博客配置 site: _config.yml&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.4.1&lt;/span&gt; 修改配置文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.4.2&lt;/span&gt; 添加一级页面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.4.3&lt;/span&gt; 重要功能插件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-next-_config.yml&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.5&lt;/span&gt; 修改主题配置 NexT: _config.yml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#-css&#34;&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.6&lt;/span&gt; 修改博客的 CSS&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.6.1&lt;/span&gt; 模板调整记录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;2.6.2&lt;/span&gt; 自定义样式文件调整记录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;3&lt;/span&gt; 远程部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a&gt;&lt;span class=&#34;toc-section-number&#34;&gt;4&lt;/span&gt; 应用问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;p&gt;参考内容：&lt;a href=&#34;http://qjzhixing.com/2015/08/26/&#34; class=&#34;uri&#34;&gt;http://qjzhixing.com/2015/08/26/&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;提醒&lt;/strong&gt;：出现其他任何的问题，先删除博客目录下的&lt;code&gt;db.json&lt;/code&gt;文件，然后清理再部署远程博客，操作时输入以下的命令&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;hexo clean
hexo d -g&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;-hexo&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;1&lt;/span&gt; 为什么选择 Hexo&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.1&lt;/span&gt; 优点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;速度&lt;/strong&gt;：目前&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;还不清楚 Hexo 在文章数量较多时的速度如何，但可以肯定 Hexo 的速度虽然比 Jekyll 要快得多（虽然与 Hugo 相比还是有较大差距）；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时刷新&lt;/strong&gt;：通过命令&lt;code&gt;hexo -s&lt;/code&gt;启动服务，接下来对内容文件进行任何更新都可以直接在浏览器中直接刷新看到更新后的结果；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;站内搜索&lt;/strong&gt;：在 NexT 主题可以轻松实现内建的搜索功能；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mathjax&lt;/strong&gt;：可以通过&lt;code&gt;hexo-renderer-pandoc&lt;/code&gt;实现 Markdown 和 Mathjax 的良好兼容（不清楚 Hugo 中如何使用 Pandoc）；&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- more --&gt;
&lt;p&gt;值得一提的是，Hexo 默认的 Markdown 渲染插件&lt;code&gt;hexo-renderer-marked&lt;/code&gt;功能较弱，与 Mathjax 的兼容也不太好&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;，虽然&lt;a href=&#34;http://shomy.top/2016/10/22/hexo-markdown-mathjax/&#34;&gt;&lt;code&gt;hexo-renderer-kramed&lt;/code&gt;&lt;/a&gt;在&lt;code&gt;hexo-renderer-marked&lt;/code&gt;的基础上完善了对 Mathjax 的支持，但在功能方面与&lt;code&gt;hexo-renderer-markdown-it&lt;/code&gt;相比还是太弱，可惜&lt;code&gt;hexo-renderer-markdown-it&lt;/code&gt;与 Mathjax 的兼容性也不太好，并且这个插件非常复杂，通过 Hack 方式改进对 Markdown 的支持也没有好的方案可以借鉴。&lt;/p&gt;
&lt;p&gt;总的来讲，Pandoc 的效果是最好的&lt;a href=&#34;#fn3&#34; class=&#34;footnoteRef&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;，唯一的缺点是需要单独安装 Pandoc，但考虑到只是将转换好的静态文件发布到 Github，这一缺点也基本上可以忽视。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;1.2&lt;/span&gt; (可能的)缺点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;没有直接的方法将&lt;code&gt;_post&lt;/code&gt;下的源文件按类别存放到不同的子目录中，但是 Hugo 可以；&lt;/li&gt;
&lt;li&gt;内建的内容汇总文件&lt;code&gt;db.json&lt;/code&gt;将来可能会非常大，同步到 Github 可能会比较慢，博客内建的搜索功能也可能会变得非常慢；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;hexo-renderer-pandoc&lt;/code&gt;不支持 emoji 表情插件，但&lt;code&gt;hexo-renderer-markdown-it&lt;/code&gt;中的子插件&lt;code&gt;markdown-it-emoji&lt;/code&gt;支持文本字符类型的表情；&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;2&lt;/span&gt; 安装与配置&lt;/h1&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.1&lt;/span&gt; 步骤简介&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;搭建&lt;strong&gt;本地&lt;/strong&gt;博客：在电脑上安装&lt;strong&gt;Git&lt;/strong&gt;、&lt;strong&gt;Node.js&lt;/strong&gt;和&lt;strong&gt;Pandoc&lt;/strong&gt;，利用简单的命令安装好&lt;strong&gt;Hexo&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;安装并配置&lt;strong&gt;NexT&lt;/strong&gt;主题：&lt;a href=&#34;http://notes.iissnan.com/2015/something-about-next/&#34;&gt;演示&lt;/a&gt;、&lt;a href=&#34;http://theme-next.iissnan.com/getting-started.html&#34;&gt;使用文档&lt;/a&gt;、&lt;a href=&#34;https://github.com/iissnan/hexo-theme-next&#34;&gt;主题文档&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;部署克隆版分站点；&lt;/li&gt;
&lt;li&gt;部署&lt;strong&gt;远程&lt;/strong&gt;博客；注册一个Github账号，然后在上面创建一个Repository，简单配置一下，博客的基本框架就建立好了；&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.2&lt;/span&gt; 搭建本地博客&lt;/h2&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.2.1&lt;/span&gt; 软件安装&lt;/h3&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;安装&lt;a href=&#34;http://git-scm.com/&#34;&gt;Git&lt;/a&gt;：安装过程一路默认即可，安装好后，单击右键就会多出两个Git的按钮；&lt;/li&gt;
&lt;li&gt;安装&lt;a href=&#34;https://nodejs.org/&#34;&gt;Node.js&lt;/a&gt;：可以一路默认，需要的话也可以更改一下安装的路径；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;安装 Hexo：&lt;a href=&#34;http://wiki.jikexueyuan.com/project/hexo-document/&#34;&gt;中文文档&lt;/a&gt;、&lt;a href=&#34;https://hexo.io/docs/&#34;&gt;英文文档&lt;/a&gt;；Hexo 的安装需要借助 Node.js 的&lt;code&gt;npm&lt;/code&gt;命令，可以理解为 Hexo 是 Node.js 的模块。操作的方式是在任意的位置单击鼠标右键，选择&lt;code&gt;Git bash&lt;/code&gt;命令，在里面输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g hexo-cli&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;卸载的话，将上面命令中的&lt;code&gt;install&lt;/code&gt;替换成&lt;code&gt;uninstall&lt;/code&gt;即可执行卸载。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.2.2&lt;/span&gt; 博客平台搭建&lt;/h3&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;创建 Hexo 文件夹&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;Hexo&lt;/code&gt;文件夹就是博客的文件夹，用于存放全部相关文件（但只有静态生成的文件必需上传到远程 Repository）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步先在某个盘符下新建一个文件夹，重命名（英文字母），假设是在&lt;code&gt;D&lt;/code&gt;盘下建立了一个名叫&lt;code&gt;Hexo&lt;/code&gt;的文件夹，那么路径就是&lt;code&gt;D:\hexo&lt;/code&gt; （后续的操作大多在这个文件夹里进行）；&lt;/li&gt;
&lt;li&gt;第二步进入Hexo文件夹单击右键，依旧选择&lt;code&gt;Git bash&lt;/code&gt;这一命令，输入以下命令，博客所需要的文件都已经自动建立好了，这比jekyll操作简单多了：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;hexo init&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;安装依赖包&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm install&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为保证下一环节远程部署成功，还需要执行如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo-deployer-git --save&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;预览本地博客&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一系列的安装命令之后，本地博客就算搭建好了，输入如下的命令，然后在浏览器地址栏中输入&lt;a href=&#34;http://localhost:4000&#34;&gt;&lt;code&gt;http://localhost:4000&lt;/code&gt;&lt;/a&gt;或者&lt;a href=&#34;http://127.0.0.1:4000&#34;&gt;&lt;code&gt;http://127.0.0.1:4000&lt;/code&gt;&lt;/a&gt;就可以查看本地博客。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo g
hexo s&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令中，&lt;code&gt;hexo g&lt;/code&gt;用于生成静态文件，&lt;code&gt;hexo s&lt;/code&gt;用于创建 Web 服务器，这两条命令可以合并写为一条：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo s -g&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;-next-&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.3&lt;/span&gt; 安装 NexT 主题&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;推荐先备份&lt;code&gt;_config.yml&lt;/code&gt;文件；&lt;/li&gt;
&lt;li&gt;进入到&lt;code&gt;hexo&lt;/code&gt;的目录，启动&lt;code&gt;Git bash&lt;/code&gt;，输入以下面的命令 Clone 主题：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;$ cd your-hexo-site
$ git clone https://github.com/iissnan/hexo-theme-next themes/next&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;在&lt;code&gt;_config.yml&lt;/code&gt;中修改&lt;code&gt;theme&lt;/code&gt;取值为&lt;code&gt;next&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;\hexo\themes\next\_config.yml&lt;/code&gt;中修改与主题相关的设置；&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;-site-_config.yml&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.4&lt;/span&gt; 修改博客配置 site: _config.yml&lt;/h2&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.4.1&lt;/span&gt; 修改配置文件&lt;/h3&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;修改&lt;code&gt;Site&lt;/code&gt;段相关内容，包括&lt;code&gt;title, author, language&lt;/code&gt;等，其中&lt;code&gt;language&lt;/code&gt;取值为&lt;code&gt;zh-Hans&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;参考 2.3 修改&lt;code&gt;theme&lt;/code&gt;取值为&lt;code&gt;NexT&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;修改&lt;code&gt;deploy&lt;/code&gt;段内容为：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;deploy:
  type: git
  repository: https://github.com/peng-howard/lives.git
  branch: master&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 repository 为&lt;code&gt;lives&lt;/code&gt;，本人的主页面&lt;code&gt;https://peng-howard.github.io/&lt;/code&gt;是用 Jekyll 生成的（直接在 GitHub 上修改&lt;code&gt;index.html&lt;/code&gt;似乎不起作用），因此这里将&lt;code&gt;lives&lt;/code&gt;相关内容作为主页面的一个分页面站点存在。如果是部署到 GitHub Pages 的主页面，则使用如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  repository: https://github.com/peng-howard/peng-howard.github.com.git&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;设定本人的社交信息及友情链接等：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;social:
  GitHub: https://github.com/your-user-name
  Twitter: https://twitter.com/your-user-name
  微博: http://weibo.com/your-user-name
  豆瓣: http://douban.com/people/your-user-name
  知乎: http://www.zhihu.com/people/your-user-name

social_icons:
  enable: true
  # Icon Mappings.
  # KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome
  GitHub: github
  Twitter: twitter
  Weibo: weibo
  微博: weibo

# 友情链接
# Blog rolls
links_title: 友情链接
#links_layout: block
#links_layout: inline
links:
  MacTalk: http://macshuo.com/
  Title: http://example.com/&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;设定每页文章显示篇数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一步：安装相关插件（&lt;del&gt;&lt;strong&gt;不必安装&lt;/strong&gt;&lt;/del&gt;：在安装完相关依赖包以后不再安装也是正常的，已经验证）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install --save hexo-generator-index
npm install --save hexo-generator-archive
npm install --save hexo-generator-tag&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二步：安装完插件后，在站点配置文件中，添加如下内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# index 为首页的每页数量
# archive 是存档页每页数量
# tag 不知道在哪里起作用

index_generator:
  per_page: 10
archive_generator:
  per_page: 50
  yearly: true
  monthly: true
tag_generator:
  per_page: 15

# 下面的 Pagination 是分类中，每个分类的目录页面中单页的文章数量
# Pagination
## Set per_page to 0 to disable pagination
per_page: 50
pagination_dir: page&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;index, archive&lt;/code&gt;及&lt;code&gt;tag&lt;/code&gt;开头分表代表主页，归档页面和标签页面。其中&lt;code&gt;per_page&lt;/code&gt;字段是希望设定的显示篇数。&lt;/p&gt;
&lt;ol start=&#34;6&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;修改&lt;code&gt;new_post_name&lt;/code&gt;取值为&lt;code&gt;:year-:month-:day-:title.md # File name of new posts&lt;/code&gt;，这样生成的文件名称不包含年月日部分。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.4.2&lt;/span&gt; 添加一级页面&lt;/h3&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;生成 RSS 文件&lt;code&gt;atom.xml&lt;/code&gt;，首先执行如下命令安装插件：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;npm install hexo-generator-feed --save&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在主配置文件中添加如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;feed:
  type: atom
  path: atom.xml
  limit: 20
  hub:
  content:&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;添加标签（tags）页面，首先执行如下命令：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;$ cd your-hexo-site
$ hexo new page tags&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：(1) 其中第一条命令可以不执行，改为先进入 blog 文件所在文件夹，再右键调出&lt;code&gt;Git&lt;/code&gt;命令行，然后直接执行第二条命令；(2) &lt;code&gt;hexo new page&lt;/code&gt;是建立一个新的文件夹，并在其中加入一个&lt;code&gt;index.md&lt;/code&gt;文件，相当于新建一个分站点，而&lt;code&gt;hexo new &amp;quot;...&amp;quot;&lt;/code&gt;是建立一篇新的文章。&lt;/p&gt;
&lt;p&gt;生成相关文件后，到&lt;code&gt;source/tags&lt;/code&gt;目录下修改&lt;code&gt;index.md&lt;/code&gt;文件为如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: 标签
date: 2014-12-22 12:39:04
type: &amp;quot;tags&amp;quot;
comments: false
---&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;添加分类页面：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;$ hexo new page categories&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后修改相关文件为如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
title: 分类
date: 2014-12-22 12:39:04
type: &amp;quot;categories&amp;quot;
comments: false
---&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.4.3&lt;/span&gt; 重要功能插件&lt;/h3&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;站内搜索&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在主目录中执行如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install hexo-generator-searchdb --save&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在主配置文件中添加如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;search:
  path: search.xml
  field: post
  format: html
  limit: 10000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在主题配置文件修改如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;local_search:
  enable: true&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在实际使用中，站内搜索要输入两个以上的字才会有搜索结果，并且可能会搜索不到内容。&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;为各级标题添加编号&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据&lt;a href=&#34;http://www.tuicool.com/articles/7BnIVnI&#34; class=&#34;uri&#34;&gt;http://www.tuicool.com/articles/7BnIVnI&lt;/a&gt;，Hexo 的 NexT 主题在右侧的导航栏中可以自动给各级标题添加编号，这利用了 Hexo 3 的一个最新功能，但是正文中却无法使用，因此这里用命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cnpm install hexo-heading-index --save&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装&lt;code&gt;hexo-heading-index&lt;/code&gt;命令，之后在主站点的&lt;code&gt;_config.yml&lt;/code&gt;中添加如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;heading_index:
  enable: true
  index_styles: &amp;quot;{1} {1} {1} {1} {1} {1}&amp;quot;
  connector: &amp;quot;.&amp;quot;
  global_prefix: &amp;quot;&amp;quot;
  global_suffix: &amp;quot; &amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后设定 NexT 主题配置文件&lt;code&gt;_config.yml&lt;/code&gt;中的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;toc:
  enable: true

  # Automatically add list number to toc.
  number: false&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;number&lt;/code&gt;取值为&lt;code&gt;false&lt;/code&gt;，这样在启动正文各级标题编号的同时，关闭右侧导航栏中的重复编号。&lt;/p&gt;
&lt;p&gt;需要注意的是，Hexo 的正文标题虽然用了&lt;code&gt;h1&lt;/code&gt;标记，但来自于头文件中的&lt;code&gt;title&lt;/code&gt;项。&lt;/p&gt;
&lt;p&gt;正文中建议仍然以&lt;code&gt;#&lt;/code&gt;开始第一级标题，否则标题的编号可能会出现意想不到的错误，比如&lt;code&gt;{1}&lt;/code&gt;对应的一级标题实际上会是&lt;code&gt;0&lt;/code&gt;，如果改成&lt;code&gt;{0}&lt;/code&gt;，又会在一级编号前出现一个&lt;code&gt;-&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;另外这个包的&lt;code&gt;index_styles&lt;/code&gt;中，一级的编号设定是必需的，其它级是可选的，希望将来一级可以选择为空。&lt;/p&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;code&gt;hexo-renderer-pandoc&lt;/code&gt;的 Markdown 渲染&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hexo 首先用配置文件&lt;code&gt;config.yml&lt;/code&gt;和安装的 Markdown 渲染插件对应的 Markdown 解释器对&lt;code&gt;.md&lt;/code&gt;文件进行处理，之后 Mathjax 或者其它在线 LaTeX 解释器再根据 Markdown 生成的结果解释其中的公式内容。考虑到 Hexo 自带的&lt;code&gt;hexo-renderer-marked&lt;/code&gt;，基于该插件的 LaTeX 修正版&lt;code&gt;hexo-renderer-kramed&lt;/code&gt;功能较弱，另一个解释器&lt;code&gt;hexo-renderer-marked-it&lt;/code&gt;虽然功能很强，但是和 LaTeX 的兼容不太好，在参考&lt;a href=&#34;http://shomy.top/2016/10/22/hexo-markdown-mathjax/&#34; class=&#34;uri&#34;&gt;http://shomy.top/2016/10/22/hexo-markdown-mathjax/&lt;/a&gt;之后，最终决定使用&lt;code&gt;hexo-renderer-pandoc&lt;/code&gt;作为&lt;code&gt;.md&lt;/code&gt;文件的解释器。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;到 &lt;a href=&#34;http://pandoc.org/installing.html&#34;&gt;Pandoc 官方站点&lt;/a&gt; 下载并安装 Pandoc&lt;a href=&#34;#fn4&#34; class=&#34;footnoteRef&#34; id=&#34;fnref4&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;；&lt;/li&gt;
&lt;li&gt;卸载默认的 Markdown 解释器并安装&lt;code&gt;hexo-renderer-pandoc&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;cnpm uninstall hexo-renderer-marked --save
cnpm install hexo-renderer-pandoc --save&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;根据&lt;a href=&#34;https://github.com/wzpan/hexo-renderer-pandoc&#34; class=&#34;uri&#34;&gt;https://github.com/wzpan/hexo-renderer-pandoc&lt;/a&gt;的提示，在站点的配置文件中，将 Markdown 部分的内容替换为&lt;code&gt;hexo-renderer-pandoc&lt;/code&gt;的默认配置：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;pandoc:
  filters:
  extra:
  meta:
  mathEngine:&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;考虑到没有空格的多行在一起组成一个段落时，CJK 类文本处理与英文不一样（后者之间将换行转换成一个空格），需要开启 Pandoc 的&lt;code&gt;east_asian_line_breaks&lt;/code&gt;扩展，具体方法是修改&lt;code&gt;hexo-renderer-pandoc&lt;/code&gt;的&lt;code&gt;index.js&lt;/code&gt;，将其中的&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;var args = [ &amp;#39;-f&amp;#39;, &amp;#39;markdown&amp;#39;, &amp;#39;-t&amp;#39;, &amp;#39;html&amp;#39;, math, &amp;#39;--smart&amp;#39;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;替换成&lt;a href=&#34;#fn5&#34; class=&#34;footnoteRef&#34; id=&#34;fnref5&#34;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var args = [ &amp;#39;-f&amp;#39;, &amp;#39;markdown+east_asian_line_breaks&amp;#39;, &amp;#39;-t&amp;#39;, &amp;#39;html&amp;#39;, math, &amp;#39;--smart&amp;#39;]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后，重新启动 Git 命令行，再重新启动 Hexo 服务就可以正常工作。&lt;/p&gt;
&lt;ol start=&#34;4&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;del&gt;Markdown 编译器的设定&lt;/del&gt;（&lt;strong&gt;不再使用&lt;/strong&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本部分除&lt;code&gt;fix-cjk&lt;/code&gt;外，marked 配置部分不再使用，改用 markdown-it 进行解释，详细参考下面第 5 点。最新进展：markdown-it 与 Mathjax 的兼容性也不太好，改为使用 pandoc 进行 md 的解释，并且 pandoc 中提供了 cjk space 问题的修正，因此 fix-cjk 也不再使用，具体配置见上面第 3 点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;问题&lt;/strong&gt;&lt;a href=&#34;#fn6&#34; class=&#34;footnoteRef&#34; id=&#34;fnref6&#34;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;：下面的设置保证 Markdown 中连着的两行不会被解释成为&lt;code&gt;&amp;lt;br/&amp;gt;&lt;/code&gt;，但是换行变成了&lt;code&gt;空格&lt;/code&gt;？（来自&lt;a href=&#34;https://wwssllabcd.github.io/blog/2014/12/22/how-to-install-hexo/&#34; class=&#34;uri&#34;&gt;https://wwssllabcd.github.io/blog/2014/12/22/how-to-install-hexo/&lt;/a&gt;）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由於新版的&lt;code&gt;Hexo&lt;/code&gt;使用&lt;code&gt;hexo-renderer-marked&lt;/code&gt;來控制&lt;code&gt;Markdown&lt;/code&gt;，而所以还要再调整一下，在站点配置文件中，添加如下内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# fix_cjk_spacing: false  # false 时停用 cjk 换行 - 空格 修正
# https://github.com/hexojs/hexo-renderer-marked
# breaks 遇到 CJK 字符时，会将换行符转成一个空格
# https://github.com/lotabout/hexo-filter-fix-cjk-spacing/issues/1
#          提供的方案可以部分修正这个问题，但要更新 npm 包到最新
marked:
  gfm: true
  pedantic: false
  sanitize: false
  tables: true
  breaks: false
  smartLists: true
  smartypants: false
  modifyAnchors: &amp;#39;&amp;#39;
  autolink: false&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;确保其中&lt;code&gt;breaks&lt;/code&gt;是为&lt;code&gt;false&lt;/code&gt;，此时&lt;code&gt;fix_cjk_spacing&lt;/code&gt;才会处于工作状态；另外还可以设定&lt;code&gt;fix_cjk_spacing: false&lt;/code&gt;以禁用这一修正功能（特别是纯英文的 blog）。&lt;/p&gt;
&lt;p&gt;但需要注意的是，&lt;code&gt;fix_cjk_spacing&lt;/code&gt;可能会出现如下的错误：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ npm install hexo-filter-fix-cjk-spacing --save
hexo-site@0.0.0 D:\GitHub\stylus
-- hexo-filter-fix-cjk-spacing@0.0.3

npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 (node_modules\chokidar\node_modules\fsevents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.1.1: wanted {&amp;quot;os&amp;quot;:&amp;quot;darwin&amp;quot;,&amp;quot;arch&amp;quot;:&amp;quot;any&amp;quot;} (current: {&amp;quot;os&amp;quot;:&amp;quot;win32&amp;quot;,&amp;quot;arch&amp;quot;:&amp;quot;x64&amp;quot;})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据 &lt;a href=&#34;https://github.com/npm/npm/issues/14042&#34; class=&#34;uri&#34;&gt;https://github.com/npm/npm/issues/14042&lt;/a&gt; 提供的信息，对&lt;code&gt;npm&lt;/code&gt;降级或者将&lt;code&gt;npm&lt;/code&gt;升级到最新版本可以解决这个问题，这里选择升级&lt;code&gt;npm&lt;/code&gt;。由于国内升级&lt;code&gt;npm&lt;/code&gt;可能无法成功，因此根据&lt;a href=&#34;https://npm.taobao.org/&#34; class=&#34;uri&#34;&gt;https://npm.taobao.org/&lt;/a&gt;的说明，安装命令&lt;code&gt;cnpm&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g cnpm --registry=https://registry.npm.taobao.org&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后用淘宝的镜像更新&lt;code&gt;npm&lt;/code&gt;（当然，还可以更新&lt;code&gt;cnpm&lt;/code&gt;本身，这个命令与&lt;code&gt;npm&lt;/code&gt;实质上是相同的，只是镜像在淘宝）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cnpm install -g npm&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安装&lt;code&gt;fix_cjk_spacing&lt;/code&gt;也可以：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cnpm install hexo-filter-fix-cjk-spacing --save&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后运行&lt;code&gt;hexo&lt;/code&gt;相关命令就不会再出错。&lt;/p&gt;
&lt;ol start=&#34;5&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;del&gt;Markdonw-it、脚注、表情设置&lt;/del&gt;（&lt;strong&gt;不再使用&lt;/strong&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hexo 的文章内容默认是不支持 emoji 表情的，作为一个有逼格的码农，怎么少得了丰富的表情语言，下面的内容介绍怎么支持 emoji。&lt;/p&gt;
&lt;p&gt;Hexo 默认的 markdown 编译插件是&lt;a href=&#34;https://github.com/hexojs/hexo-renderer-marked&#34;&gt;hexo-renderer-marked&lt;/a&gt;，看了一下相关文档，好像没办法支持 emoji，还好在 Hexo 的&lt;a href=&#34;https://hexo.io/plugins/&#34;&gt;plugins&lt;/a&gt;页，我们找到了另外一个 markdown 插件&lt;a href=&#34;https://github.com/celsomiranda/hexo-renderer-markdown-it&#34;&gt;hexo-renderer-markdown-it&lt;/a&gt;，而且号称速度比默认的还要快，最主要的是，在&lt;a href=&#34;https://github.com/markdown-it/markdown-it&#34;&gt;markdown-it&lt;/a&gt;的文档里面，我们发现它可以通过 plugins 的方式支持&lt;a href=&#34;https://github.com/markdown-it/markdown-it-emoji&#34;&gt;emoji&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下面我们就来替换 markdown 插件，首先进入博客的主目录（stylus）&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;cnpm un hexo-renderer-marked --save
cnpm i hexo-renderer-markdown-it --save&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不过此时的 hexo-renderer-markdown-it 还是用不了 emoji 的，我们需要加上 emoji 的 plugin&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;$ cd node_modules/hexo-renderer-markdown-it/
$ cnpm install markdown-it-emoji --save&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后编辑 Hexo 的配置文件&lt;code&gt;_config.yml&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# fix_cjk_spacing: false  # false 时停用 cjk 换行 - 空格 修正
# https://github.com/hexojs/hexo-renderer-marked
# breaks 遇到 CJK 字符时，会将换行符转成一个空格
# https://github.com/lotabout/hexo-filter-fix-cjk-spacing/issues/1 提供的方案可以修正这个问题，但要更新 npm 到最新
# MD-it 对 html 中的内容不起作用，但是 cjk-fix 会起作用
markdown:
  render:
    html: true
    xhtmlOut: false
    breaks: false
    linkify: true
    typographer: false
    quotes: &amp;#39;“”‘’&amp;#39;
  plugins:
    - markdown-it-footnote
    - markdown-it-sup
    - markdown-it-sub
    - markdown-it-abbr
    - markdown-it-emoji
  anchors:
    level: 1
    collisionSuffix: &amp;#39;v&amp;#39;
    permalink: false
    permalinkClass: header-anchor
    permalinkSymbol: ¶&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;与 Hexo 默认的 Markdown 引擎相比，这个引擎要严格一些：默认的引擎可以解释 html 中的 md 部分，但这个引擎在遇到 html 中的 md 时，会跳过去。&lt;/li&gt;
&lt;li&gt;注意上面的&lt;code&gt;xhtmlOut&lt;/code&gt;用于确保Markdown转换结果符合xhtml的规范；&lt;code&gt;typographer&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;用于确保&lt;code&gt;”“&lt;/code&gt;以及&lt;code&gt;’‘&lt;/code&gt;会自动被纠正为&lt;code&gt;“”&lt;/code&gt;和&lt;code&gt;‘’&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;MD-it 对 html 中的内容不起作用，但是 cjk-fix 会起作用，为了使用&lt;code&gt;&amp;lt;pre class=&amp;quot;center&amp;quot;&amp;gt;&lt;/code&gt;及&lt;code&gt;&amp;lt;pre class=&amp;quot;white&amp;quot;&amp;gt;&lt;/code&gt;，在&lt;code&gt;lives&lt;/code&gt;中禁用了&lt;code&gt;fix_cjk&lt;/code&gt;功能。&lt;/li&gt;
&lt;li&gt;关键就是在 plugins 里加上&lt;code&gt;- markdown-it-emoji&lt;/code&gt;，其他的配置说明可以参见&lt;a href=&#34;https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki/Advanced-Configuration&#34;&gt;wiki&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;重启Hexo服务，即可生效，这里输入&lt;code&gt;:smile: :smirk: :relieved:&lt;/code&gt;就可以显示表情符号，当然直接输入表情也是可以的，具体参考&lt;a href=&#34;https://github.com/markdown-it/markdown-it-emoji&#34; class=&#34;uri&#34;&gt;https://github.com/markdown-it/markdown-it-emoji&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;表情的安装参考上面的命令，而脚注确定不需要再安装任何包，下面是脚注的例子：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;Here is a footnote reference,[^1] and another.[^longnote]
 
[^1]: Here is the footnote.
 
[^longnote]: Here&amp;#39;s one with multiple blocks.
 
    Subsequent paragraphs are indented to show that they
belong to the previous footnote.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个例子中，“Subsequent…”也是脚注的一部分，因此脚注的结束符号将在“footnote.”之后。&lt;/p&gt;
&lt;p&gt;下面是一个 inline 的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Here is an inline note.^[Inlines notes are easier to write, since
you don&amp;#39;t have to pick an identifier and move down to type the
note.]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;-next-_config.yml&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.5&lt;/span&gt; 修改主题配置 NexT: _config.yml&lt;/h2&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;设定&lt;code&gt;mathjax&lt;/code&gt;取值为&lt;code&gt;true&lt;/code&gt;，打开 LaTeX 公式支持；&lt;/li&gt;
&lt;li&gt;设定&lt;code&gt;use_motion&lt;/code&gt;取值为&lt;code&gt;false&lt;/code&gt;，关闭页面加载时的动画效果，配置文件中提到&lt;code&gt;5.0.0 及更低版本中，侧栏在 use motion: false 下不会展示&lt;/code&gt;，这一说法没有具体印证；&lt;/li&gt;
&lt;li&gt;设定&lt;code&gt;scrollpercent&lt;/code&gt;取值为&lt;code&gt;true&lt;/code&gt;，这样在滚动页面时，右下角会出现当前页面所在位置的百分比；&lt;/li&gt;
&lt;li&gt;制作头像图片，保存为&lt;code&gt;source/images/avatar.png&lt;/code&gt;，设定主题配置文件中&lt;code&gt;avatar&lt;/code&gt;取值为&lt;code&gt;/images/avatar.png&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;设定&lt;code&gt;display&lt;/code&gt;取值为&lt;code&gt;hide&lt;/code&gt;，这样右侧边栏在页面加载时默认关闭，只能通过手工方式加载；&lt;/li&gt;
&lt;li&gt;设定&lt;code&gt;since&lt;/code&gt;取值为&lt;code&gt;2005&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;到&lt;a href=&#34;https://disqus.com/admin/&#34; class=&#34;uri&#34;&gt;https://disqus.com/admin/&lt;/a&gt;生成一个 shortname，并加入到主题配置文件中。现有网页上说的在右上角设置中生成的方法打不开；&lt;/li&gt;
&lt;li&gt;删除&lt;code&gt;themes\next\layout\_macro\post.swig&lt;/code&gt;中的&lt;code&gt;&amp;amp;raquo;&lt;/code&gt;，只保留“阅读全文”这四个字；&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div id=&#34;-css&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.6&lt;/span&gt; 修改博客的 CSS&lt;/h2&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.6.1&lt;/span&gt; 模板调整记录&lt;/h3&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;修改&lt;code&gt;theme/next/source/css/_variables/custom.styl&lt;/code&gt;文件，添加如下内容：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;// 修改成你期望的宽度
$content-desktop = 700px

// 当视窗超过 1600px 后的宽度
$content-desktop-large = 960px&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实际上本人在&lt;code&gt;theme/next/surce/css&lt;/code&gt;中增加了一个&lt;code&gt;haopeng.styl&lt;/code&gt;，并将其&lt;code&gt;import&lt;/code&gt;到&lt;code&gt;main.styl&lt;/code&gt;，用于添加自定义的具体样式内容，工作原理与&lt;code&gt;custom.styl&lt;/code&gt;文件非常接近。&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;next/source/css/_variables/base.styl&lt;/code&gt;中，将&lt;code&gt;$head-bg&lt;/code&gt;设定为&lt;code&gt;transparent&lt;/code&gt;。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改了页脚模板文件中的文字内容（&lt;code&gt;\themes\next\layout\_partials\footer.swig&lt;/code&gt;）；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;themes\next\languages&lt;/code&gt;中有对应的语言，注意关键词的名称是英文，可以在语言文件中修改或添加关键字，在主题配置文件中修改关键字对应的图标，&lt;a href=&#34;http://fontawesome.io/icons/&#34; class=&#34;uri&#34;&gt;http://fontawesome.io/icons/&lt;/a&gt;列出了全部可用的图标，考虑到最近一次修改的模板中不再使用图标，这一条的作用就暂时不再重要。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;修改&lt;code&gt;next/layout/_macro/post-collapse.swig&lt;/code&gt; 27 行的 date 的格式，添加年份，这样分类和归档页的标题中就包含年份，同时调整分类和标题页中的 css 的缩进。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在&lt;code&gt;next/layout/_macro/post.swig&lt;/code&gt;中，将&lt;code&gt;post-footer&lt;/code&gt;中的tag处的&lt;code&gt;#&lt;/code&gt;改成图标效果：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;i class=&amp;quot;fa fa-fw fa-tag&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;span class=&#34;header-section-number&#34;&gt;2.6.2&lt;/span&gt; 自定义样式文件调整记录&lt;/h3&gt;
&lt;p&gt;其它要修改的内容都在&lt;code&gt;haopeng.styl&lt;/code&gt;中，需要注意的是：(1) 一些CSS属性可能无法被覆盖，此时在指令后面加&lt;code&gt;!important&lt;/code&gt;强制覆盖；(2) 一部分下划线是通过&lt;code&gt;background-color&lt;/code&gt;实现的，另一些是通过&lt;code&gt;border-bottom&lt;/code&gt;实现的，因此需要根据实际情况做修改；(3) 主页与正文中的文章标题样式名称不相同，要分别修改；(4) 文章标题的文字大小只能通过&lt;code&gt;!important&lt;/code&gt;修改；(5) 存档目录页中的文章标题与时间在水平方向没对齐，这与修改了文章标题的文字大小有关，很难调整，最后是通过调整如下内容才做到的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* 存档页中文章标题与时间对齐 */
.post-title-link span {
    display: block;
}&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;分类页中文章数量用了浮动体样式；&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;将背景图片放置到&lt;code&gt;themes/next/source/images&lt;/code&gt;中，然后在自定义文件中加入如下内容：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;body { background: url(/images/bg.png) repeat; }&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;博客的页脚使用了 Galdeano 字体，原始的方法是通过 NexT 主题配置文件&lt;code&gt;_config.yaml&lt;/code&gt;下的 global 字段修改字体，这种方法会在线调用 Google 的远程字体。但这种方法有两个问题，一是放两种字体需要通过语法实现：&lt;code&gt;family: font1|font2&lt;/code&gt;，这种语法对应到&lt;code&gt;fonts.googleapis.com&lt;/code&gt;的查询字符串时，通过&lt;code&gt;|&lt;/code&gt;指定两种字体（如果字体名称有空格，用&lt;code&gt;+&lt;/code&gt;），但这种做法会导致正文、标题加载时将这两个字体组成的名称当成一个字体名称，这不是我们正常情形需要的，如果我们只指定一种字体，我们也可能不希望 NexT 自动把相关字体做全局修改。第二个问题是这样需要在线加载字体，即使通过&amp;lt;fonts.useso.com&amp;gt;加载可以提高速度，也未必是我们想要的做法，谁知道将来 360 会不会停止这一服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里推荐的做法是生成本地字体并加载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从&lt;a href=&#34;https://gist.github.com/dotJoel/7326331&#34; class=&#34;uri&#34;&gt;https://gist.github.com/dotJoel/7326331&lt;/a&gt;找到&lt;code&gt;Galdeano&lt;/code&gt;字体 ttf 文件的下载地址并下载该文件；&lt;/li&gt;
&lt;li&gt;到&lt;a href=&#34;https://www.fontsquirrel.com/tools/webfont-generator&#34; class=&#34;uri&#34;&gt;https://www.fontsquirrel.com/tools/webfont-generator&lt;/a&gt;，上传下载的字体并生成不同浏览器需要的字体文件；&lt;/li&gt;
&lt;li&gt;将字体文件放到&lt;code&gt;themes\next\source\lib\font-Galdeano&lt;/code&gt;之中，由于这里将&lt;code&gt;lives&lt;/code&gt;。当成站点下的子目录，因此这些文件实际上是放在&lt;code&gt;\lives\themes\next\source\lib\font-Galdeano&lt;/code&gt;里面（根据实际情况自己放置）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要说明的是，上面的 css 内容没有选择用&lt;a href=&#34;https://segmentfault.com/q/1010000005679305&#34; class=&#34;uri&#34;&gt;https://segmentfault.com/q/1010000005679305&lt;/a&gt;中介绍的用&lt;code&gt;https://fonts.googleapis.com/css?family=Galdeano&lt;/code&gt;里面的内容，这种方法只包含了&lt;code&gt;woff2&lt;/code&gt;文件，IE 下无法看到字体效果。而是主要选择用&lt;a href=&#34;http://smartgrid.ac.cn/63.html&#34; class=&#34;uri&#34;&gt;http://smartgrid.ac.cn/63.html&lt;/a&gt;提供的方法，根据下面的代码结合&lt;a href=&#34;https://www.fontsquirrel.com/tools/webfont-generator&#34; class=&#34;uri&#34;&gt;https://www.fontsquirrel.com/tools/webfont-generator&lt;/a&gt;中提供的 css 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@font-face {
font-family:&amp;#39;Tangerine-b&amp;#39;;
    src: url(&amp;#39;./font/Tangerine_Bold.eot&amp;#39;);
    src: url(&amp;#39;./font/Tangerine_Bold.eot?#iefix&amp;#39;) format(&amp;#39;embedded-opentype&amp;#39;),
         url(&amp;#39;./font/Tangerine_Bold.woff&amp;#39;) format(&amp;#39;woff&amp;#39;),
         url(&amp;#39;./font/Tangerine_Bold.ttf&amp;#39;) format(&amp;#39;truetype&amp;#39;),
         url(&amp;#39;./font/Tangerine_Bold.svg#tangerinebold&amp;#39;) format(&amp;#39;svg&amp;#39;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改后，在&lt;code&gt;haopeng.styl&lt;/code&gt;中添加如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/* latin */
@font-face {
  font-family: &amp;#39;Galdeano&amp;#39;;
  font-style: normal;
  font-weight: 400;
  src: url(&amp;#39;/lives/lib/font-Galdeano/galdeano-webfont.woff2&amp;#39;) format(&amp;#39;woff2&amp;#39;),
       url(&amp;#39;/lives/lib/font-Galdeano/galdeano-webfont.woff&amp;#39;) format(&amp;#39;woff&amp;#39;);
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215;
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因是生成的文件中没有&lt;code&gt;eot, svg&lt;/code&gt;类文件。&lt;/p&gt;
&lt;ol start=&#34;5&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;在线的思源宋体加载&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 2017.5 时，参考谢益辉的博客，将博客的主字体换成思源宋体，这个过程除了在&lt;code&gt;haopeng.styl&lt;/code&gt;中添加样式的支持外，还需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;next/layout/_partials/head.swig&lt;/code&gt;添加从谢站点上下载的&lt;code&gt;load-typekit.js&lt;/code&gt;文件，&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;script async src=&amp;quot;/stylus/js/load-typekit.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;：不使用注册 Adobe 的 Typekit 服务时提供的代码的原因是上面的脚本不仅能够实时加载思源宋体，还可以在加载之前先判断客户端是否已经安装思源宋体。Adobe 使用的 ID 需要在 VPN 下到 Adobe Typekit 注册，邮箱是&lt;code&gt;haopeng.yn@gmail.com|1A&lt;/code&gt;，用 Chrome 提供的翻墙功能注册后无法得到字体服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;将&lt;code&gt;load-typekit.js&lt;/code&gt;复制到合适的位置，将其中的&lt;code&gt;kitid&lt;/code&gt;改成这里的&lt;code&gt;oqz0fck&lt;/code&gt;，这个来自注册时候提供的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;Pandoc 生成的脚注编号中，&lt;code&gt;sup&lt;/code&gt;在&lt;code&gt;a&lt;/code&gt;之中，虽然修改&lt;code&gt;a&lt;/code&gt;的&lt;code&gt;display&lt;/code&gt;为&lt;code&gt;inline-flex&lt;/code&gt;或&lt;code&gt;inine-grid&lt;/code&gt;可以移动&lt;code&gt;a&lt;/code&gt;的下划线，但会导致&lt;code&gt;hover&lt;/code&gt;背景颜色失效，因此暂时不修改编号的链接效果，这与谢益辉的博客中&lt;code&gt;sup&lt;/code&gt;和&lt;code&gt;a&lt;/code&gt;的顺序刚好相反。（&lt;a href=&#34;https://github.com/jgm/pandoc/issues/2583&#34; class=&#34;uri&#34;&gt;https://github.com/jgm/pandoc/issues/2583&lt;/a&gt;）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其它 CSS 内容的修改非常多，所以这里不再一一解释。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;3&lt;/span&gt; 远程部署&lt;/h1&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;在 GitHub 上先新建一个 Repository（Public，不需要修改任何设置），然后在站点文件夹中用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;hexo d&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上传相关文件到远程。上传完成后，再到 GitHub 的 Repository 的设置中修改&lt;code&gt;GitHub Pages&lt;/code&gt;中的&lt;code&gt;Source&lt;/code&gt;为&lt;code&gt;master branch&lt;/code&gt;，这样就可以成功启动博客。在这个过程中可能会调出一个登陆 GitHub 的窗口，输入用户名和密码即可。&lt;/p&gt;
&lt;p&gt;由于之前已经配置过 SSH，因此上面不涉及这个过程。&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;配置 SSH（新机器可能需要）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;检查是否已经有 SSH Key，打开 Git Bash，输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cd ~/.ssh&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果没有这个目录，则生成一个新的 SSH，输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;your e-mail&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中，your e-mail 是注册 Github 时用到的邮箱。然后接下来几步都直接按回车键，最后生成相关内容文件。&lt;/p&gt;
&lt;p&gt;复制公钥内容到 Github 账户信息中&lt;/p&gt;
&lt;p&gt;打开&lt;code&gt;~/.ssh/id_rsa.pub&lt;/code&gt;文件，复制里面的内容；&lt;/p&gt;
&lt;p&gt;打开 Github 官网，登陆后进入到个人设置(点击头像 -&amp;gt; &lt;code&gt;setting&lt;/code&gt;)，点击右侧的&lt;code&gt;SSH Keys&lt;/code&gt;，点击&lt;code&gt;Add SSH key&lt;/code&gt;；填写&lt;code&gt;title&lt;/code&gt;之后，将之前复制的内容粘贴到&lt;code&gt;Key&lt;/code&gt;框中，最后点击&lt;code&gt;Add key&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;测试 SSH 是否配置成功，输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh -T git@github.com&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果显示以下，则说明 SSH 配置成功。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hi username! You&amp;#39;ve successfully authenticated, but GitHub does not provide shell access.&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;克隆子栏目&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;直接复制文件夹，新建 Repository 就可以。记得修改 CSS 中背景图片的位置，修改主题配置中站点的目录，修改主配置中的相关信息，修改模板等。&lt;/p&gt;
&lt;p&gt;一个特殊的问题是，在&lt;code&gt;node_modules&lt;/code&gt;发现了以&lt;code&gt;stylus&lt;/code&gt;为名称的子文件夹，这说明最初生成 Hexo 站点子目录&lt;code&gt;stylus&lt;/code&gt;时，写入了一些特殊信息，但直接复制这个文件夹似乎没有给另一个子站点&lt;code&gt;lives&lt;/code&gt;造成不良影响。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;section level1&#34;&gt;
&lt;h1&gt;&lt;span class=&#34;header-section-number&#34;&gt;4&lt;/span&gt; 应用问题&lt;/h1&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;不要用&lt;code&gt;NexT&lt;/code&gt;官方文档中的居中对齐样式，要居中自己直接用 HTML 实际就好；&lt;/li&gt;
&lt;li&gt;通过各种方法添加虾米音乐的外链播放都不成功，感觉是被禁止了；&lt;/li&gt;
&lt;li&gt;多个标签用&lt;code&gt;[...,...]&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hexo&lt;/code&gt;的四个主要命令：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;hexo g = hexo generate  #生成
hexo s = hexo server  #启动本地预览
hexo d = hexo deploy  #远程部署
hexo n &amp;quot;文章标题&amp;quot; = hexo new &amp;quot;文章标题&amp;quot;  #新建一篇博文&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中前三个命令经常组合用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo s -g
hexo d -g&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;奇怪的是在部署到远程时，出现过失效的现象，建议直接删除&lt;code&gt;_public&lt;/code&gt;文件夹，再重新生成页面，最后再部署，即生成和部署分开进行。更保险的做法是&lt;code&gt;hexo clean&lt;/code&gt;之后，再重新生成文件并部署。&lt;/p&gt;
&lt;ol start=&#34;5&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;将来新安装机器时，怎么做到用现有的文件进行覆盖安装还没有想通（一个可能的问题是基础平台、博客平台、主题都会有更新，当然在安装完 Git 和 Node.js 之后，其它内容可能都在站点子目录中，可以尝试直接覆盖这部分内容），不同机器内容的同步也没有好的方法。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Mathjax 支持带编号的公式&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在原有的&lt;code&gt;themes\next\layout\_third-party.mathjax.swig&lt;/code&gt;中添加如下内容：&lt;/p&gt;
&lt;pre class=&#34;javascript&#34;&gt;&lt;code&gt;&amp;lt;script type=&amp;quot;text/x-mathjax-config&amp;quot;&amp;gt;
MathJax.Hub.Config({
    TeX: {equationNumbers: {autoNumber: [&amp;quot;AMS&amp;quot;], useLabelIds: true}},
    &amp;quot;HTML-CSS&amp;quot;: {linebreaks: {automatic: true}},
    SVG: {linebreaks: {automatic: true}}
});
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后可以像 LaTeX 一样添加&lt;code&gt;\label{}&lt;/code&gt;以及&lt;code&gt;\eqref{}, \ref{}&lt;/code&gt;。&lt;/p&gt;
&lt;ol start=&#34;7&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;del&gt;Mathjax 与 Markdown 的冲突&lt;/del&gt;（&lt;strong&gt;用 Pandoc 后，不再存在&lt;/strong&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;a href=&#34;http://blog.csdn.net/emptyset110/article/details/50123231&#34; class=&#34;uri&#34;&gt;http://blog.csdn.net/emptyset110/article/details/50123231&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hexo 先用&lt;code&gt;marked.js&lt;/code&gt;渲染，然后再交给 MathJax 渲染。在&lt;code&gt;marked.js&lt;/code&gt;渲染的时候下划线&lt;code&gt;_&lt;/code&gt;是被 escape 掉并且换成了&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;标签，即斜体字，另外 LaTeX 中的&lt;code&gt;\\&lt;/code&gt;也会被转义成一个&lt;code&gt;\&lt;/code&gt;，这样会导致 MathJax 渲染时不认为它是一个换行符了。&lt;/p&gt;
&lt;p&gt;修改&lt;code&gt;marked.js&lt;/code&gt;源码的方式来避开这些问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;针对下划线的问题，取消&lt;code&gt;_&lt;/code&gt;作为斜体转义，因为&lt;code&gt;marked.js&lt;/code&gt;中&lt;code&gt;*&lt;/code&gt;也是斜体的意思，所以取消掉&lt;code&gt;_&lt;/code&gt;的转义并不影响我们使用markdown，只要我们习惯用&lt;code&gt;*&lt;/code&gt;作为斜体字标记就行了。&lt;/li&gt;
&lt;li&gt;针对&lt;code&gt;marked.js&lt;/code&gt;与Mathjax对于个别字符二次转义的问题，我们只要不让&lt;code&gt;marked.js&lt;/code&gt;去转义&lt;code&gt;\\,\{,\}&lt;/code&gt;在MathJax中有特殊用途的字符就行了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体修改方式，用编辑器打开&lt;code&gt;marked.js&lt;/code&gt;（在&lt;code&gt;./node_modules/marked/lib/&lt;/code&gt;中）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;escape: /^\\([\\`*{}\[\]()# +\-.!_&amp;gt;])/,1
em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;替换成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;escape: /^\\([`*\[\]()# +\-.!_&amp;gt;])/,1
em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;2017.5.28&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;可以通过 Hack &lt;code&gt;mark.js&lt;/code&gt;的方式做一些简单的优化，参考本文中相关内容或者&lt;a href=&#34;http://shomy.top/2016/10/22/hexo-markdown-mathjax/&#34; class=&#34;uri&#34;&gt;http://shomy.top/2016/10/22/hexo-markdown-mathjax/&lt;/a&gt;。&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;Pandoc 生成的脚注编号中, &lt;code&gt;sup&lt;/code&gt;在&lt;code&gt;a&lt;/code&gt;之中，虽然修改&lt;code&gt;a&lt;/code&gt;的&lt;code&gt;display&lt;/code&gt;为&lt;code&gt;inline-flex&lt;/code&gt;或&lt;code&gt;inine-grid&lt;/code&gt;可以移动&lt;code&gt;a&lt;/code&gt;的下划线位置，但会导致&lt;code&gt;hover&lt;/code&gt;背景颜色失效，因此暂时不修改编号的链接效果，&lt;a href=&#34;https://github.com/jgm/pandoc/issues/2583&#34; class=&#34;uri&#34;&gt;https://github.com/jgm/pandoc/issues/2583&lt;/a&gt;的讨论表明这个问题还没有正式的解决方案。&lt;a href=&#34;#fnref3&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34;&gt;&lt;p&gt;RStudio 的 Pandoc 只在 RStudio 中使用。&lt;a href=&#34;#fnref4&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn5&#34;&gt;&lt;p&gt;这里替换的思路来自&lt;a href=&#34;https://github.com/wzpan/hexo-renderer-pandoc&#34; class=&#34;uri&#34;&gt;https://github.com/wzpan/hexo-renderer-pandoc&lt;/a&gt;。&lt;a href=&#34;#fnref5&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn6&#34;&gt;&lt;p&gt;用 Pandoc 进行解释，这个问题已经得到解决。&lt;a href=&#34;#fnref6&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;

        
      </description>
    </item>
    
    <item>
      <title>ggimage：ggplot2中愉快地使用图片 z</title>
      <link>/tech/2017/03/29/ggimage/</link>
      <pubDate>Wed, 29 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/tech/2017/03/29/ggimage/</guid>
      <description>
        &lt;p&gt;&lt;strong&gt;原文地址&lt;/strong&gt;：&lt;a href=&#34;https://cos.name/2017/04/ggimage/&#34; target=&#34;_blank&#34;&gt;https://cos.name/2017/04/ggimage/&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;作者简介：余光创，香港大学公共卫生学院，生物信息学博士生。&lt;br /&gt;博客：&lt;a href=&#34;https://guangchuangyu.github.io&#34; target=&#34;_blank&#34;&gt;https://guangchuangyu.github.io&lt;/a&gt;， 公众号：biobabble&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;导言&#34;&gt;导言&lt;/h1&gt;

&lt;p&gt;本文介绍了&lt;strong&gt;ggimage&lt;/strong&gt;包，允许在&lt;strong&gt;ggplot2&lt;/strong&gt;作图时嵌入图片，并支持&lt;code&gt;aes&lt;/code&gt;映射，可以把离散型变量映射到不同图片。目前有几个包可以使用图片嵌入做图，但都是针对特定的场景，这里使用&lt;strong&gt;ggimage&lt;/strong&gt;来展示在这些特定领域里的应用，&lt;strong&gt;ggimage&lt;/strong&gt;的设计是通用的，并不被特定场景所限定，文末又介绍了用R图标来画出R、用饼图来画气泡图等实例。&lt;/p&gt;

&lt;!-- more --&gt;

&lt;h1 id=&#34;图上嵌图片&#34;&gt;图上嵌图片&lt;/h1&gt;

&lt;p&gt;R 基础图形库（base graphics）可以在做图的时候嵌入图片，使用的是&lt;code&gt;graphics::rasterImage&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;imgurl &amp;lt;- &amp;quot;http://phylopic.org/assets/images/submissions/295cd9f7-eef2-441e-ba7e-40c772ca7611.256.png&amp;quot;
library(EBImage)
x &amp;lt;- readImage(imgurl)
plot(1, type = &amp;quot;n&amp;quot;, xlab = &amp;quot;&amp;quot;, ylab = &amp;quot;&amp;quot;, xlim = c(0, 8), ylim = c(0, 8))
rasterImage(x, 2, 2, 6, 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/R/ggimage/raster.png&#34; alt=&#34;R绘图嵌入图片演示&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;如果我们搜索&amp;rdquo;ggplot2 image&amp;rdquo;，会找到类似于下面这样的帖子/博文：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/9917049/inserting-an-image-to-ggplot2&#34; target=&#34;_blank&#34;&gt;r - Inserting an image to ggplot2 - Stack Overflow&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.r-bloggers.com/add-a-background-png-image-to-ggplot2/&#34; target=&#34;_blank&#34;&gt;Add a background png image to ggplot2 | R-bloggers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;也就是说通过程序员秘笈，搜索，我们用&lt;strong&gt;ggplot2&lt;/strong&gt;同样也可以做到。&lt;/p&gt;

&lt;p&gt;这里我们需要用到&lt;code&gt;annotation_custom(rasterGrob)&lt;/code&gt;来把图片加到&lt;strong&gt;ggplot2&lt;/strong&gt;图形中，这和基础图形库是一模一样的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(grid)
library(ggplot2)

p &amp;lt;- ggplot(d = data.frame(x = c(0, 8), y = c(0, 8)), aes(x, y)) + geom_blank()
p + annotation_custom(rasterGrob(x), 2, 6, 2, 4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要使用图片来打点画一个散点图，我们就需要&lt;code&gt;for&lt;/code&gt;循环，对每一个点进行操作，这显然是底层的操作，而&lt;strong&gt;ggplot2&lt;/strong&gt;是一个高抽象的画图系统，我们希望能够使用&lt;strong&gt;ggplot2&lt;/strong&gt;的语法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ggimage&lt;/strong&gt;就是来实现这样一个功能，它只是一个简单的包，允许我们在ggplot2中把离散性变量映射到不同的图片来画图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/R/ggimage/Screenshot1.png&#34; alt=&#34;推特截屏：把图片当字体一样使用&#34; /&gt;&lt;/p&gt;

&lt;p&gt;实现这个功能的想法已经酝酿很久了，在&lt;strong&gt;ggtree&lt;/strong&gt;的开发中，我实现了&lt;code&gt;phylopic&lt;/code&gt;函数来使用Phylopic数据库的图片注释进化树，也实现了&lt;code&gt;subview&lt;/code&gt;函数在图上嵌入小图。用图片来注释进化树在进化分析上还是很常见的，特别是在一些分类学的研究中，需要把一些分类学特征在进化树上展示出来，而像我们做病毒，也经常会把一些图片放在进化树上来展示病毒的宿主信息。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ggtree&lt;/strong&gt;和可视化有关的函数分两类，一类是加注释的图层，另一类是可视化操作树（比如像旋转、合并分支）。操作树的都是普通函数，而加注释的都是&lt;code&gt;geom&lt;/code&gt;图层，除了&lt;code&gt;subview&lt;/code&gt;和&lt;code&gt;phylopic&lt;/code&gt;，这种所谓逼死处女座的存在，我早就想改成了&lt;code&gt;geom_subview&lt;/code&gt;和&lt;code&gt;geom_phylopic&lt;/code&gt;了（已实现），这也是为什么我要写&lt;strong&gt;ggimage&lt;/strong&gt;的原因了。&lt;/p&gt;

&lt;h1 id=&#34;安装&#34;&gt;安装&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;ggimage&lt;/strong&gt;依赖于&lt;strong&gt;EBImage&lt;/strong&gt;来读图片，这是个Bioconductor包，所以我们需要额外的动作来安装它，用&lt;code&gt;setRepositories&lt;/code&gt;把Bioconductor软件仓库加进来，这样&lt;code&gt;install.packages&lt;/code&gt;也可以搜索到它的包。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;setRepositories(ind = 1:2)
install.packages(&amp;quot;ggimage&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;实例分析&#34;&gt;实例分析&lt;/h1&gt;

&lt;p&gt;据我所知目前支持使用图片的R包有&lt;strong&gt;CatterPlots&lt;/strong&gt;, &lt;strong&gt;rphylopic&lt;/strong&gt;, &lt;strong&gt;emoGG&lt;/strong&gt;,&lt;strong&gt;ggflags&lt;/strong&gt;这几个，都是为特定的目的而实现的，都有其特定的应用场景，而&lt;strong&gt;ggimage&lt;/strong&gt;是的&lt;code&gt;geom_image&lt;/code&gt;是通用的，通过对它进行简单的包装，同样可以实现这些特殊场景的应用图层。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CatterPlots&lt;/strong&gt;这个包只可以应用于基础图形库（base graphics）中，通过预设的几个猫图（R对象，随包载入）来画散点图。最近&lt;a href=&#34;http://blog.revolutionanalytics.com/2017/02/catterplots-plots-with-cats.html&#34; target=&#34;_blank&#34;&gt;RevolutionAnalytics 有博文&lt;/a&gt;介绍。&lt;strong&gt;ggplot2&lt;/strong&gt;没有相应画猫的包。我们可以使用&lt;strong&gt;ggimage&lt;/strong&gt;来画，而且不用限制于&lt;strong&gt;CatterPlots&lt;/strong&gt;预设的几个图形。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(ggplot2)
library(ggimage)

mytheme &amp;lt;- theme_minimal() +
    theme(axis.title = element_blank())
theme_set(mytheme)

x &amp;lt;- seq(-2 * pi, 2 * pi, length.out = 30)
d &amp;lt;- data.frame(x = x, y = sin(x))

img &amp;lt;- &amp;quot;http://www.belleamibengals.com/bengal_cat_2.png&amp;quot;
ggplot(d, aes(x, y)) + geom_image(image = img, size = .1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/R/ggimage/ggimage_CatterPlots.png&#34; alt=&#34;ggimage画猫散点图演示&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;CatterPlots&lt;/strong&gt;实现的方式就是上面谈到的&lt;code&gt;rasterImage&lt;/code&gt;内部使用了循环。&lt;strong&gt;rphylopic&lt;/strong&gt;同时支持基础图形库（base graphics）和&lt;strong&gt;ggplot2&lt;/strong&gt;，也是一样的实现方式，不过&lt;strong&gt;rphylopic&lt;/strong&gt;内部没有使用循环，一次只能加一个图，它使用的图来自于&lt;a href=&#34;http://phylopic.org/&#34; target=&#34;_blank&#34;&gt;phylopic&lt;/a&gt;数据库。&lt;/p&gt;

&lt;p&gt;我们用&lt;strong&gt;ggimage&lt;/strong&gt;同样可以使用&lt;code&gt;phylopic&lt;/code&gt;图片：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;ggplot(d, aes(x, y)) + geom_phylopic(image = &amp;quot;500bd7c6-71c1-4b86-8e54-55f72ad1beca&amp;quot;, size = .1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/R/ggimage/ggimage_rphylopic.png&#34; alt=&#34;ggimage使用phylopic图片演示&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;图中是&lt;code&gt;翼足目&lt;/code&gt;动物。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;emoGG&lt;/strong&gt;是专门来画&lt;code&gt;emoji&lt;/code&gt;的，如果要画&lt;code&gt;emoji&lt;/code&gt;的话，我推荐我写的&lt;strong&gt;emojifont&lt;/strong&gt;包，在轩哥的&lt;a href=&#34;https://cos.name/2014/01/showtext-interesting-fonts-and-graphs/&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;showtext&lt;/strong&gt;基础&lt;/a&gt;上，把&lt;code&gt;emoji&lt;/code&gt;当做普通字体一样操作，更方便。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;emoGG&lt;/strong&gt;这个包提供了&lt;code&gt;geom_emoji&lt;/code&gt;图层，虽然一次可以画出散点，但因为不支持&lt;code&gt;aes&lt;/code&gt;映射，而&lt;strong&gt;ggimage&lt;/strong&gt;所提供的&lt;code&gt;geom_emoji&lt;/code&gt;则支持映射，下面的例子中我们做了一个简单的回归分析，如果残差&lt;code&gt;&amp;lt;0.5&lt;/code&gt;用笑脸表示，&lt;code&gt;&amp;gt;0.5&lt;/code&gt;则用哭脸来表示。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;set.seed(123)
iris2 &amp;lt;- iris[sample(1:nrow(iris), 30), ]
model &amp;lt;- lm(Petal.Length ~ Sepal.Length, data = iris2)
iris2$fitted &amp;lt;- predict(model)

p &amp;lt;- ggplot(iris2, aes(x = Sepal.Length, y = Petal.Length)) +
  geom_linerange(aes(ymin = fitted, ymax = Petal.Length),
                 colour = &amp;quot;purple&amp;quot;) +
  geom_abline(intercept = model$coefficients[1],
              slope = model$coefficients[2])

p + ggimage::geom_emoji(aes(image = ifelse(abs(Petal.Length-fitted) &amp;gt; 0.5, &#39;1f622&#39;, &#39;1f600&#39;)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/R/ggimage/emoji_residual2.png&#34; alt=&#34;ggimage画emoji演示&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如果要用&lt;strong&gt;emoGG&lt;/strong&gt;来做的话，则需要自己切数据分两次来进行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;p + emoGG::geom_emoji(data = subset(iris2, (Petal.Length-fitted) &amp;lt; 0.5), emoji = &amp;quot;1f600&amp;quot;) +
    emoGG::geom_emoji(data = subset(iris2, (Petal.Length-fitted) &amp;gt; 0.5), emoji = &amp;quot;1f622&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里我们只分两类(残差是否大于0.5)，所以需要加两次，试想我们的分类变量有多种可能的取值，则我们需要分多次切数据加图层，&lt;strong&gt;CatterPlots&lt;/strong&gt;、&lt;strong&gt;rphylopic&lt;/strong&gt;和&lt;strong&gt;emoGG&lt;/strong&gt;都有这个问题，这也是&lt;code&gt;aes&lt;/code&gt;映射之于&lt;strong&gt;ggplot2&lt;/strong&gt;的重要和强大之处，它让我们可以在更高的抽像水平思考，&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ggflags&lt;/strong&gt;是支持&lt;code&gt;aes&lt;/code&gt;映射的，只不过它只能用来画国旗而已。同样&lt;strong&gt;ggimage&lt;/strong&gt;也提供了相应的&lt;code&gt;geom_flag&lt;/code&gt;来使用国旗用于做图。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(rvest)
library(dplyr)

url &amp;lt;- &amp;quot;http://www.nbcolympics.com/medals&amp;quot;

medals &amp;lt;- read_html(url) %&amp;gt;%
    html_nodes(&amp;quot;table&amp;quot;) %&amp;gt;%
    html_table() %&amp;gt;% .[[1]]

library(countrycode)
library(tidyr)

medals &amp;lt;- medals %&amp;gt;%
    mutate(code = countrycode(Country, &amp;quot;country.name&amp;quot;, &amp;quot;iso2c&amp;quot;)) %&amp;gt;%
    gather(medal, count, Gold:Bronze) %&amp;gt;%
    filter(Total &amp;gt;= 10)

head(medals)
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Country&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Total&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;code&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;medal&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;count&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Russia&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;33&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;RU&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Gold&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;13&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;United States&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;28&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;US&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Gold&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Norway&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;26&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Gold&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;11&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Canada&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;25&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;CA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Gold&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;10&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Netherlands&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;24&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;NL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Gold&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Germany&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;19&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;DE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Gold&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;首先我们从网站上爬回来2016年各个国家的奥林匹克奖牌数，画出柱状图，并在&lt;code&gt;xlab&lt;/code&gt;国家名边上用&lt;strong&gt;ggimage&lt;/strong&gt;画上国旗：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;p &amp;lt;- ggplot(medals, aes(Country, count)) + geom_col(aes(fill = medal), width = .8)

p + geom_flag(y = -2, aes(image = code)) +
    coord_flip() + expand_limits(y = -2)  +
    scale_fill_manual(values = c(&amp;quot;Gold&amp;quot; = &amp;quot;gold&amp;quot;, &amp;quot;Bronze&amp;quot; = &amp;quot;#cd7f32&amp;quot;, &amp;quot;Silver&amp;quot; = &amp;quot;#C0C0C0&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/R/ggimage/olympics_2016.png&#34; alt=&#34;ggimage画国旗演示&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ggimage&#34;&gt;&lt;strong&gt;ggimage&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;前面我们介绍了&lt;strong&gt;ggimage&lt;/strong&gt;在一些场景的应用实例，虽然有专门的包针对这些应用场景，但&lt;strong&gt;ggimage&lt;/strong&gt;在这些领域中的表现要比大多数的包要好（支持aes映射）。但&lt;strong&gt;ggimage&lt;/strong&gt;的使用并不限于这些(&lt;code&gt;geom_phylopic&lt;/code&gt;，&lt;code&gt;geom_emoji&lt;/code&gt;和&lt;code&gt;geom_flag&lt;/code&gt;只是通用图层&lt;code&gt;geom_image&lt;/code&gt;的简单封装)，这里将展示一些有趣的例子。&lt;/p&gt;

&lt;h3 id=&#34;用r图标来画r形状&#34;&gt;用R图标来画R形状&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;x &amp;lt;- c(2, 2, 2, 2, 2, 3, 3, 3.5, 3.5, 4)
y &amp;lt;- c(2, 3, 4, 5, 6, 4, 6, 3, 5, 2)
d &amp;lt;- data.frame(x = x, y = y)

img &amp;lt;- system.file(&amp;quot;img&amp;quot;, &amp;quot;Rlogo.png&amp;quot;, package = &amp;quot;png&amp;quot;)
ggplot(d, aes(x, y)) + geom_image(image = img, size = .1) +
  xlim(0, 6) + ylim(0, 7)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/R/ggimage/R.png&#34; alt=&#34;用R图标画R形状演示&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;嵌套式绘图&#34;&gt;嵌套式绘图&lt;/h3&gt;

&lt;p&gt;这里我要展示的是非常有名的气泡图（Bubble Plot），但气泡不是圆圈，而是使用&lt;strong&gt;ggplot2&lt;/strong&gt;画的饼图，我先把饼图保存起来，再用&lt;strong&gt;ggimage&lt;/strong&gt;拿来画，饼图的大小与人口总数正相关。这个例子可以应用到很多场景中去，比如一个时间序列的曲线，你要用统计图在某些时间点上展示相关的信息，比如你要在地图上加某些地方的相关统计信息（如果要在地图上画饼图，可以使用我写的&lt;a href=&#34;https://cran.r-project.org/package=scatterpie&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;scatterpie&lt;/strong&gt;&lt;/a&gt;包）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;crime &amp;lt;- read.csv(&amp;quot;http://datasets.flowingdata.com/crimeRatesByState2005.tsv&amp;quot;,
                  header = TRUE, sep = &amp;quot;\t&amp;quot;, stringsAsFactors = F)
&lt;/code&gt;&lt;/pre&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;state&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;murder&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Forcible_rate&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;Robbery&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;aggravated_assult&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;burglary&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;larceny_theft&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;motor&lt;em&gt;vehicle&lt;/em&gt;theft&lt;/th&gt;
&lt;th align=&#34;right&#34;&gt;population&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Alabama&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;8.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;34.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;141.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;247.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;953.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2650.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;288.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4627851&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Alaska&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;81.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;80.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;465.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;622.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2599.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;391.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;686293&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Arizona&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;33.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;144.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;327.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;948.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2965.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;924.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6500180&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Arkansas&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;42.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;91.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;386.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1084.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2711.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;262.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2855390&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;California&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;6.9&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;26.0&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;176.1&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;317.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;693.3&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;1916.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;712.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;36756666&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Colorado&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;3.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;43.4&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;84.6&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;264.7&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;744.8&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2735.2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;559.5&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4861515&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;library(gtable)

plot_pie &amp;lt;- function(i) {
    df &amp;lt;- gather(crime[i, ], type, value, murder:motor_vehicle_theft)
    ggplot(df, aes(x = 1, value, fill = type)) +
        geom_col() + coord_polar(theta = &#39;y&#39;) +
        ggtitle(crime[i, &amp;quot;state&amp;quot;]) +
        theme_void() + theme_transparent() +
        theme(legend.position = &amp;quot;none&amp;quot;,
              plot.title = element_text(size = rel(6), hjust = 0.5))
}

pies &amp;lt;- sapply(1:nrow(crime), function(i) {
    outfile &amp;lt;- paste0(&amp;quot;crime_&amp;quot;, i, &amp;quot;.png&amp;quot;)
    plot_pie(i) + ggsave(outfile, bg = &amp;quot;transparent&amp;quot;)
    outfile
})

radius &amp;lt;- sqrt(crime$population / pi)
crime$radius &amp;lt;- 0.2 * radius/max(radius)
crime$pie &amp;lt;- pies

leg1 &amp;lt;- gtable_filter(
    ggplot_gtable(
        ggplot_build(plot_pie(1) + theme(legend.position = &amp;quot;right&amp;quot;))
    ), &amp;quot;guide-box&amp;quot;)

ggplot(crime, aes(murder, Robbery)) +
  geom_image(aes(image = pie, size = I(radius))) +
  geom_subview(leg1, x = 8.8, y = 50)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/R/ggimage/us_crime.png&#34; alt=&#34;嵌套式绘图演示：用饼图来画气泡图&#34; /&gt;&lt;/p&gt;

&lt;p&gt;我们还可以每次只画一个州的数据，制作成动图。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-r&#34;&gt;plot_crime &amp;lt;- function(i) {
    o &amp;lt;- paste0(i, &amp;quot;.png&amp;quot;)
    ggplot(crime, aes(murder, Robbery)) + geom_blank() +
        geom_image(data = crime[i, ], aes(image = pie, size = I(radius))) +
        geom_subview(p, leg1, x = 8.8, y = 50) + ggsave(o)
    o
}

library(magick)
library(purrr)
order(crime$murder, decreasing = F) %&amp;gt;%
    map(plot_crime) %&amp;gt;%
    map(image_read) %&amp;gt;%
    image_join() %&amp;gt;%
    image_animate(fps = 2) %&amp;gt;%
    image_write(&amp;quot;crime.gif&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/R/ggimage/us_crime.gif&#34; alt=&#34;嵌套式绘图演示，动图版本&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;geom_subview&lt;/code&gt;可以图上嵌图，并不需要保存为图片，但对于&lt;strong&gt;ggplot2&lt;/strong&gt;来讲，保存图片也是有好处的，因为&lt;strong&gt;ggplot2&lt;/strong&gt;画图，点线是在数据空间上，随着我们保存图片的大小是按比例缩小或放大的，但文字是在像素空间上，和画图空间并不相关。所以当我们嵌图时缩小了画图窗口之后，字体会显得格外大，微调起来也比较繁琐，这时候保存为合适尺寸的图片，再用&lt;code&gt;geom_image&lt;/code&gt;来加上去，显然就轻松得多。&lt;/p&gt;

&lt;h3 id=&#34;其它来自r社区的例子&#34;&gt;其它来自R社区的例子&lt;/h3&gt;

&lt;p&gt;SAS博客对&lt;code&gt;M&amp;amp;M&lt;/code&gt;巧克力的&lt;a href=&#34;http://blogs.sas.com/content/iml/2017/02/20/proportion-of-colors-mandms.html&#34; target=&#34;_blank&#34;&gt;颜色分布做了分析&lt;/a&gt;，通过模拟估计不同颜色的置信区间。这个&lt;a href=&#34;http://rpubs.com/hrbrmstr/mms&#34; target=&#34;_blank&#34;&gt;分析被翻译成R&lt;/a&gt;，并产生下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/R/ggimage/mm.png&#34; alt=&#34;M&amp;amp;M例子展示&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其中垂直片段|是真实值，水平片段当然就是置信空间了，而估计值用了&lt;strong&gt;ggimage&lt;/strong&gt;来画不同颜色的巧克力。&lt;/p&gt;

&lt;p&gt;另一个例子是&lt;a href=&#34;https://rpubs.com/bhaskarvk/disney&#34; target=&#34;_blank&#34;&gt;迪斯尼电影主人公名字的流行程度&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/R/ggimage/Screenshot3.png&#34; alt=&#34;迪斯尼例子展示&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最近我还添加了&lt;code&gt;geom_pokemon&lt;/code&gt;图层，让大家可以用pokemon来画图，比如：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/R/ggimage/geom_pokemon.png&#34; alt=&#34;pokemon例子展示&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ggimage&lt;/strong&gt;是通用的包，所以可以被应用于不同的领域/场景中，起码可以让我们画出更好玩的图出来，后续我有时间的话，会写一个&lt;code&gt;draw_key_image&lt;/code&gt;的函数，实现使用图片来当legend key的功能。&lt;/p&gt;

&lt;p&gt;最后祝大家玩得开心！不要把图画得太有魔性哦:)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/images/Tech/R/ggimage/Screenshot2.png&#34; alt=&#34;推特截屏&#34; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;感谢大为和太云的校稿，特别是大为提出很多修改意见以及给出了用R画R的例子。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;参考资料&#34;&gt;参考资料&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://stackoverflow.com/questions/9917049/inserting-an-image-to-ggplot2&#34; target=&#34;_blank&#34;&gt;https://stackoverflow.com/questions/9917049/inserting-an-image-to-ggplot2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.r-bloggers.com/add-a-background-png-image-to-ggplot2/&#34; target=&#34;_blank&#34;&gt;https://www.r-bloggers.com/add-a-background-png-image-to-ggplot2/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/GuangchuangYu/ggimage&#34; target=&#34;_blank&#34;&gt;https://github.com/GuangchuangYu/ggimage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/Gibbsdavidl/CatterPlots&#34; target=&#34;_blank&#34;&gt;https://github.com/Gibbsdavidl/CatterPlots&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/sckott/rphylopic&#34; target=&#34;_blank&#34;&gt;https://github.com/sckott/rphylopic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/baptiste/ggflags&#34; target=&#34;_blank&#34;&gt;https://github.com/baptiste/ggflags&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.revolutionanalytics.com/2017/02/catterplots-plots-with-cats.html&#34; target=&#34;_blank&#34;&gt;http://blog.revolutionanalytics.com/2017/02/catterplots-plots-with-cats.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blogs.sas.com/content/iml/2017/02/20/proportion-of-colors-mandms.html&#34; target=&#34;_blank&#34;&gt;http://blogs.sas.com/content/iml/2017/02/20/proportion-of-colors-mandms.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://rpubs.com/hrbrmstr/mms&#34; target=&#34;_blank&#34;&gt;http://rpubs.com/hrbrmstr/mms&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rpubs.com/bhaskarvk/disney&#34; target=&#34;_blank&#34;&gt;https://rpubs.com/bhaskarvk/disney&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://cran.r-project.org/package=scatterpie&#34; target=&#34;_blank&#34;&gt;https://cran.r-project.org/package=scatterpie&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
        
      </description>
    </item>
    
  </channel>
</rss>
